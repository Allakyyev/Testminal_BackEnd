import { TableCell } from '../../../../../../core/model/tables/main-structures/table-cell';
import { ConditionalTableStyleFormatting, TableCellMergingState } from '../../../../../../core/model/tables/secondary-structures/table-base-structures';
import { Pair } from '@devexpress/utils/lib/class/pair';
import { NumberMapUtils } from '@devexpress/utils/lib/utils/map/number';
import { BaseFormatter, StdProps } from '../../base-formatter';
export class CCF_TableCell extends BaseFormatter {
    isHandleObject(obj) {
        return obj instanceof TableCell;
    }
    getShortDescription(_config) {
        const list = [
            new Pair("", this.getIndex() + ":"),
            new Pair("", `[${this.curr.startParagraphPosition.value}, ${this.curr.endParagrapPosition.value}]`),
        ];
        if (this.curr.columnSpan > 1)
            list.push(new Pair("cols", this.curr.columnSpan));
        if (this.curr.verticalMerging != TableCellMergingState.None)
            list.push(new Pair("vertMerg", TableCellMergingState[this.curr.verticalMerging]));
        return this.stdShow(new StdProps(list).showAsLine());
    }
    availableFullDescription(_config) {
        return true;
    }
    getFullDescription(_config) {
        const list = [
            new Pair("index", this.getIndex()),
            new Pair("preferredWidth", this.curr.preferredWidth),
            new Pair("columnSpan", this.curr.columnSpan),
            new Pair("interval", this.curr.interval),
            new Pair("text", this.getRawText(this.getSubDocument().getText(this.curr.interval)).setLen(30)),
            new Pair("runsOnCell", this.getSubDocument().getRunsByInterval(this.curr.interval)),
            new Pair("properties", this.curr.properties),
            new Pair("conditionalFormatting", ConditionalTableStyleFormatting[this.curr.conditionalFormatting]),
            new Pair("style", this.curr.style),
            new Pair("verticalMerging", TableCellMergingState[this.curr.verticalMerging]),
            new Pair("parentRow", this.curr.parentRow),
        ];
        return this.stdShow(new StdProps(list).showAsColumn());
    }
    getIndex() {
        return this.curr.parentRow.cells.indexOf(this.curr);
    }
    getSubDocument() {
        return NumberMapUtils.elementBy(this.model.subDocuments, (subDoc) => subDoc.tables[this.curr.parentRow.parentTable.index] == this.curr.parentRow.parentTable);
    }
}
CCF_TableCell._foo = BaseFormatter.addToFormattersList(new CCF_TableCell());
