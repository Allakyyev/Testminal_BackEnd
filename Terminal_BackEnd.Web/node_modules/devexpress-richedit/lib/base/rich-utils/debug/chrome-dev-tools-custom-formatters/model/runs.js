import { InlinePictureRun } from '../../../../../core/model/runs/inline-picture-run';
import { RunBase } from '../../../../../core/model/runs/run-base';
import { RunType } from '../../../../../core/model/runs/run-type';
import { Pair } from '@devexpress/utils/lib/class/pair';
import { Errors } from '@devexpress/utils/lib/errors';
import { FixedInterval } from '@devexpress/utils/lib/intervals/fixed';
import { ListUtils } from '@devexpress/utils/lib/utils/list';
import { NumberMapUtils } from '@devexpress/utils/lib/utils/map/number';
import { BaseFormatter, StdProps } from '../base-formatter';
import { ShortString } from '../short-string';
export class CCF_RunBase extends BaseFormatter {
    isHandleObject(obj) {
        return obj instanceof RunBase;
    }
    getShortDescription(_config) {
        const list = [
            new Pair("", RunType[this.curr.getType()]),
            new Pair("", `[${this.curr.startOffset}, ${this.curr.startOffset + this.curr.getLength()}]`),
        ];
        if (this.curr.getType() == RunType.TextRun)
            list.push(new Pair("", new ShortString(this.getText())));
        if (this.curr.getType() == RunType.AnchoredPictureRun || this.curr.getType() == RunType.InlinePictureRun) {
            const r = this.curr;
            const size = r.size.actualSize;
            list.push(new Pair("", this.getPictureNode(r.cacheInfo.currId, size)));
        }
        if (this.curr.getType() == RunType.AnchoredTextBoxRun)
            list.push(new Pair("txt", this.getSubDocumentText(this.curr.subDocId)));
        return this.stdShow(new StdProps(list).showAsLine());
    }
    availableFullDescription(_config) {
        return true;
    }
    getFullDescription(_config) {
        const list = [
            new Pair("type", RunType[this.curr.getType()]),
            new Pair("offset", this.curr.startOffset),
            new Pair("endOffset", this.curr.startOffset + this.curr.getLength()),
            new Pair("length", this.curr.getLength()),
            new Pair("maskedCharacterProperties", this.curr.maskedCharacterProperties),
            new Pair("mergedCharacterProperies", this.curr.getCharacterMergedProperties()),
            new Pair("charStyle", this.curr.characterStyle),
            new Pair("paragraph", this.curr.paragraph),
        ];
        switch (this.curr.getType()) {
            case RunType.TextRun:
                list.push(new Pair("text", new ShortString(this.getText())));
                break;
            case RunType.InlinePictureRun: {
                list.push(new Pair("nextPublicAPIId", InlinePictureRun.nextPublicAPIId));
                this.addPicRunInfo(list);
                break;
            }
            case RunType.AnchoredPictureRun: {
                this.addPicRunInfo(list);
                this.addAnchorInfo(list);
                break;
            }
            case RunType.InlineTextBoxRun: {
                const r = this.curr;
                this.addTextBoxRunInfo(list);
                list.push(new Pair("size", r.size));
                const subDoc = this.model.subDocuments[r.subDocId];
                list.push(new Pair("textOfInnerSubDocument", new ShortString(subDoc.getText(new FixedInterval(0, subDoc.getDocumentEndPosition())))));
                break;
            }
            case RunType.AnchoredTextBoxRun:
                const r = this.curr;
                this.addTextBoxRunInfo(list);
                this.addAnchorInfo(list);
                list.push(new Pair("size", r.size));
                list.push(new Pair("textOfInnerSubDocument", this.getSubDocumentText(r.subDocId)));
                break;
            case RunType.FieldCodeEndRun:
                break;
            case RunType.FieldCodeStartRun:
                break;
            case RunType.FieldResultEndRun:
                break;
            case RunType.EndNoteRun:
            case RunType.FootNoteRun:
            case RunType.NoteSeparatorRun:
            case RunType.NoteContinuationSeparatorRun:
                break;
            case RunType.LayoutDependentRun:
                break;
            case RunType.ParagraphRun:
                break;
            case RunType.SectionRun:
                break;
            case RunType.Undefined:
                break;
            default: throw new Error(Errors.NotImplemented);
        }
        return this.stdShow(new StdProps(list).showAsColumn());
    }
    addPicRunInfo(list) {
        const r = this.curr;
        list.push(new Pair("size", r.size));
        list.push(new Pair("cacheInfo", r.cacheInfo));
        list.push(new Pair("shape", r.shape));
        list.push(new Pair("", this.getPictureNode(r.cacheInfo.currId, r.size.actualSize)));
    }
    addTextBoxRunInfo(list) {
        const r = this.curr;
        list.push(new Pair("subDocId", r.subDocId));
        list.push(new Pair("textBoxProperties", r.textBoxProperties));
        list.push(new Pair("shape", r.shape));
    }
    addAnchorInfo(list) {
        const r = this.curr;
        list.push(new Pair("anchoredObjectID", r.anchoredObjectID));
        list.push(new Pair("anchorInfo", r.anchorInfo));
    }
    getText() {
        return this.getChunk().textBuffer.substr(this.curr.startOffset, this.curr.getLength());
    }
    getChunk() {
        return NumberMapUtils.anyOf(this.model.subDocuments, (subD) => ListUtils.elementBy(subD.chunks, (chunk) => !!ListUtils.elementBy(chunk.textRuns, (run) => run === this.curr)));
    }
}
CCF_RunBase._foo = BaseFormatter.addToFormattersList(new CCF_RunBase());
