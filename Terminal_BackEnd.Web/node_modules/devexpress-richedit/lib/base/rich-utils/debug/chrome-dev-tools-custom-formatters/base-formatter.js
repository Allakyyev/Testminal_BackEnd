import { ColorHelper } from '../../../../core/model/color/color';
import { RichUtils } from '../../../../core/model/rich-utils';
import { FixedInterval } from '@devexpress/utils/lib/intervals/fixed';
import { ListUtils } from '@devexpress/utils/lib/utils/list';
import { NumberMapUtils } from '@devexpress/utils/lib/utils/map/number';
import { BaseElement, DivElement, ObjectElement, SpanElement, TdElement, TrElement } from './elements';
import { ShortString } from './short-string';
export class BaseFormatter {
    static addToFormattersList(formatter) {
        BaseFormatter.formattersList.push(formatter);
    }
    availableFullDescription(_config) {
        return false;
    }
    getFullDescription(_config) {
        return null;
    }
    header(obj, config) {
        if (!this.isHandleObject(obj) || config && !config.useCustomFormatter)
            return null;
        this.curr = obj;
        return this.getShortDescription(config).toList();
    }
    hasBody(obj, config) {
        this.curr = obj;
        return this.availableFullDescription(config);
    }
    body(obj, config) {
        this.curr = obj;
        const domObj = this.getFullDescription(config);
        return domObj ? domObj.toList() : null;
    }
    toFixed(val, numDigitsAfterPoint = 2) {
        if (val === null)
            return "null";
        if (val === undefined)
            return "undefined";
        const str = val.toFixed(numDigitsAfterPoint);
        const len = str.length;
        return str.substr(len - 2) == "00" ? str.substring(0, len - 3) : str;
    }
    stdShow(props) {
        const rowElement = new DivElement();
        if (props._onLine && props._openChar.length)
            rowElement.setNode(new SpanElement().setText(props._openChar));
        ListUtils.forEach(props._list, (prop) => {
            const node = new DivElement()
                .setStyle("margin: 0px 5px")
                .setStyle("padding: 0px 2px");
            if (prop.first.length)
                node.setNode(new SpanElement().setText(`${prop.first}: `)
                    .setStyle("font-weight: bold")
                    .setStyle(`color: ${BaseFormatter.paramNameColor}`));
            if (props._onLine)
                node.setStyle("display: inline-block");
            if (typeof prop.second == "object") {
                if (prop.second instanceof BaseElement)
                    node.setNode(prop.second);
                else
                    node.setNode(new ObjectElement().setObjectData(prop.second, null));
            }
            else {
                node.setNode(new SpanElement().setText(`${prop.second === null || prop.second === undefined ? "null" : prop.second}`)
                    .setStyle(`color: ${BaseFormatter.valueColor}`));
            }
            rowElement.setNode(node);
        }, 0, props._numElements);
        if (props.isShowNotAllElements())
            rowElement.setNode(new SpanElement().setText("..."));
        if (props._onLine && props._closeChar.length)
            rowElement.setNode(new SpanElement().setText(props._closeChar));
        return rowElement;
    }
    mapNumberAsKeyToListOfPairs(map, getSortVal, makePair) {
        return ListUtils.map(NumberMapUtils.toListBy(map, (obj, key) => [key, obj])
            .sort((a, b) => getSortVal(a[0], a[1]) - getSortVal(b[0], b[1])), (obj) => makePair(obj[0], obj[1]));
    }
    static getColorBoxNode(color) {
        return new DivElement()
            .setStyle(`display: inline-block`)
            .setStyle(`background-color:${ColorHelper.getCssString(color, false)}`)
            .setStyle(`width: 10px`)
            .setStyle(`height: 10px`)
            .setStyle(`border: 1px solid black`);
    }
    getPictureNode(_picId, _obj) {
        return null;
    }
    makeTableCellNode(propName, val) {
        return new TrElement()
            .setNode(new TdElement().setText(`${propName}:`))
            .setNode(new TdElement().setText(`${val}`));
    }
    get handlerURI() {
        return "";
    }
    get model() {
        return BaseFormatter.rich.modelManager.model;
    }
    getSubDocumentText(subDocId, interval = null) {
        const subDoc = this.model.subDocuments[subDocId];
        if (!interval)
            interval = new FixedInterval(0, subDoc.getDocumentEndPosition());
        const text = subDoc.getText(interval);
        return this.getRawText(text);
    }
    getRawText(text) {
        text = text.replace(new RegExp(RichUtils.specialCharacters.ParagraphMark, "g"), "Â¶");
        return new ShortString(text);
    }
}
BaseFormatter.stringColor = "rgb(196,26,22)";
BaseFormatter.paramNameColor = "rgb(176,98,182)";
BaseFormatter.valueColor = "rgb(70,47,216)";
BaseFormatter.blackColor = "rgb(0,0,0)";
BaseFormatter.formattersList = [];
export class StdProps {
    constructor(list) {
        this._onLine = true;
        this._list = list;
        this._numElements = list.length;
        this._openChar = "{";
        this._closeChar = "}";
    }
    setNumElements(val) {
        this._numElements = val;
        return this;
    }
    setStdNumElements() {
        return this.setNumElements(Math.min(this._list.length, StdProps.STD_NUM_ELEMENTS));
    }
    showAsLine() {
        this._onLine = true;
        return this;
    }
    showAsColumn() {
        this._onLine = false;
        return this;
    }
    setBoundChars(openChar, closeChar) {
        this._openChar = openChar;
        this._closeChar = closeChar;
        return this;
    }
    isShowNotAllElements() {
        return this._numElements < this._list.length;
    }
}
StdProps.STD_NUM_ELEMENTS = 3;
export class Config {
    getProp(getter, defaultVal) {
        const val = getter();
        if (val === undefined)
            return defaultVal;
        return val;
    }
    get useCustomFormatter() { return this.getProp(() => this.aspxRichEditConfig_useCustomFormatter, true); }
    set useCustomFormatter(val) { this.aspxRichEditConfig_useCustomFormatter = val; }
    static useCustomFormatter(val, config = new Config) {
        config.useCustomFormatter = val;
        return config;
    }
}
