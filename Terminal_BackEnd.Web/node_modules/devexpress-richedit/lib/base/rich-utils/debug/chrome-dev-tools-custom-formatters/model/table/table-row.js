import { TableRow } from '../../../../../../core/model/tables/main-structures/table-row';
import { ConditionalTableStyleFormatting } from '../../../../../../core/model/tables/secondary-structures/table-base-structures';
import { Log } from '../../../../../../core/rich-utils/debug/logger/base-logger/log';
import { Pair } from '@devexpress/utils/lib/class/pair';
import { NumberMapUtils } from '@devexpress/utils/lib/utils/map/number';
import { BaseFormatter, StdProps } from '../../base-formatter';
export class CCF_TableRow extends BaseFormatter {
    isHandleObject(obj) {
        return obj instanceof TableRow;
    }
    getShortDescription(_config) {
        const list = [
            new Pair("", this.getIndex() + ":"),
            new Pair("cells", this.curr.cells.length),
            new Pair("height", this.curr.height),
        ];
        return this.stdShow(new StdProps(list).showAsLine());
    }
    availableFullDescription(_config) {
        return true;
    }
    getFullDescription(_config) {
        const list = [
            new Pair("index", this.getIndex()),
            new Pair("gridBefore", this.curr.gridBefore),
            new Pair("gridAfter", this.curr.gridAfter),
            new Pair("cells", this.curr.cells),
            new Pair("height", this.curr.height),
            new Pair("text", this.getRawText(this.getSubDocument().getText(this.curr.interval)).setLen(30)),
            new Pair("runsOnCell", this.getSubDocument().getRunsByInterval(this.curr.interval)),
            new Pair("conditionalFormatting", Log.mask(ConditionalTableStyleFormatting, this.curr.conditionalFormatting)),
            new Pair("properties", this.curr.properties),
            new Pair("tablePropertiesException", this.curr.tablePropertiesException),
        ];
        if (this.curr.gridBefore)
            list.push(new Pair("widthBefore", this.curr.widthBefore));
        if (this.curr.gridAfter)
            list.push(new Pair("widthAfter", this.curr.widthAfter));
        list.push(new Pair("parentTable", this.curr.parentTable));
        return this.stdShow(new StdProps(list).showAsColumn());
    }
    getIndex() {
        return this.curr.parentTable.rows.indexOf(this.curr);
    }
    getSubDocument() {
        return NumberMapUtils.elementBy(this.model.subDocuments, (subDoc) => subDoc.tables[this.curr.parentTable.index] == this.curr.parentTable);
    }
}
CCF_TableRow._foo = BaseFormatter.addToFormattersList(new CCF_TableRow());
