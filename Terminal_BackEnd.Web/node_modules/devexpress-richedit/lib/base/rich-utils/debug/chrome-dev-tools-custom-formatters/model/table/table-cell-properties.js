import { TableCellProperties, TableCellPropertiesMask } from '../../../../../../core/model/tables/properties/table-cell-properties';
import { TableCellVerticalAlignment, TextDirection } from '../../../../../../core/model/tables/secondary-structures/table-base-structures';
import { Log } from '../../../../../../core/rich-utils/debug/logger/base-logger/log';
import { Pair } from '@devexpress/utils/lib/class/pair';
import { BaseFormatter, StdProps } from '../../base-formatter';
export class CCF_TableCellProperties extends BaseFormatter {
    isHandleObject(obj) {
        return obj instanceof TableCellProperties;
    }
    getShortDescription(_config) {
        const list = [];
        if (this.curr.getUseValue(TableCellPropertiesMask.UseVerticalAlignment) && this.curr.verticalAlignment != TableCellVerticalAlignment.Top)
            list.push(new Pair("vertAlign", TableCellVerticalAlignment[this.curr.verticalAlignment]));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseShadingInfoIndex))
            list.push(new Pair("", BaseFormatter.getColorBoxNode(this.curr.shadingInfo.getActualColor(this.model.colorProvider))));
        return this.stdShow(new StdProps(list).showAsLine());
    }
    availableFullDescription(_config) {
        return true;
    }
    getFullDescription(_config) {
        const list = [
            new Pair("mask", Log.mask(TableCellPropertiesMask, this.curr.mask, TableCellPropertiesMask.UseNone)),
        ];
        if (this.curr.getUseValue(TableCellPropertiesMask.UseVerticalAlignment))
            list.push(new Pair("verticalAlignment", TableCellVerticalAlignment[this.curr.verticalAlignment]));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseLeftMargin))
            list.push(new Pair("cellMargins.left", this.curr.cellMargins.left));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseRightMargin))
            list.push(new Pair("cellMargins.right", this.curr.cellMargins.right));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseTopMargin))
            list.push(new Pair("cellMargins.top", this.curr.cellMargins.top));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseBottomMargin))
            list.push(new Pair("cellMargins.bottom", this.curr.cellMargins.bottom));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseLeftBorder))
            list.push(new Pair("cellMargins.left", this.curr.borders.leftBorder));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseRightBorder))
            list.push(new Pair("cellMargins.right", this.curr.borders.rightBorder));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseTopBorder))
            list.push(new Pair("cellMargins.top", this.curr.borders.topBorder));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseBottomBorder))
            list.push(new Pair("cellMargins.bottom", this.curr.borders.bottomBorder));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseTextDirection))
            list.push(new Pair("textDirection", TextDirection[this.curr.textDirection]));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseFitText))
            list.push(new Pair("fitText", this.curr.fitText));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseShadingInfoIndex))
            list.push(new Pair("shadingInfo", this.curr.shadingInfo.getActualColor(this.model.colorProvider)));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseHideCellMark))
            list.push(new Pair("hideCellMark", this.curr.hideCellMark));
        if (this.curr.getUseValue(TableCellPropertiesMask.UseNoWrap))
            list.push(new Pair("noWrap", this.curr.noWrap));
        return this.stdShow(new StdProps(list).showAsColumn());
    }
}
CCF_TableCellProperties._foo = BaseFormatter.addToFormattersList(new CCF_TableCellProperties());
