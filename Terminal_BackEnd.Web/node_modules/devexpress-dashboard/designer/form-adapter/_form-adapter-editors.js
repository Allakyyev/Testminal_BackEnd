/**
* DevExpress Dashboard (_form-adapter-editors.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { dxFileImagePicker } from '@devexpress/analytics-core/analytics-widgets-internal';
import DataSource from 'devextreme/data/data_source';
import dxList from 'devextreme/ui/list';
import dxTagBox from 'devextreme/ui/tag_box';
import * as ko from 'knockout';
import { getFlagsEnumTypeValues } from '../../data/_common';
import { $unwrap } from '../../data/_jquery-helpers';
import { localizationId } from '../../data/_localization-ids';
import { getLocalizationById, tryLocalize } from '../../data/localization/_default';
import { validateGuid } from '../../model/parameters/_parameters-helper';
import { CalculationExpressionEditor } from '../calculations/_expression-editor';
import { FormatConditionTypeEditorSurface } from '../conditional-formatting/_condition-type-editor';
import { RuleRangesEditor } from '../conditional-formatting/_rule-ranges-editor';
import { StyleSettingsEditor } from '../conditional-formatting/_style-settings-editor';
import { CurrencySelector } from '../currency-selector/_currency-selector';
import { FilterExpressionEditorViewModel } from '../expression-editor/_filter-expression-editor';
import { SimpleFilterExpressionEditorViewModel } from '../filtering/simple-filter-editor/_simple-filter-editor-view-model';
import { ContainerTypeSelector } from '../items/container-type-selector/_container-type-selector';
import { FormItemTemplates } from '../public-editors/form-item-templates';
import { CollectionEditorViewModel } from '../ui-widgets/collection-editor/_collection-editor-viewmodel';
import { EditableListEditorViewModel } from '../ui-widgets/collection-editor/_editable-list-editor-viewmodel';
import { InlineEditCollectionEditorViewModel } from '../ui-widgets/collection-editor/_inline-edit-collection-editor-viewmodel';
export function getFieldValue(args) {
    return ko.unwrap(args.component.option('formData')[args.dataField]);
}
function localizeValues(v) {
    return v.map(v => ({ value: v.value, displayValue: tryLocalize(v.displayValueId) }));
}
export const dateBoxEditor = () => ({
    editorType: 'dxDateBox',
    editorOptions: {
        closeOnValueChange: true,
        showClearButton: true,
        type: 'datetime',
        applyButtonText: getLocalizationById(localizationId.buttonNames.ButtonOK),
        cancelButtonText: getLocalizationById(localizationId.buttonNames.ButtonCancel),
        todayButtonText: getLocalizationById(localizationId.labelName.ParametersFormCalendarTodayButton)
    }
});
export const colorBoxEditor = () => ({
    editorType: 'dxColorBox',
    editorOptions: {
        showClearButton: true,
        editAlphaChannel: true,
        applyButtonText: getLocalizationById(localizationId.buttonNames.ButtonOK),
        cancelButtonText: getLocalizationById(localizationId.buttonNames.ButtonCancel)
    }
});
export const numberBoxEditor = (options = {}) => ({
    editorType: 'dxNumberBox',
    editorOptions: Object.assign(Object.assign({}, options), { showSpinButtons: true }),
    comparableEditorOptions: ['format']
});
export const checkBoxEditor = (args) => {
    var text = args && args.text || null;
    return {
        editorType: 'dxCheckBox',
        label: { visible: !text },
        editorOptions: {
            elementAttr: {
                class: 'dx-dashboard-check-box'
            },
            text: text
        }
    };
};
export const textBoxEditor = () => ({ editorType: 'dxTextBox' });
export const guidEditor = () => ({
    editorType: 'dxTextBox',
    validationRules: [
        {
            type: 'custom',
            validationCallback: (options) => { return validateGuid(options.value); },
            message: getLocalizationById('AnalyticsCoreStringId.GuidIsRequired_Error')
        }
    ]
});
export const selectBoxEditor = values => context => {
    return {
        editorType: 'dxSelectBox',
        editorOptions: {
            items: localizeValues(values),
            valueExpr: 'value',
            displayExpr: 'displayValue',
            displayCustomValue: true,
            dropDownOptions: { container: context.widgetContainer }
        }
    };
};
export function dynamicSelectBoxEditor(options) {
    return observableSelectBoxEditor(Object.assign(Object.assign({}, options), { observables: { values: options.values }, load: (args) => localizeValues(args.values) }));
}
export function observableSelectBoxEditor(options) {
    return context => {
        let dataSource = new DataSource({
            load: () => options.load(Object.keys(options.observables).reduce((acc, key) => { acc[key] = options.observables[key](); return acc; }, {})),
            key: 'value',
            loadMode: 'raw'
        });
        const dynamicOptions = options.additionalOptions && options.additionalOptions() || {};
        return {
            editorType: 'dxSelectBox',
            editorOptions: Object.assign({ dataSource: dataSource, valueExpr: 'value', displayExpr: 'displayValue', displayCustomValue: true, dropDownOptions: { container: context.widgetContainer }, onInitialized: e => {
                    const disposables = e.component.__DX_DASHBOARD_DISPOSABLES = (e.component.__DX_DASHBOARD_DISPOSABLES || []);
                    Object.keys(options.observables).map(obsName => options.observables[obsName].subscribe(newValue => {
                        dataSource.reload();
                    })).forEach(d => disposables.push(d));
                }, onDisposing: e => {
                    (e.component.__DX_DASHBOARD_DISPOSABLES || []).forEach(d => d && d.dispose());
                    e.component.__DX_DASHBOARD_DISPOSABLES = [];
                } }, dynamicOptions),
            comparableEditorOptions: options.comparableEditorOptions
        };
    };
}
export const buttonGroupEditor = values => ({
    template: FormItemTemplates.buttonGroup,
    editorOptions: {
        keyExpr: 'value',
        items: values.map((val) => ({ value: val.value, text: getLocalizationById(val.displayValueId) })),
    }
});
export const listEditor = (values) => ({
    template: args => getListTemplate(args, values)
});
function getListTemplate(args, values) {
    var div = document.createElement('div');
    var initialValue = getFieldValue(args);
    var options = {
        dataSource: values,
        selectionMode: 'single',
        disabled: args.editorOptions && args.editorOptions.disabled || undefined,
        selectedItems: values.filter(value => { return value.value === initialValue; }),
        onItemClick: (e) => { args.component.updateData(args.dataField, e.itemData.value); },
        itemTemplate: (itemData) => {
            var span = document.createElement('span');
            span.innerText = getLocalizationById(itemData.displayValueId);
            return span;
        }
    };
    new dxList(div, options);
    return div;
}
export const editableListEditor = options => context => {
    return {
        editorOptions: options,
        template: args => editableListEditorTemplate(args, context, options)
    };
};
const editableListEditorTemplate = (args, context, options) => {
    let viewModel = new EditableListEditorViewModel(options, args.component.option('formData')[args.dataField]);
    const div = document.createElement('div');
    ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-collection-editor', data: viewModel } }, context.bindingContext);
    return div;
};
export const collectionEditor = options => context => {
    return {
        editorOptions: options,
        template: (args) => collectionEditorTemplate(args, context, options)
    };
};
const collectionEditorTemplate = (args, context, options) => {
    let viewModel = new CollectionEditorViewModel(options, args.component.option('formData')[args.dataField]);
    const div = document.createElement('div');
    ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-collection-editor', data: viewModel } }, context.bindingContext);
    return div;
};
export const inlineEditCollectionEditor = options => context => ({
    editorOptions: options,
    template: (args, elt) => inlineEditCollectionEditorTemplate(args, $unwrap(elt), context, options)
});
const inlineEditCollectionEditorTemplate = (args, elt, context, options) => {
    const viewModel = new InlineEditCollectionEditorViewModel(options, args.component.option('formData')[args.dataField]);
    ko.applyBindingsToNode(elt, { template: { name: 'dx-dashboard-editable-collection-editor', data: viewModel } }, context.bindingContext);
};
export const textPreviewEditor = options => context => {
    return {
        template: args => {
            const field = args.component.option('formData')[args.dataField];
            const div = document.createElement('div');
            div.classList.add('dx-dashboard-text-preview');
            ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-text-preview', data: options.target } }, context.bindingContext);
            return div;
        }
    };
};
export const actionButtons = (options) => context => {
    return {
        template: args => {
            const div = document.createElement('div');
            ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-action-buttons', data: { buttons: options } } }, context.bindingContext);
            return div;
        }
    };
};
export const flagsEnumListEditor = options => {
    return {
        template: args => {
            const div = document.createElement('div');
            div.classList.add('dx-dashboard-point-label-content-type-selector');
            new dxList(div, Object.assign({ showSelectionControls: true, selectionMode: 'multiple', keyExpr: 'value', onInitialized: function (e) {
                    e.component.option('selectedItemKeys', getFlagsEnumTypeValues(getFieldValue(args), options.enumDeclaration, 'value'));
                } }, getFlagsEnumWidgetCommonOptions(args, options.values)));
            return div;
        }
    };
};
export const flagsEnumTagBoxEditor = options => context => {
    return {
        template: args => {
            const div = document.createElement('div');
            div.classList.add('dx-dashboard-enum-flags-date-type-selector');
            new dxTagBox(div, Object.assign(Object.assign({ placeholder: getLocalizationById('DashboardWebStringId.ConditionalFormatting.DatesOccurringNone'), selectAllMode: 'allPages', showSelectionControls: true, showDropDownButton: true, multiline: false, searchEnabled: true, valueExpr: 'value', onInitialized: function (e) {
                    e.component.option('value', getFlagsEnumTypeValues(getFieldValue(args), options.enumDeclaration, 'value'));
                } }, getFlagsEnumWidgetCommonOptions(args, options.values)), {
                selectAllText: getLocalizationById('DashboardStringId.FilterElementShowAllItem'),
                pageLoadMode: 'scrollBottom',
                dropDownOptions: { container: context.widgetContainer }
            }));
            return div;
        }
    };
};
function getFlagsEnumWidgetCommonOptions(args, values) {
    return {
        dataSource: values,
        displayExpr: e => e && getLocalizationById(e.displayValueId),
        onSelectionChanged: function (e) {
            var val = getFieldValue(args);
            e.addedItems.forEach(function (added) {
                val = val | added.value;
            });
            e.removedItems.forEach(function (removed) {
                val = val & ~removed.value;
            });
            args.component.updateData(args.dataField, val);
        },
    };
}
export const currencyEditor = () => (context) => ({
    template: args => currencyEditorTemplate(args, context)
});
const currencyEditorTemplate = (args, context) => {
    const div = document.createElement('div');
    let viewModel = new CurrencySelector(args.component.option('formData')[args.dataField], args.editorOptions.disabled);
    ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-currency-editor-template', data: viewModel } }, context.bindingContext);
    return div;
};
export const iconTypeEditor = (options) => context => ({
    template: args => iconTypeEditorTemplate(args, context, options)
});
const iconTypeEditorTemplate = (args, context, options) => {
    const div = document.createElement('div');
    var value = args.component.option('formData')[args.dataField];
    var viewModel = new ContainerTypeSelector(options.containersMap, value, options.containerGroupLocalization || undefined, options.highlightedTypes);
    ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-container-type-selector-full', data: viewModel } }, context.bindingContext);
    return div;
};
export const nullableNumberBoxEditor = (options) => context => {
    return {
        template: (args) => nullableNumberBoxEditorTemplate(args, context, options)
    };
};
const nullableNumberBoxEditorTemplate = (args, context, options) => {
    const div = document.createElement('div');
    var value = args.component.option('formData')[args.dataField];
    const defaultValue = options.defaultValue ? options.defaultValue : 0;
    const viewModel = {
        buttonGroupOptions: {
            selectedItemKeys: ko.pureComputed(() => [isNaN(value())]),
            keyExpr: 'value',
            width: '100%',
            items: [
                { value: true, text: getLocalizationById('DashboardWebStringId.Gauge.Scale.Auto') },
                { value: false, text: getLocalizationById('DashboardWebStringId.Gauge.Scale.Custom') }
            ],
            onItemClick: e => { value(e.itemData.value ? NaN : defaultValue); }
        },
        numberBoxOptions: Object.assign(Object.assign({}, options.editorOptions), { disabled: ko.pureComputed(() => isNaN(value())), value: value, showSpinButtons: true, step: 1 })
    };
    ko.applyBindingsToNode(div, { template: { name: 'dx-dashboard-nullable-numberbox', data: viewModel } }, context.bindingContext);
    return div;
};
export const flowModeSettingsEditor = () => context => {
    return {
        template: (args, itemElement) => {
            const periodLimit = args.component.option('formData')[args.dataField];
            const viewModel = {
                selectBoxOptions: {
                    items: periodLimit._getAvailableIntervals(),
                    value: periodLimit.interval,
                    valueExpr: 'value',
                    displayExpr: 'displayValue',
                    displayCustomValue: true,
                    dropDownOptions: { container: args.editorOptions.dashboardWidgetContainer }
                },
                numberBoxOptions: {
                    value: periodLimit.offset,
                    showSpinButtons: true,
                    step: 1
                }
            };
            ko.applyBindingsToNode($unwrap(itemElement), { template: { name: 'dx-dashboard-flow-mode-settings', data: viewModel } }, context.bindingContext);
        }
    };
};
export const calculationExpressionEditor = options => expressionEditorFormAdapter(() => new CalculationExpressionEditor(options));
export const filterEditor = options => expressionEditorFormAdapter(() => new FilterExpressionEditorViewModel(options));
export const simpleFilterEditor = options => expressionEditorFormAdapter(() => new SimpleFilterExpressionEditorViewModel(options));
function expressionEditorFormAdapter(createEditorViewModel) {
    return context => {
        return {
            template: (args, itemElement) => {
                var viewModel = createEditorViewModel();
                ko.applyBindingsToNode($unwrap(itemElement), { template: { name: 'dx-dashboard-expression-editor-view', data: viewModel } }, context.bindingContext);
            }
        };
    };
}
export const filePickerEditor = (options) => {
    return {
        template: (args) => {
            var div = document.createElement('div');
            new dxFileImagePicker(div, Object.assign(Object.assign({}, options), { value: getFieldValue(args), onValueChanged: (e) => {
                    args.component.updateData(args.dataField, e.value);
                } }));
            return div;
        }
    };
};
export const nestedPropertyGridEditor = (caption) => context => {
    return {
        template: (args, itemElement) => {
            const formatModel = args.component.option('formData')[args.dataField];
            ko.applyBindingsToNode($unwrap(itemElement), { template: { name: 'dx-dashboard-nested-propertygrid-editor', data: {
                        object: formatModel,
                        caption: caption
                    } } }, context.bindingContext);
        }
    };
};
export const ruleRangesEditor = (options) => context => {
    return {
        options: options,
        template: (args, itemElement) => {
            var viewModel = new RuleRangesEditor(options);
            ko.applyBindingsToNode($unwrap(itemElement), { template: { name: 'dx-dashboard-rule-ranges-editor', data: viewModel } }, context.bindingContext);
        }
    };
};
export const styleSettingsEditor = (options) => context => {
    return {
        options: options,
        template: (args, itemElement) => {
            const styleSettings = args.component.option('formData')[args.dataField];
            if (!options.restrictToColor) {
                options.getAvailableFontFamilies = () => {
                    const getAvailableFontFamilies = args.component.option('formData').model.condition()._getAvailableFontFamilies;
                    if (getAvailableFontFamilies) {
                        return getAvailableFontFamilies();
                    }
                    return ko.computed(() => []);
                };
            }
            var viewModel = new StyleSettingsEditor(styleSettings, options);
            ko.applyBindingsToNode($unwrap(itemElement), { template: { name: 'dx-dashboard-style-settings-editor', data: viewModel } }, context.bindingContext);
        }
    };
};
export const conditionTypeEditor = options => context => {
    return {
        options: options,
        template: (args, itemElement) => {
            const viewModel = new FormatConditionTypeEditorSurface(options);
            ko.applyBindingsToNode($unwrap(itemElement), { template: { name: 'dx-dashboard-format-rule-condition-type-editor', data: viewModel } }, context.bindingContext);
        }
    };
};
