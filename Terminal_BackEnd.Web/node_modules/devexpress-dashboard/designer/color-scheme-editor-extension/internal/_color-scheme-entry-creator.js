/**
* DevExpress Dashboard (_color-scheme-entry-creator.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { OperandProperty } from '@devexpress/analytics-core/analytics-criteria';
import { criteriaForEach } from '@devexpress/analytics-core/analytics-criteria-utils';
import { ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
import { ColorSchemeEntry } from '../../../model/colorization/color-scheme-entry';
import { DimensionKey } from '../../../model/colorization/dimension-key';
import { MeasureDefinition } from '../../../model/colorization/measure-definition';
import { DimensionDefinition } from '../../../model/colorization/_dimension-definition';
import { Calculation } from '../../../model/data-item/calculations/calculation';
import { Dimension } from '../../../model/data-item/dimension';
import { WindowDefinition } from '../../../model/data-item/window-definition/window-definition';
import { getFilterCriteria } from '../../../model/internal/_expression-utils';
export class ColorSchemeEntryCreator {
    constructor() {
        this._entry = new ColorSchemeEntry({});
    }
    static createMeasureKey(dataMember, summaryType) {
        var measureDefinition = new MeasureDefinition({ '@ItemType': 'Definition' });
        measureDefinition.dataMember(dataMember);
        measureDefinition.summaryType(summaryType);
        return measureDefinition;
    }
    static createMeasureDefinitionFromMeasure(measure, otherDataItems) {
        var measureDefinition = new MeasureDefinition({ '@ItemType': 'Definition' });
        var serializer = new ModelSerializer();
        var calculationClone = new Calculation(serializer.serialize(measure.calculation));
        var windowDefinitionJson = serializer.serialize(measure.windowDefinition);
        var windowDefinitionClone = new WindowDefinition(windowDefinitionJson);
        measureDefinition.dataMember(measure.dataMember());
        measureDefinition.summaryType(measure.summaryType());
        measureDefinition.calculation.calculation(calculationClone.calculation());
        measureDefinition.calculation.calculationType(calculationClone.calculationType());
        measureDefinition.expression(measure.expression());
        measureDefinition.windowDefinition.windowDefinition(windowDefinitionClone.windowDefinition());
        measureDefinition.windowDefinition.windowDefinitionType(windowDefinitionClone.windowDefinitionType());
        let filterString = measure.filterString();
        measureDefinition.filterString(filterString);
        if (filterString && otherDataItems && otherDataItems.length > 0) {
            let filterCriteria = getFilterCriteria(filterString);
            let dimensions = [];
            criteriaForEach(filterCriteria, op => {
                if (op instanceof OperandProperty) {
                    let prop = op;
                    let dataItem = otherDataItems.filter(di => di.uniqueName() === prop.propertyName)[0];
                    if (dataItem instanceof Dimension) {
                        dimensions.push(this.createDimensionDefinitionFromDimension(dataItem));
                    }
                }
            });
            measureDefinition.definitions(dimensions);
        }
        return measureDefinition;
    }
    static createDimensionDefinitionFromDimension(dimension) {
        var dimensionDefinition = new DimensionDefinition();
        dimensionDefinition.dataMember = dimension.dataMember;
        dimensionDefinition.dateTimeGroupInterval = dimension.dateTimeGroupInterval;
        return dimensionDefinition;
    }
    static createMeasureDefinitionCopy(measureKey) {
        var serializer = new ModelSerializer();
        return new MeasureDefinition(serializer.serialize(measureKey));
    }
    static createDimensionKey(dataMember, groupInterval, valueType, value) {
        var dimensionKey = new DimensionKey({ '@ItemType': 'DimensionKey' });
        dimensionKey.definition = {
            dataMember: ko.observable(dataMember),
            dateTimeGroupInterval: ko.observable(groupInterval)
        };
        dimensionKey.value = {
            value: ko.observable(value),
            type: ko.observable(valueType)
        };
        return dimensionKey;
    }
    addColor(color) {
        this._entry.color(color);
        return this;
    }
    addItemComponentName(name) {
        this._entry.itemComponentName = name;
        return this;
    }
    addPaletteIndex(paletteIndex) {
        this._entry.paletteIndex(paletteIndex);
        return this;
    }
    addDataSourceName(dataSourceName) {
        this._entry.dataSource(dataSourceName);
        return this;
    }
    addDataMemberName(dataMember) {
        this._entry.dataMember(dataMember);
        return this;
    }
    addMeasureKey(dataMember, summaryType) {
        this._entry.measureKeys.push(ColorSchemeEntryCreator.createMeasureKey(dataMember, summaryType));
        return this;
    }
    addDimensionKey(dataMember, groupInterval, valueType, value) {
        this._entry.dimensionKeys.push(ColorSchemeEntryCreator.createDimensionKey(dataMember, groupInterval, valueType, value));
        return this;
    }
    getEntry() {
        return this._entry;
    }
}
