/**
* DevExpress Dashboard (_entry-editor-model.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import validationEngine from 'devextreme/ui/validation_engine';
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { jqueryWhenArray } from '../../../data/_jquery-helpers';
import { Color } from '../../../model/color';
import { getRealDimensionType } from '../../filtering/_item-filter-items-provider';
import { ColorSchemeEntryCreator } from './_color-scheme-entry-creator';
export class EntryEditorViewModel {
    constructor(colorPalette) {
        this.colorPalette = colorPalette;
        this.editEntry = (dataSourceBrowser, entry, colorByMeasures, availableMeasures, updateEntry, isAutoGenerated) => {
            this.invalidate();
            this.isAutogenerated(isAutoGenerated);
            this.updateEntry = updateEntry;
            this.hasMeasures(colorByMeasures);
            this.availableMeasures(availableMeasures);
            this.entryToEdit(entry.clone());
            this.subscribeObservables();
            if (colorByMeasures) {
                this.measuresValidationRules = [{
                        type: 'custom',
                        validationCallback: () => {
                            return this.measureKeys().length > 0;
                        },
                        message: getLocalizationById('DashboardWebStringId.Colorization.ValidationSelectMeasure')
                    }];
            }
            var dimensionEditors = [];
            var promises = [];
            this.dimensionKeys().forEach(key => {
                promises.push(dataSourceBrowser
                    .findDataField(entry.definition.dataSource, entry.definition.dataMember, key.definition.dataMember())
                    .done(field => {
                    var type = field && getRealDimensionType(key.definition, field) || 'Unknown';
                    dimensionEditors.push({
                        dimensionKey: key,
                        valueType: type
                    });
                }));
            });
            jqueryWhenArray(promises).done((fields) => {
                this.dimensionEditors(dimensionEditors);
                this.visible(true);
            });
        };
        this.close = () => {
            this.visible(false);
            this.invalidate();
        };
        this.validate = () => {
            var validationGroup = validationEngine.getGroupConfig(this._validationGroupName);
            if (!!validationGroup && validationGroup.validate().isValid) {
                this.dimensionKeys().forEach((key, index) => this.entryToEdit().dimensionKeys()[index].value.value(key.value.value()));
                this.entryToEdit().measureKeys(this.measureKeys().map(key => ColorSchemeEntryCreator.createMeasureDefinitionCopy(key)));
                this.entryToEdit().paletteIndex(null);
                this.entryToEdit().color(Color.fromRgbaString(this.color()));
                this.updateEntry(this.entryToEdit());
            }
        };
        this.invalidate = () => {
            this._subscriptions.forEach(s => s.dispose());
            this._subscriptions = [];
            this.entryToEdit(null);
            this.isAutogenerated(false);
            this.measuresValidationRules = [];
            this.dimensionKeys([]);
            this.measureKeys([]);
        };
        this.visible = ko.observable(false);
        this.entryToEdit = ko.observable();
        this.isAutogenerated = ko.observable(false);
        this.hasMeasures = ko.observable();
        this.availableMeasures = ko.observableArray();
        this.measuresValidationRules = [];
        this.dimensionEditors = ko.observableArray();
        this.dimensionKeys = ko.observableArray();
        this.measureKeys = ko.observableArray();
        this.selectedMeasuresIds = ko.computed({
            read: () => {
                return this.measureKeys().map(md => md._id);
            },
            write: (selectedIds) => {
                this.measureKeys(this.availableMeasures().filter(md => selectedIds.some(id => id === md._id)));
            }
        });
        this.color = ko.observable();
        this._subscriptions = [];
        this._validationGroupName = 'newEntry';
    }
    subscribeObservables() {
        this.entryToEdit().dimensionKeys().forEach(key => this.dimensionKeys.push(ColorSchemeEntryCreator.createDimensionKey(key.definition.dataMember(), key.definition.dateTimeGroupInterval(), key.value.type(), key.value.value())));
        this.measureKeys(this.entryToEdit().measureKeys().map(key => ColorSchemeEntryCreator.createMeasureDefinitionCopy(key)));
        let computedColor = this.entryToEdit().paletteIndex() === null ? this.entryToEdit().color() : this.colorPalette()[this.entryToEdit().paletteIndex()];
        this.color(computedColor ? computedColor.toHex() : '');
        this.dimensionKeys().forEach(key => {
            this._subscriptions.push(key.value.value.subscribe(this.validate));
        });
        this._subscriptions.push(this.measureKeys.subscribe(this.validate));
        this._subscriptions.push(this.color.subscribe(this.validate));
    }
}
