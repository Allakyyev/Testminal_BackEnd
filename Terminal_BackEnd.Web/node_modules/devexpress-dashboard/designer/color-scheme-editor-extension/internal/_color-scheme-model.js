/**
* DevExpress Dashboard (_color-scheme-model.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { Disposable, deserializeArray } from '@devexpress/analytics-core/analytics-utils';
import * as $ from 'jquery';
import * as ko from 'knockout';
import { debounce } from '../../../data/_utils';
import { Color } from '../../../model/color';
import { AutoColorSchemeEntry } from '../../../model/colorization/color-scheme-entry';
import { DisposableObject } from '../../../model/disposable-object';
import { compareArrays } from '../../../model/internal/_array-utils';
import { subscribeWithPrev } from '../../../model/internal/_knockout-utils';
import { DataDashboardItem } from '../../../model/items/data-dashboard-item';
import { PropertyCategory } from '../../../model/metadata/_base-metadata';
import { ColorSchemeEntryCreator } from './_color-scheme-entry-creator';
var measureDefinitionEqual = (key1, key2) => key1._id === key2._id;
function combineEntries(auto, custom) {
    var customEntries = custom.slice();
    var result = [];
    var dimensionValuesEqual = (value1, value2) => value1.value() === value2.value();
    return auto.map(autoEntry => {
        var foundCustom = customEntries.filter(customEntry => {
            return customEntry.definition.equals(autoEntry.definition) &&
                compareArrays(customEntry.dimensionKeys().map(key => key.value), autoEntry.dimensionKeys().map(key => key.value), dimensionValuesEqual) &&
                compareArrays(customEntry.measureKeys(), autoEntry.measureKeys(), measureDefinitionEqual);
        })[0];
        !!foundCustom && customEntries.splice(customEntries.indexOf(foundCustom), 1);
        return foundCustom || autoEntry;
    }).concat(customEntries);
}
export class ItemColorScheme extends DisposableObject {
    constructor(item, _requestColorSchemeDelegate, _updateHub) {
        super();
        this.generatedEntries = ko.observableArray();
        this.componentName = '';
        this.name = '';
        if (item instanceof DataDashboardItem) {
            this.componentName = item.componentName();
            this.name = item.name();
        }
        this.customEntries = item.colorScheme;
        this.allEntries = ko.computed(() => {
            return combineEntries(this.generatedEntries(), this.customEntries());
        });
        this.toDispose(this.allEntries);
        var update = debounce(() => {
            if (!this.disposed && !item.disposed) {
                _requestColorSchemeDelegate(this.componentName).done(scheme => {
                    var coloringSchemeEntries = deserializeArray(scheme, (item) => new AutoColorSchemeEntry(item, null, this.componentName, this.name))();
                    this.generatedEntries(coloringSchemeEntries);
                });
            }
        }, 10);
        this.toDispose(this.customEntries.subscribe(update));
        var dashboardItemUpdated = (args) => {
            if ((args.category !== PropertyCategory.ViewModel && args.category !== PropertyCategory.NoUpdate)
                && item._colorableItems().indexOf(args.item) !== -1) {
                update();
            }
        };
        item._colorableItems.subscribe(update);
        _updateHub.dashboardItemPropertyChanged.add(dashboardItemUpdated);
        this.toDispose({ dispose: () => { _updateHub.dashboardItemPropertyChanged.remove(dashboardItemUpdated); } });
        update();
    }
    dispose() {
        super.dispose();
    }
}
function contains(array, item) {
    return array.some(element => element === item);
}
export class ColorSchemeModel extends Disposable {
    constructor(dashboard, _requestColorSchemeDelegate, _updateHub) {
        super();
        this.dashboard = dashboard;
        this._requestColorSchemeDelegate = _requestColorSchemeDelegate;
        this._updateHub = _updateHub;
        this.isSignatureAutogenerated = (definition) => this.itemColorSchemes[definition.componentName].generatedEntries().some(entry => entry.definition.equals(definition));
        this.removeEntry = (entry) => {
            this.getScheme(entry.definition.componentName).remove(entry);
            this.newEntry(null);
        };
        this.removeTable = (definition) => {
            var scheme = this.getScheme(definition.componentName);
            scheme.removeAll(scheme().filter(entry => entry.definition.equals(definition)));
        };
        this.initNewEntry = () => {
            var entryCreator = new ColorSchemeEntryCreator();
            var entryToClone = this.selectedSignatureEntries()[0];
            var defaultNames = this.generateDefaultNames(entryToClone);
            entryCreator.addItemComponentName(entryToClone.definition.componentName);
            entryCreator.addDataSourceName(entryToClone.definition.dataSource);
            entryCreator.addDataMemberName(entryToClone.definition.dataMember);
            entryToClone.dimensionKeys().map((key, index) => {
                entryCreator.addDimensionKey(key.definition.dataMember(), key.definition.dateTimeGroupInterval(), key.value.type(), defaultNames[index]);
            });
            entryCreator.addColor(Color.fromArgb(1, 0, 0, 0));
            this.newEntry(entryCreator.getEntry());
        };
        this.updateEntry = (entry, editedEntry) => {
            var entries = this.getScheme(editedEntry.definition.componentName);
            var oldEntryIndex = entry instanceof AutoColorSchemeEntry ? -1 : entries().indexOf(entry);
            if (oldEntryIndex >= 0) {
                entries.splice(oldEntryIndex, 1);
            }
            if (entries().indexOf(editedEntry) === -1) {
                entries.push(editedEntry);
            }
            this.newEntry(null);
        };
        this.getAvailableMeasureKeys = () => {
            var result = [];
            var definition = this.selectedSignatureEntries().length > 0 ? this.selectedSignatureEntries()[0].definition : null;
            var itemId = definition.componentName;
            var addMeasureDefinition = function (measureDefinition) {
                if (!result.some(definition => measureDefinitionEqual(definition, measureDefinition)))
                    result.push(measureDefinition);
            };
            var items = this.dashboard._dataDashboardItems().
                filter(item => (!!itemId ? item.componentName() === itemId : item._isGloballyColored) &&
                definition.equals(item._getColoringSignature()));
            if (items.length > 0) {
                items.forEach(item => {
                    item._measures.forEach(measure => {
                        if (item._isColoringEnabled(measure)) {
                            addMeasureDefinition(ColorSchemeEntryCreator.createMeasureDefinitionFromMeasure(measure, item.dataItems()));
                        }
                    });
                });
            }
            else {
                this.selectedSignatureEntries().forEach(entry => {
                    entry.measureKeys().forEach(measure => addMeasureDefinition(ColorSchemeEntryCreator.createMeasureDefinitionCopy(measure)));
                });
            }
            return result;
        };
        this.selectedSignatures = ko.observable([]);
        this.itemColorSchemes = {};
        this.newEntry = ko.observable();
        dashboard.addDisposable(this);
        this.itemColorSchemes[''] = new ItemColorScheme(dashboard, _requestColorSchemeDelegate, _updateHub);
        var localyColoredItems = ko.computed(() => dashboard._dataDashboardItems().filter(item => item._isLocallyColored));
        localyColoredItems().forEach(item => this.createItemColorScheme(item));
        this.addDisposable(subscribeWithPrev(localyColoredItems, (oldValues, newValues) => {
            var deleted = oldValues
                .filter(oldValue => !newValues.some(element => element === oldValue))
                .forEach(item => {
                this.itemColorSchemes[item.componentName()].dispose();
                delete this.itemColorSchemes[item.componentName()];
            });
            var added = newValues
                .filter(newValue => !oldValues.some(element => element === newValue))
                .forEach(item => this.createItemColorScheme(item));
        }));
        this.addDisposable(localyColoredItems);
        this.addDisposable(this.allEntries = ko.computed(() => {
            var result = [];
            $.each(this.itemColorSchemes, (componentName, scheme) => {
                result = result.concat(scheme.allEntries());
            });
            return result;
        }));
        this.addDisposable(this.availableSignatures = ko.computed(() => {
            var result = [];
            this.allEntries().forEach(entry => {
                var definition = entry.definition;
                if (!result.some(resultDefinition => resultDefinition.equals(definition))) {
                    result.push(definition);
                }
            });
            return result;
        }));
        this.addDisposable(this.editableSignatures = ko.computed(() => {
            return this.availableSignatures().filter(s => s.dataItems().length > 0);
        }));
        this.addDisposable(this.selectedSignatureEntries = ko.pureComputed(() => {
            return this.allEntries().filter(entry => !!this.selectedSignatures().length && entry.definition.equals(this.selectedSignatures()[0])).concat(this.newEntry() ? [this.newEntry()] : []);
        }));
    }
    createItemColorScheme(item) {
        this.itemColorSchemes[item.componentName()] = new ItemColorScheme(item, this._requestColorSchemeDelegate, this._updateHub);
    }
    getScheme(componentName = '') {
        return this.itemColorSchemes[componentName].customEntries;
    }
    retainColorIndex(entry) {
        var newEntry = entry.clone();
        newEntry.color(null);
        newEntry.paletteIndex(entry.paletteIndex());
        this.getScheme(entry.definition.componentName).push(newEntry);
    }
    generateDefaultNames(newEntry) {
        var result = [];
        var entries = this.itemColorSchemes[newEntry.definition.componentName].allEntries().filter(entry => entry.definition.equals(newEntry.definition));
        var dimensionKeys = newEntry.dimensionKeys();
        var lastDimensionIndex = null;
        var isString = function (dimensionKey) {
            return dimensionKey.value.type() === 'System.String';
        };
        for (var i = dimensionKeys.length - 1; i >= 0; i--) {
            if (isString(dimensionKeys[i])) {
                lastDimensionIndex = i;
                break;
            }
        }
        if (lastDimensionIndex != null) {
            for (var i = 0; i < lastDimensionIndex; i++) {
                result.push(isString(dimensionKeys[i]) ? dimensionKeys[i].definition.dataMember() + '1' : null);
            }
            var lastDimensionPattern = dimensionKeys[lastDimensionIndex].definition.dataMember();
            var lastDimensionPostfix = 1;
            while (entries.some(entry => entry.dimensionKeys()[lastDimensionIndex].value.value() === lastDimensionPattern + (lastDimensionPostfix).toString())) {
                lastDimensionPostfix++;
            }
            result[lastDimensionIndex] = lastDimensionPattern + lastDimensionPostfix.toString();
        }
        return result;
    }
    isEntryAutogenerated(entry) {
        return this.itemColorSchemes[entry.definition.componentName].generatedEntries().some(generatedEntry => generatedEntry.equals(entry));
    }
}
