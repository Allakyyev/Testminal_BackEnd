/**
* DevExpress Dashboard (_simple-filter-tree-list.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import ArrayStore from 'devextreme/data/array_store';
import CustomStore from 'devextreme/data/custom_store';
import dxCheckBox from 'devextreme/ui/check_box';
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { $promiseAdapter, $unwrap, createJQueryDeferred } from '../../../data/_jquery-helpers';
import { findIndex } from '../../../data/_utils';
import { DisposableObject } from '../../../model';
const treeRootValue = '0';
export class SimpleFilterTreeList extends DisposableObject {
    constructor(dashboardItem, dataSourceBrowser) {
        super();
        this.dashboardItem = dashboardItem;
        this.dataSourceBrowser = dataSourceBrowser;
        this._dataCache = [];
        this.template = {
            name: 'dx-simple-filter-tree-list',
            data: {
                editorOptions: ko.observable(undefined),
                visible: ko.observable(false)
            }
        };
    }
    reload(field) {
        this._dataCache = [];
        this.template.data.editorOptions(this._getTreeListOptions(this._getStore(field), field && !field.isGroup()));
    }
    show(field) {
        this.template.data.visible(true);
        this.reload(field);
    }
    hide() {
        this.template.data.visible(false);
        this.template.data.editorOptions(undefined);
    }
    getTreeListItems() {
        return this._dataCache;
    }
    dispose() {
        this.dispose();
        this._dataCache = [];
    }
    _getBranchIndexes(filterItems, initialParentId) {
        let branchIndexes = [];
        let parentId = initialParentId;
        while (parentId !== treeRootValue) {
            var index = findIndex(filterItems, filterItem => filterItem.id == parentId);
            branchIndexes.push(index);
            parentId = filterItems[index].parentId;
        }
        return branchIndexes.reverse();
    }
    _getStore(selectedField) {
        return new CustomStore({
            load: (options) => {
                if (!selectedField) {
                    return undefined;
                }
                let result = createJQueryDeferred();
                if (options.filter) {
                    new ArrayStore({ data: this._dataCache })
                        .load({ filter: options.filter })
                        .then((data) => {
                        if (data && data.length) {
                            result.resolve(data);
                        }
                        else if (options.filter[0] === 'parentId') {
                            let parentId = (options.filter && options.filter[0] === 'parentId') ? options.filter[2] : treeRootValue;
                            let pathComponents = !!parentId ? parentId.split('.') : undefined;
                            let filterItemsState = this.getTreeListItems();
                            let branch = this._getBranchIndexes(filterItemsState, parentId);
                            this.dataSourceBrowser.getDimensionFilterItems(this.dashboardItem, selectedField.dataMember(), filterItemsState.map(i => i.data), branch).done(expandedItems => {
                                let items = expandedItems.map((item, index) => {
                                    return {
                                        id: parentId + '.' + index,
                                        parentId: parentId,
                                        displayName: item.IsBlank ? '(Blank)' : item.Text,
                                        hasItems: selectedField.hasItems(pathComponents),
                                        data: item
                                    };
                                });
                                var parentIndex = findIndex(this._dataCache, item => item.id === parentId);
                                this._dataCache.splice(parentIndex + 1, 0, ...items);
                                result.resolve(items);
                            });
                        }
                        else {
                            result.resolve([]);
                        }
                    });
                }
                return $promiseAdapter(result.promise());
            }
        });
    }
    _getTreeListOptions(store, searchEnabled) {
        return {
            dataSource: { store: store },
            noDataText: '',
            encodeNoDataText: true,
            rootValue: treeRootValue,
            dataStructure: 'plain',
            keyExpr: 'id',
            parentIdExpr: 'parentId',
            hasItemsExpr: 'hasItems',
            columns: [{
                    caption: getLocalizationById('DashboardStringId.FilterElementShowAllItem'),
                    dataField: 'displayName',
                }],
            selection: {
                allowSelectAll: true,
                mode: 'multiple',
                recursive: true
            },
            scrolling: {
                mode: 'virtual'
            },
            searchPanel: {
                placeholder: getLocalizationById('DashboardStringId.SearchNullValuePrompt'),
                visible: searchEnabled,
                width: '100%',
                searchVisibleColumnsOnly: true
            },
            remoteOperations: {
                filtering: true
            },
            showRowLines: false,
            onEditorPrepared: (e) => {
                $unwrap(e.editorElement).classList.remove('dx-treelist-checkbox-size');
            },
            onSelectionChanged: (e) => {
                e.component.forEachNode(node => {
                    node.data.data.IsChecked = e.component.isRowSelected(node.key);
                });
            },
            onCellPrepared: (e) => {
                if (e.rowType === 'data' && (e.data.data.IsChecked === null || e.data.data.IsChecked === undefined)) {
                    let editor = dxCheckBox.getInstance($unwrap(e.cellElement).querySelector('.dx-select-checkbox'));
                    if (editor) {
                        editor.option('value', undefined);
                    }
                }
            },
            onNodesInitialized: (e) => {
                let selectedKeys = [];
                e.component.forEachNode(node => {
                    if (node.data.data.IsChecked) {
                        selectedKeys.push(node.key);
                    }
                });
                e.component.selectRows(selectedKeys, false);
            },
            onInitialized: (e) => {
                this.treeList = e.component;
            },
        };
    }
}
