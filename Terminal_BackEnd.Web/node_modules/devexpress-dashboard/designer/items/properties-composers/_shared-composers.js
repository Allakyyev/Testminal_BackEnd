/**
* DevExpress Dashboard (_shared-composers.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { PointLabelContentType } from '../../../model';
import { dateTimeFormat, numericFormat } from '../../../model/data-item/metadata/_data-item';
import { customFormatString, dataItemCurrencyCultureName, dateFormat, dateHourFormat, dateHourMinuteFormat, dateTimeWithSecondsFormat, dayOfWeekFormat, exactDateFormat, formatType, formatTypeValues, hourFormat, includeGroupSeparator, monthFormat, precision, quarterFormat, unit, yearFormat } from '../../../model/data-item/metadata/_data-item-format';
import { NameGenerator } from '../../../model/internal/_helper-classes';
import { safeComputed, safeSubscribe, subscribeToArrayItemProperties } from '../../../model/internal/_knockout-utils';
import { SimpleSeries } from '../../../model/items/chart/chart-series';
import { axisVisible, enableZooming, limitVisiblePoints, logarithmic, logarithmicBase, reverse, showGridLinesBaseInfo, title, titleVisibleBaseInfo, visiblePointsCount } from '../../../model/items/chart/metadata/_chart-axis';
import { chartLegend } from '../../../model/items/chart/metadata/_chart-item';
import { chartLegendVisible, insidePosition, isInsideDiagram, outsidePosition } from '../../../model/items/chart/metadata/_chart-legend';
import { chartSeriesPointLabelOptions } from '../../../model/items/chart/metadata/_chart-series';
import { contentType, overlappingMode, pointLabelOrientation, position as pointLabelPosition, showForZeroValues, showPointLabels } from '../../../model/items/chart/metadata/_point-label-options';
import { area, colorLegend, shapeTitleAttributeName, weightedLegend } from '../../../model/items/map/metadata/_map-item';
import { legendType, legendPosition as mapLegendPosition, legendVisible as mapLegendvisible, weightedLegendVisible as mapWeightedLegendVisible } from '../../../model/items/map/metadata/_map-legend';
import { showCaption } from '../../../model/items/metadata/_dashboard-item';
import { resultIndicationThreshold, resultIndicationThresholdType } from '../../../model/items/options/metadata/_delta-options';
import { highlightMinMaxPoints, highlightStartEndPoints, viewType } from '../../../model/items/options/metadata/_sparkline-options';
import { DateTimePeriod } from '../../../model/items/range-filter/date-time-period';
import { dateTimePeriods } from '../../../model/items/range-filter/metadata/_range-filter-item';
import { content } from '../../../model/items/scatter-chart/metadata/_scatter-point-label-options';
import { ScatterChartItem } from '../../../model/items/scatter-chart/scatter-chart-item';
import { contentArrangementMode, contentLineCount, name } from '../../../model/metadata/_base-metadata';
import { DashboardPrivateSettings } from '../../../viewer-parts/legacy-settings';
import { collectionEditor, currencyEditor, dynamicSelectBoxEditor, editableListEditor, flagsEnumListEditor, iconTypeEditor, nestedPropertyGridEditor } from '../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../form-adapter/_object-properties-wrapper';
import { AccordionTab, KnownTabs } from '../../properties-controller/_accordion-tab';
import { CollectionEditorEditItemArguments } from '../../ui-widgets/collection-editor/_collection-editor-viewmodel';
import { CollectionEditorRefreshCallback } from '../../ui-widgets/collection-editor/_collection-editor-viewmodel-base';
import { MapCustomShapeFileSurface } from '../surfaces/_map-custom-shapefile-surface';
export class SharedComposers {
    static getCommonTab(model, properties = [], disabledRules = {}) {
        var wrapper = this.getCommonWrapper(model, properties, disabledRules);
        return new AccordionTab(KnownTabs.Common, 'DashboardWebStringId.AccordionTab.Common', wrapper);
    }
    static getAllTab(model) {
        return new AccordionTab('ALL', 'All', new ObjectPropertiesWrapper({
            model: model,
            properties: []
        }));
    }
    static getContentArrangementTab(model) {
        return new AccordionTab(KnownTabs.ContentArrangement, 'DashboardWebStringId.AccordionTab.Layout', this.getContentArrangementWrapper(model));
    }
    static getCommonWrapper(model, specificProperties = [], specificDisabledRules = {}, specificVisibilityRules = {}) {
        var properties = [
            showCaption,
            name
        ];
        properties = properties.concat(specificProperties);
        var disabledRules = {};
        Object.keys(specificDisabledRules).forEach((key) => {
            disabledRules[key] = specificDisabledRules[key];
        });
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            visibilityFilterRules: specificVisibilityRules,
            disabledFilterRules: disabledRules
        });
    }
    static getCommonMapWrapper(model, propertiesController, specificProperties = []) {
        const editHandler = () => {
            var surface = new MapCustomShapeFileSurface(model.customShapefile, propertiesController);
            surface.startEditing(new CollectionEditorEditItemArguments());
        };
        const editorOptions = {
            dataSource: Object.keys(area.values),
            getDisplayText: (item) => getLocalizationById(area.values[item]),
            enableEditItem: (item) => item === 'Custom',
            editItemHandler: editHandler,
            onSelectionChanged: (item) => {
                if (item === 'Custom' && !model.customShapefile.url() && !model.customShapefile.data.shapeData())
                    editHandler();
            },
        };
        var properties = [Object.assign(Object.assign({}, area), { formAdapterItem: editableListEditor(editorOptions) })].concat(specificProperties);
        return SharedComposers.getCommonWrapper(model, properties);
    }
    static updateValidationMessages(rules) {
        visiblePointsCount.validationRules.forEach((rule) => {
            if (rule.message)
                rule.message = getLocalizationById(rule.message);
        });
    }
    static getAxisWrapper(model, axisComputedTitle, alwaysShowZeroLevelInfo, isDateField = false, isNumericField = true, groupInterval = 'None') {
        var disabledRules = {};
        var visibilityRules = {};
        disabledRules[titleVisibleBaseInfo.propertyName] = [axisVisible.propertyName, '=', false];
        disabledRules[title.propertyName] = [[titleVisibleBaseInfo.propertyName, '=', false], 'or', [axisVisible.propertyName, '=', false]];
        disabledRules[logarithmicBase.propertyName] = [logarithmic.propertyName, '=', false];
        disabledRules[limitVisiblePoints.propertyName] = [axisVisible.propertyName, '=', false];
        disabledRules[visiblePointsCount.propertyName] = [[limitVisiblePoints.propertyName, '=', false], 'or', [axisVisible.propertyName, '=', false]];
        disabledRules[numericFormat.propertyName] = [numericFormat.propertyName, '=', false];
        disabledRules[dateTimeFormat.propertyName] = [dateTimeFormat.propertyName, '=', false];
        this.updateValidationMessages(visiblePointsCount.validationRules);
        var properties = alwaysShowZeroLevelInfo ? [alwaysShowZeroLevelInfo] : [];
        properties = properties.concat([
            reverse,
            showGridLinesBaseInfo,
            axisVisible,
            titleVisibleBaseInfo,
            Object.assign({ editorOptions: { placeholder: (axisComputedTitle && axisComputedTitle()) } }, title),
            logarithmic,
            logarithmicBase,
            enableZooming,
            limitVisiblePoints,
            visiblePointsCount,
        ]);
        if (isDateField) {
            properties.push({
                container: dateTimeFormat,
                properties: [
                    yearFormat,
                    monthFormat,
                    quarterFormat,
                    dayOfWeekFormat,
                    hourFormat,
                    dateFormat,
                    dateHourFormat,
                    dateHourMinuteFormat,
                    dateTimeWithSecondsFormat,
                    exactDateFormat
                ]
            });
            visibilityRules[yearFormat.propertyName] = () => groupInterval === 'Year';
            visibilityRules[quarterFormat.propertyName] = () => groupInterval === 'Quarter';
            visibilityRules[monthFormat.propertyName] = () => groupInterval === 'Month';
            visibilityRules[hourFormat.propertyName] = () => groupInterval === 'Hour';
            visibilityRules[dayOfWeekFormat.propertyName] = () => groupInterval === 'DayOfWeek';
            visibilityRules[dateFormat.propertyName] = () => groupInterval === 'DayMonthYear';
            visibilityRules[dateHourFormat.propertyName] = () => groupInterval === 'DateHour';
            visibilityRules[dateHourMinuteFormat.propertyName] = () => groupInterval === 'DateHourMinute';
            visibilityRules[dateTimeWithSecondsFormat.propertyName] = () => groupInterval === 'DateHourMinuteSecond';
            visibilityRules[exactDateFormat.propertyName] = () => groupInterval === 'None';
        }
        if (isNumericField) {
            properties.push(Object.assign(Object.assign({ sourceObject: this.getNumericFormatWrapper(model.numericFormat) }, numericFormat), { displayName: null, formAdapterItem: nestedPropertyGridEditor(getLocalizationById(numericFormat.displayName)) }));
        }
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: disabledRules,
            visibilityFilterRules: visibilityRules
        });
    }
    static getLegendWrapper(model) {
        var properties = [
            chartLegendVisible,
            isInsideDiagram,
            insidePosition,
            outsidePosition,
        ];
        var disabledRules = {};
        disabledRules[isInsideDiagram.propertyName] = [chartLegendVisible.propertyName, '=', false];
        disabledRules[insidePosition.propertyName] = [chartLegendVisible.propertyName, '=', false];
        disabledRules[outsidePosition.propertyName] = [chartLegendVisible.propertyName, '=', false];
        var visibleRules = {};
        visibleRules[insidePosition.propertyName] = [isInsideDiagram.propertyName, '=', true];
        visibleRules[outsidePosition.propertyName] = [isInsideDiagram.propertyName, '=', false];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [{
                    container: chartLegend,
                    properties: properties
                }],
            disabledFilterRules: disabledRules,
            visibilityFilterRules: visibleRules
        });
    }
    static getContentArrangementWrapper(model) {
        var properties = [
            contentArrangementMode,
            contentLineCount
        ];
        var disabledRules = {};
        disabledRules[contentLineCount.propertyName] = [contentArrangementMode.propertyName, '=', 'Auto'];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: disabledRules
        });
    }
    static getLabelsWrapper(model) {
        if (model) {
            let simpleSeries = model instanceof SimpleSeries ? model : null;
            var properties = [];
            if (model instanceof ScatterChartItem) {
                properties.push(showPointLabels);
                properties.push(content);
            }
            else {
                let isFullStackedSeries = simpleSeries && ['FullStackedBar', 'FullStackedLine', 'FullStackedArea', 'FullStackedSplineArea'].indexOf(simpleSeries.seriesType()) >= 0;
                var avaliablePointLabelContentTypes = isFullStackedSeries ?
                    [
                        { value: PointLabelContentType.Argument, displayValueId: 'DashboardStringId.PointLabelContentTypeArgument' },
                        { value: PointLabelContentType.SeriesName, displayValueId: 'DashboardStringId.PointLabelContentTypeSeriesName' },
                        { value: PointLabelContentType.Value, displayValueId: 'DashboardStringId.PointLabelContentTypeValue' },
                        { value: PointLabelContentType.Percent, displayValueId: 'DashboardStringId.PointLabelContentTypePercent' }
                    ]
                    :
                        [
                            { value: PointLabelContentType.Argument, displayValueId: 'DashboardStringId.PointLabelContentTypeArgument' },
                            { value: PointLabelContentType.SeriesName, displayValueId: 'DashboardStringId.PointLabelContentTypeSeriesName' },
                            { value: PointLabelContentType.Value, displayValueId: 'DashboardStringId.PointLabelContentTypeValue' }
                        ];
                properties.push(Object.assign(Object.assign({}, contentType), { formAdapterItem: flagsEnumListEditor({
                        values: avaliablePointLabelContentTypes,
                        enumDeclaration: PointLabelContentType
                    }) }));
            }
            properties = properties.concat([
                overlappingMode,
                pointLabelOrientation
            ]);
            if (simpleSeries && simpleSeries.seriesType().indexOf('Bar') > -1) {
                properties.push(showForZeroValues);
                properties.push(pointLabelPosition);
            }
            if (model instanceof ScatterChartItem) {
                properties.push(pointLabelPosition);
            }
            return new ObjectPropertiesWrapper({
                model: model,
                properties: [{
                        container: chartSeriesPointLabelOptions,
                        properties: properties
                    }],
                summary: ko.computed(() => (model.pointLabelOptions && model.pointLabelOptions.showPointLabels()) ? 'DashboardWebStringId.ButtonOn' : '')
            });
        }
        return null;
    }
    static getAttributeNamesSerializationInfo(model, propertyInfo, includeNoneValue = true, noneValueCaption = 'DashboardStringId.MapShapeNoneAttribute') {
        var attributeNames = safeComputed({ attributeNames: model._shapeFilesAttributeNameList }, args => {
            var attributes = args.attributeNames.map(attr => { return { value: attr, displayValueId: attr }; });
            if (includeNoneValue) {
                attributes.splice(0, 0, {
                    value: '', displayValueId: noneValueCaption
                });
            }
            return attributes;
        });
        var info = Object.assign(Object.assign({}, propertyInfo), { formAdapterItem: dynamicSelectBoxEditor({ values: attributeNames }) });
        return info;
    }
    static getShapeTitleSerializationInfo(model) {
        return SharedComposers.getAttributeNamesSerializationInfo(model, shapeTitleAttributeName);
    }
    static getColorLegendWrapper(model) {
        var properties = [
            mapLegendvisible,
            mapLegendPosition
        ];
        var disabledRules = {};
        disabledRules[mapLegendPosition.propertyName] = [mapLegendvisible.propertyName, '=', false];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [{
                    container: colorLegend,
                    properties: properties
                }],
            disabledFilterRules: disabledRules
        });
    }
    static getWeightedLegendWrapper(model) {
        var properties = [
            mapWeightedLegendVisible,
            legendType,
            mapLegendPosition
        ];
        var disabledRules = {};
        disabledRules[legendType.propertyName] = [mapWeightedLegendVisible.propertyName, '=', false];
        disabledRules[mapLegendPosition.propertyName] = [mapWeightedLegendVisible.propertyName, '=', false];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [{
                    container: weightedLegend,
                    properties: properties
                }],
            disabledFilterRules: disabledRules
        });
    }
    static getNumericFormatWrapper(model) {
        var measuredInUnits = (numericFormat) => {
            return numericFormat.formatType() === 'Number' || numericFormat.formatType() === 'Currency';
        };
        var notCustomizedFormat = (numericFormat) => {
            return numericFormat.formatType() === 'Auto' || numericFormat.formatType() === 'General';
        };
        var isCustomFormat = (numericFormat) => {
            return numericFormat.formatType() === 'Custom';
        };
        var disabledRules = {};
        disabledRules[unit.propertyName] = (numericFormat) => !measuredInUnits(numericFormat);
        disabledRules[precision.propertyName] = (numericFormat) => {
            return notCustomizedFormat(numericFormat) || (measuredInUnits(numericFormat) && numericFormat.unit() === 'Auto');
        };
        disabledRules[includeGroupSeparator.propertyName] = (numericFormat) => {
            return notCustomizedFormat(numericFormat) || numericFormat.formatType() === 'Scientific';
        };
        disabledRules[dataItemCurrencyCultureName.propertyName] = (numericFormat) => numericFormat.formatType() !== 'Currency';
        const visibilityFilterRules = {};
        visibilityFilterRules[unit.propertyName] = (model) => !isCustomFormat(model);
        visibilityFilterRules[precision.propertyName] = (model) => !isCustomFormat(model);
        visibilityFilterRules[includeGroupSeparator.propertyName] = (model) => !isCustomFormat(model);
        visibilityFilterRules[dataItemCurrencyCultureName.propertyName] = (model) => !isCustomFormat(model);
        visibilityFilterRules[customFormatString.propertyName] = (model) => isCustomFormat(model);
        var properties = [
            formatType,
            unit,
            precision,
            includeGroupSeparator,
            Object.assign(Object.assign({}, dataItemCurrencyCultureName), { formAdapterItem: currencyEditor() }),
            customFormatString
        ];
        if (DashboardPrivateSettings.customNumericFormatMode !== 'Enabled') {
            var restrictedFormatTypeValues = (Object.assign({}, formatTypeValues));
            delete restrictedFormatTypeValues['Custom'];
            properties = [
                Object.assign(Object.assign({}, formatType), { values: Object.assign({}, restrictedFormatTypeValues) }),
                ...properties.filter(p => p.propertyName !== formatType.propertyName && p.propertyName !== customFormatString.propertyName)
            ];
        }
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: disabledRules,
            visibilityFilterRules: visibilityFilterRules,
            summary: ko.pureComputed(() => notCustomizedFormat(model) ? '' : (formatTypeValues[model.formatType()] || model.formatType()))
        });
    }
    static getDeltaOptionsWrapper(model) {
        var disabledRules = {};
        disabledRules[resultIndicationThresholdType.propertyName] = (deltaOptions) => deltaOptions.resultIndicationMode() === 'NoIndication';
        disabledRules[resultIndicationThreshold.propertyName] = (deltaOptions) => deltaOptions.resultIndicationMode() === 'NoIndication';
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [],
            disabledFilterRules: disabledRules
        });
    }
    static getDeltaFormatsOptionsWrapper(model, editFormat = (model) => { }, ...additionalFormats) {
        var formats = this.getDeltaFormats(model);
        additionalFormats.forEach(format => formats.push(format));
        const collectionEditorOptions = {
            propertyName: 'title',
            editItemHandler: editFormat,
            allowAddItem: false,
            allowReorderItem: false,
            allowRemoveItem: false
        };
        return new ObjectPropertiesWrapper({
            model: { deltaFormats: ko.observableArray(formats) },
            properties: [{
                    formAdapterItem: collectionEditor(collectionEditorOptions),
                    propertyName: 'deltaFormats'
                }]
        });
    }
    static getDeltaFormats(kpiElement) {
        var formats = [];
        var actualValueFormat = kpiElement.actualValue() ? kpiElement.actualValue().numericFormat : null;
        var targetValueFormat = kpiElement.targetValue() ? kpiElement.targetValue().numericFormat : null;
        actualValueFormat && formats.push({ title: getLocalizationById('DashboardStringId.DeltaValueTypeActualValueCaption'), numericFormat: actualValueFormat });
        targetValueFormat && formats.push({ title: getLocalizationById('DashboardStringId.CardRowDataElementTypeTargetValueCaption'), numericFormat: targetValueFormat });
        return formats.concat([
            { title: getLocalizationById('DashboardStringId.DeltaValueTypeAbsoluteVariationCaption'), numericFormat: kpiElement.absoluteVariationNumericFormat },
            { title: getLocalizationById('DashboardStringId.DeltaValueTypePercentVariationCaption'), numericFormat: kpiElement.percentVariationNumericFormat },
            { title: getLocalizationById('DashboardStringId.DeltaValueTypePercentOfTargetCaption'), numericFormat: kpiElement.percentOfTargetNumericFormat }
        ]);
    }
    static getCustomRangesWrapper(model, editRuleHandler, dataSourceBrowser, dimension) {
        let namePrefix = getLocalizationById('DashboardStringId.DefaultPeriodName') + ' ';
        let isDateTimePeriodsPropertyVisible = ko.observable(false);
        let visibilityRules = {};
        visibilityRules[dateTimePeriods.propertyName] = () => {
            return isDateTimePeriodsPropertyVisible();
        };
        ko.computed(() => {
            if (dimension()) {
                dataSourceBrowser.findDataField(model.dataSource(), model.dataMember(), dimension().dataMember()).done((dataField) => {
                    isDateTimePeriodsPropertyVisible(dataField && dataField.fieldType() === 'DateTime');
                });
            }
        });
        const customItemTemplate = (itemData, itemIndex, itemElement) => {
            const name = ko.unwrap(itemData.name);
            const div = document.createElement('div');
            div.innerText = name;
            div.style.fontWeight = model.defaultDateTimePeriodName() === name ? '800' : 'normal';
            itemElement.appendChild(div);
            return div;
        };
        const refreshCallback = new CollectionEditorRefreshCallback();
        const subscriptions = [];
        subscriptions.push(safeSubscribe({ defaultPeriod: model.defaultDateTimePeriodName }, _ => refreshCallback.refresh()));
        subscriptions.push(subscribeToArrayItemProperties(model.dateTimePeriods, (period) => period.name.subscribe(() => refreshCallback.refresh())));
        const collectionEditorOptions = {
            propertyName: 'name',
            createNewItemHandler: () => new DateTimePeriod({ '@ItemType': 'DateTimePeriod', '@Name': NameGenerator.generateName(namePrefix, model.dateTimePeriods(), 'name', 1) }),
            editItemHandler: editRuleHandler,
            customTemplate: customItemTemplate,
            forceRefreshCallback: refreshCallback,
        };
        return new ObjectPropertiesWrapper({
            model: model,
            visibilityFilterRules: visibilityRules,
            properties: [Object.assign(Object.assign({}, dateTimePeriods), { formAdapterItem: collectionEditor(collectionEditorOptions) })],
            disposableModelSubscriptions: subscriptions,
        });
    }
    static getSparklineOptionsProperties() {
        let viewTypesMap = {
            'Line': {
                icon: 'dx-dashboard-chart-series-line',
                displayName: 'DashboardStringId.SparklineIndicationModeLine'
            },
            'Area': {
                icon: 'dx-dashboard-chart-series-area',
                displayName: 'DashboardStringId.SparklineIndicationModeArea'
            },
            'Bar': {
                icon: 'dx-dashboard-chart-series-bar',
                displayName: 'DashboardStringId.SparklineIndicationModeBar'
            },
            'WinLoss': {
                icon: 'dx-dashboard-sparkline-win-loss',
                displayName: 'DashboardStringId.SparklineIndicationModeWinLoss'
            }
        };
        return [
            Object.assign(Object.assign({}, viewType), { formAdapterItem: iconTypeEditor({ containersMap: viewTypesMap }) }),
            highlightMinMaxPoints,
            highlightStartEndPoints
        ];
    }
}
