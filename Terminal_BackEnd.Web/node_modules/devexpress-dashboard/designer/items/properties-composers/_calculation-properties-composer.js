/**
* DevExpress Dashboard (_calculation-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getDimensionsExpressions } from '../../../common/_helpers';
import { createJQueryDeferred } from '../../../data/_jquery-helpers';
import { getSummaryExpression } from '../../../model/data-item/_helpers';
import { calculation, windowDefinition } from '../../../model/data-item/metadata/_measure';
import { insertDimensionsExpressionsIntoFilterExpression } from '../../../model/internal/_expression-utils';
import { windowDefinitionEditor } from '../../calculations/_window-definition-editor';
import { ExpressionEditorDisplayNameProvider } from '../../expression-editor/_expression-editor-display-name-provider';
import { ExpressionEditorItemsProvider } from '../../expression-editor/_expression-editor-item-provider';
import { calculationExpressionEditor } from '../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../form-adapter/_object-properties-wrapper';
import { AccordionTab, KnownTabs } from '../../properties-controller/_accordion-tab';
export class CalculationPropertiesComposer {
    composeTabs(model, args) {
        var commonTab = new AccordionTab(KnownTabs.Common, 'DashboardWebStringId.AccordionTab.Common');
        this.fillCommonWrapper(commonTab, model, args.dashboardItem, args.dataSourceBrowser);
        return [commonTab];
    }
    fillCommonWrapper(tab, model, dashboardItem, dataSourceBrowser) {
        var p = [];
        var visibilityRules = {};
        p.push(Object.assign(Object.assign({}, windowDefinition), { formAdapterItem: windowDefinitionEditor({ dataDashboardItem: dashboardItem, dataSourceBrowser: dataSourceBrowser }) }));
        if (!model.expression()) {
            p.push({
                container: calculation,
                properties: [{
                        container: (model.calculation.getInfo()[0]),
                        properties: (model.calculation.calculation().getInfo())
                    }]
            });
        }
        var wrapper = new ObjectPropertiesWrapper({
            model: model,
            properties: p,
            visibilityFilterRules: visibilityRules
        });
        let expressionArgument = ko.observable();
        var getExpression = () => {
            if (!!model.expression()) {
                return model.expression();
            }
            return !!model.calculation.calculation() ? model.calculation.calculation()._getExpression(expressionArgument()) : '';
        };
        getCalculationArgumentExpression(model, dashboardItem, dataSourceBrowser)
            .done(expr => {
            expressionArgument(expr);
        });
        var expression = ko.computed({
            read: getExpression,
            write: (val) => {
                if (val !== getExpression()) {
                    model.expression(val);
                }
            }
        });
        var expressionOptions = {
            value: expression,
            path: ko.observable(dashboardItem.dataMember() ? [dashboardItem.dataSource(), dashboardItem.dataMember()].join('.') : dashboardItem.dataSource()),
            patchFieldName: (fieldPath) => {
                if (fieldPath.indexOf('Parameters.Parameters.') === 0) {
                    return 'Parameters.' + fieldPath.split('.')[2];
                }
                return fieldPath;
            },
        };
        var itemsProvider = new ExpressionEditorItemsProvider(dataSourceBrowser, dataSourceBrowser, dataSourceBrowser, dataSourceBrowser.parameters && dataSourceBrowser.parameters(), dashboardItem.dataSource, dashboardItem.dataMember);
        let displayNameProvider = ExpressionEditorDisplayNameProvider.create(dataSourceBrowser, dataSourceBrowser, dashboardItem.dataSource(), dashboardItem.dataMember());
        const collectionEditorOptions = {
            options: ko.observable(expressionOptions),
            fieldListProvider: ko.observable(itemsProvider),
            displayNameProvider: displayNameProvider
        };
        wrapper.addProperty(ko.observable(), { propertyName: 'expressionOptions', displayName: 'DashboardStringId.CalculationTypeExpression', formAdapterItem: calculationExpressionEditor(collectionEditorOptions) });
        tab.tabModel(wrapper);
    }
}
export function getCalculationArgumentExpression(measure, dashboardItem, dataFieldProvider) {
    let deferred = createJQueryDeferred();
    let summaryExpression = getSummaryExpression(measure.dataMember(), measure.summaryType());
    if (!measure.filterString())
        return deferred.resolve(summaryExpression).promise();
    getDimensionsExpressions(dashboardItem, dataFieldProvider)
        .done(dimnensionsExpressions => {
        let patchedExpression = insertDimensionsExpressionsIntoFilterExpression(measure.filterString(), dimnensionsExpressions);
        deferred.resolve(`filter(${summaryExpression}, ${patchedExpression})`);
    });
    return deferred.promise();
}
