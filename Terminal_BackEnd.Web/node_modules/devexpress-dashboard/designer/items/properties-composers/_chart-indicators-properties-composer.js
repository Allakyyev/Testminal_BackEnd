/**
* DevExpress Dashboard (_chart-indicators-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { extend } from '../../../data/_jquery-helpers';
import { getAvailableValueLevels, getChartApplyToDataItems, getChartSeries, getIndicatorDisplayNameFromSeries } from '../../../model/internal/_chart-utils';
import { safeSubscribe, subscribeToArrayItemProperties } from '../../../model/internal/_knockout-utils';
import { chartIndicatorColor, chartIndicatorDashStyle, chartIndicatorLegendText, chartIndicatorShowInLegend, chartIndicatorThickness, chartIndicatorType, chartIndicatorValue, chartIndicatorValueLevel, chartIndicatorVisible } from '../../../model/items/chart/metadata/_chart-indicators';
import { chartIndicators } from '../../../model/items/chart/metadata/_chart-item';
import { chartPaneName } from '../../../model/items/chart/metadata/_chart-pane';
import { collectionEditor, dynamicSelectBoxEditor, numberBoxEditor } from '../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../form-adapter/_object-properties-wrapper';
import { CollectionEditorRefreshCallback } from '../../ui-widgets/collection-editor/_collection-editor-viewmodel-base';
function updateValueLevelIems(model, dashboardItem) {
    const currentValueLevel = model.valueLevel();
    const valueLevelIems = getAvailableValueLevels(model.value.peek(), dashboardItem);
    if (valueLevelIems.length && (!currentValueLevel || valueLevelIems.filter(item => item.value === currentValueLevel).length === 0)) {
        model.valueLevel(valueLevelIems[0].value);
    }
    return valueLevelIems || [];
}
function updateDisplayName(model, dashboardItem, dataSourceBrowser) {
    let seriesDataId = model.value();
    let legendText = model.legendText();
    if (legendText || seriesDataId) {
        let displayName = legendText;
        if (!displayName && seriesDataId) {
            displayName = getIndicatorDisplayNameFromSeries(model, dashboardItem, dataSourceBrowser);
        }
        model.displayName(displayName);
    }
}
export class ChartIndicatorPropertiesComposer {
    static getIndicatorsWrapper(model, createIndicatorDelegate, editHandler) {
        const subscriptions = [];
        const refreshCallback = new CollectionEditorRefreshCallback();
        subscriptions.push(subscribeToArrayItemProperties(model.indicators, (indicator) => indicator.name.subscribe(() => refreshCallback.refresh())));
        var collectionEditorOptions = {
            createNewItemHandler: createIndicatorDelegate,
            propertyName: chartPaneName.propertyName,
            editItemHandler: editHandler,
            visibleItemsFilter: () => true,
            forceRefreshCallback: refreshCallback
        };
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [Object.assign(Object.assign({}, chartIndicators), { formAdapterItem: collectionEditor(collectionEditorOptions) })],
            disposableModelSubscriptions: subscriptions
        });
    }
    static getIndicatorPropertiesWrapper(model, dashboardItem, dataSourceBrowser, requestRecalculation, findExtension) {
        var _a;
        const disposables = [];
        const seriesDataItems = ko.pureComputed(() => {
            const chartSeries = getChartApplyToDataItems(dashboardItem, dataSourceBrowser, getChartSeries)();
            return chartSeries.map((m) => ({ value: ko.unwrap(m.uniqueName), displayValueId: ko.unwrap(m.displayName) }));
        });
        const seriesDataItemNames = seriesDataItems().map(dataItem => ko.unwrap(dataItem.value));
        if (!model.value() && seriesDataItemNames.length) {
            model.value(seriesDataItemNames[0]);
        }
        const valueLevelItems = ko.pureComputed(() => {
            const seriesDataId = model.value();
            if (seriesDataId) {
                return updateValueLevelIems(model, dashboardItem);
            }
            return [];
        });
        if (model.value()) {
            updateValueLevelIems(model, dashboardItem);
            setTimeout(() => {
                requestRecalculation.fire();
            });
        }
        disposables.push(seriesDataItems, valueLevelItems);
        disposables.push(safeSubscribe({
            seriesDataId: model.value,
            legendText: model.legendText,
            itemType: model.itemType
        }, () => updateDisplayName(model, dashboardItem, dataSourceBrowser)));
        disposables.push(safeSubscribe({
            typeName: model._typeName
        }, () => model._updateItemType()));
        const seriesDataIdProperty = Object.assign(Object.assign({}, chartIndicatorValue), { formAdapterItem: dynamicSelectBoxEditor({ values: seriesDataItems }) });
        const valueLevelProperty = Object.assign(Object.assign({}, chartIndicatorValueLevel), { formAdapterItem: dynamicSelectBoxEditor({ values: valueLevelItems }) });
        const thickness = Object.assign(Object.assign({}, chartIndicatorThickness), { formAdapterItem: numberBoxEditor({ min: 1, format: '#' }) });
        const customTypeMap = {};
        const indicatorsExtension = findExtension('chartIndicators');
        (_a = indicatorsExtension === null || indicatorsExtension === void 0 ? void 0 : indicatorsExtension.customChartIndicators) === null || _a === void 0 ? void 0 : _a.forEach(indicatorType => {
            customTypeMap[indicatorType.type] = indicatorType.displayName;
        });
        const type = Object.assign(Object.assign({}, chartIndicatorType), { propertyName: '_typeName', values: extend({}, chartIndicatorType.values, customTypeMap) });
        const properties = [
            chartPaneName, type, seriesDataIdProperty, valueLevelProperty,
            chartIndicatorValueLevel, chartIndicatorShowInLegend,
            chartIndicatorLegendText, chartIndicatorDashStyle,
            chartIndicatorColor, thickness, chartIndicatorVisible
        ];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: {},
            visibilityFilterRules: {},
            disposableModelSubscriptions: disposables
        });
    }
}
