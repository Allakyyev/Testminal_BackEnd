/**
* DevExpress Dashboard (_grid-column-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { DataField } from '../../../model/data-sources/_data-field';
import { classCaption } from '../../../model/format-rules/metadata/_dashboard-item-format-rule';
import { createObservableDataSource } from '../../../model/internal/_knockout-utils';
import { DataDashboardItem } from '../../../model/items/data-dashboard-item';
import { GridColumnTotal, _totalTypeTemplate } from '../../../model/items/grid/grid-column-total';
import { GridColumn, GridDeltaColumn, GridDimensionColumn, GridHyperlinkColumn, GridMeasureColumn, GridSparklineColumn } from '../../../model/items/grid/grid-columns';
import { GridItem } from '../../../model/items/grid/grid-item';
import { alwaysShowZeroLevel, columnType, columnWeight, dimensionDisplayMode, displayMode, fixedWidth, gridColumnDeltaOptions, gridColumnUriPattern, showStartEndValues, sparklineOptions, totalsTemplate, widthType } from '../../../model/items/grid/metadata/_grid-columns';
import { formatRules } from '../../../model/items/metadata/_data-dashboard-item';
import { deltaOptionsSerializationsInfo, resultIndicationThreshold, resultIndicationThresholdType } from '../../../model/items/options/metadata/_delta-options';
import { name } from '../../../model/metadata/_base-metadata';
import { getDataItemContainerDisplayName } from '../../_display-name-provider';
import { collectionEditor, inlineEditCollectionEditor } from '../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../form-adapter/_object-properties-wrapper';
import { AccordionTab, KnownTabs, TypeAccordionTab } from '../../properties-controller/_accordion-tab';
import { ContainerTypeSelector } from '../container-type-selector/_container-type-selector';
import { DataItemContainerPropertiesComposer } from './_base-properties-composer';
import { SharedComposers } from './_shared-composers';
export class GridColumnPropertiesComposer extends DataItemContainerPropertiesComposer {
    constructor(customizeHandler, editRuleHandler, editDeltaFormatHandler = (model) => { }) {
        super(customizeHandler);
        this.editRuleHandler = editRuleHandler;
        this.editDeltaFormatHandler = editDeltaFormatHandler;
    }
    _composeTabsCore(model, args) {
        var columnWidthTab = new AccordionTab(KnownTabs.Common, 'DashboardWebStringId.Grid.ColumnWidth'), deltaTab = new AccordionTab(KnownTabs.DeltaOptions, 'DashboardWebStringId.Grid.DeltaOptions'), deltaFormatsTab = new AccordionTab(KnownTabs.DeltaFormats, 'DashboardWebStringId.CardLayout.Editor.FormatOptions'), sparklineTab = new AccordionTab(KnownTabs.SparklineOptions, 'DashboardWebStringId.Card.SparklineOptions'), conditionalFormattingTab = new AccordionTab(KnownTabs.ConditionalFormatting, 'DashboardWebStringId.ConditionalFormatting'), totalTab = new AccordionTab(KnownTabs.Totals, 'DashboardWebStringId.AccordionTab.ShowTotals');
        let gridItem = args.dashboardItem;
        let result = [
            new AccordionTab(KnownTabs.Common, 'DashboardWebStringId.Options', this.getColumnWrapper(model, args.dashboardItem, args.dataSourceBrowser)),
            columnWidthTab,
            deltaTab,
            sparklineTab,
            totalTab,
            conditionalFormattingTab,
            deltaFormatsTab
        ];
        let isOlap = model.actualDataItem ? DataField.isOlap(model.actualDataItem.dataMember()) : false;
        if (!isOlap || args.containerType() !== 'GridDimensionColumn')
            result.unshift(new TypeAccordionTab(KnownTabs.Type, 'DashboardWebStringId.Type', this.getColumnTypeWrapper(model, args.containerType)));
        if (gridItem.gridOptions.columnWidthMode() === 'Manual') {
            columnWidthTab.tabModel(this.getWidthWrapper(model));
        }
        if (model instanceof GridDeltaColumn) {
            deltaTab.tabModel(this.getDeltaWrapper(model));
            deltaFormatsTab.tabModel(SharedComposers.getDeltaFormatsOptionsWrapper(model, this.editDeltaFormatHandler));
        }
        if (model instanceof GridSparklineColumn) {
            sparklineTab.tabModel(this.getSparklineWrapper(model));
        }
        if ((model instanceof GridDimensionColumn) || (model instanceof GridMeasureColumn)) {
            conditionalFormattingTab.tabModel(this.getFormatRulesWrapper(model, gridItem));
        }
        if (model instanceof GridColumn) {
            totalTab.tabModel(this.getTotalsWrapper(model, args.dashboardItem));
        }
        return result;
    }
    getColumnTypeWrapper(model, containerType) {
        if (model) {
            var properties = [
                columnType
            ];
            let isOlap = model.actualDataItem ? DataField.isOlap(model.actualDataItem.dataMember()) : undefined;
            let buttonTypes;
            if (!isOlap)
                buttonTypes = GridItem._gridColumnTypesMap;
            else {
                buttonTypes = Object.assign({}, GridItem._gridColumnTypesMap);
                delete buttonTypes['GridDimensionColumn'];
            }
            return new ContainerTypeSelector(buttonTypes, containerType);
        }
        return null;
    }
    getColumnWrapper(model, dashboardItem, dataSourceBrowser) {
        var properties = [Object.assign({ editorOptions: { placeholder: getDataItemContainerDisplayName(dataSourceBrowser, dashboardItem, model) } }, name)];
        var disabledRules = {};
        var visibilityRules = {};
        if (model instanceof GridDimensionColumn) {
            properties.push(dimensionDisplayMode);
            visibilityRules[dimensionDisplayMode.propertyName] = () => {
                var result = false;
                if (model.dimension()) {
                    dataSourceBrowser
                        .findDataField(dashboardItem.dataSource(), dashboardItem.dataMember(), model.dimension().dataMember())
                        .done(dataField => {
                        result = dataField && dataField.fieldType() === 'Custom';
                    });
                }
                return result;
            };
        }
        if (model instanceof GridMeasureColumn) {
            properties.push(displayMode);
            properties.push(alwaysShowZeroLevel);
            disabledRules[alwaysShowZeroLevel.propertyName] = [displayMode.propertyName, '<>', 'Bar'];
        }
        if (model instanceof GridHyperlinkColumn) {
            gridColumnUriPattern.validationRules.forEach(rule => { if (rule.message) {
                rule.message = getLocalizationById(rule.message);
            } });
            properties.push(gridColumnUriPattern);
        }
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: disabledRules,
            visibilityFilterRules: visibilityRules
        });
    }
    getWidthWrapper(model) {
        var properties = [
            widthType,
            fixedWidth,
            columnWeight,
        ];
        var disabledRules = {};
        disabledRules[fixedWidth.propertyName] = [widthType.propertyName, '<>', 'FixedWidth'];
        disabledRules[columnWeight.propertyName] = [widthType.propertyName, '<>', 'Weight'];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: disabledRules
        });
    }
    getTotalsWrapper(model, p) {
        var collectionEditorOptions = {
            dataFields: [_totalTypeTemplate.propertyName],
            noDataText: 'DashboardWebStringId.CollectionEditor.Totals.NoItems',
            gridColumns: [{
                    dataField: _totalTypeTemplate.propertyName,
                    calculateDisplayValue: (rowData) => GridColumnTotal.getDisplayValue(rowData.totalType),
                    lookup: {
                        displayExpr: 'displayValue',
                        valueExpr: 'value'
                    }
                }],
            customizeInlineEditor: (e) => {
                const totalTypes = ko.pureComputed(() => model._getAvailableTotalTypes(p).map(totalType => {
                    return { value: totalType.value, displayValue: getLocalizationById(totalType.displayValue) };
                }));
                const { dataSource, dispose: dataSourceDispose } = createObservableDataSource({ totalTypes }, arg => arg.totalTypes);
                e.editorOptions.dataSource = dataSource;
                e.editorOptions.onDisposing = () => {
                    dataSourceDispose();
                    totalTypes.dispose();
                };
            },
            createNewItemHandler: () => new GridColumnTotal({}),
        };
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [Object.assign(Object.assign({}, totalsTemplate), { formAdapterItem: inlineEditCollectionEditor(collectionEditorOptions) })],
            summary: ko.computed(() => model.totals().length ? 'DashboardWebStringId.ButtonOn' : '')
        });
    }
    getDeltaWrapper(model) {
        var properties = [
            displayMode,
            alwaysShowZeroLevel,
            {
                container: gridColumnDeltaOptions,
                properties: deltaOptionsSerializationsInfo
            }
        ];
        var visibleRules = {};
        visibleRules[alwaysShowZeroLevel.propertyName] = [displayMode.propertyName, '=', 'Bar'];
        deltaOptionsSerializationsInfo.forEach(opt => {
            visibleRules[opt.propertyName] = [displayMode.propertyName, '=', 'Value'];
        });
        var disabledRules = {};
        disabledRules[resultIndicationThresholdType.propertyName] = (deltaOptions) => deltaOptions.resultIndicationMode() === 'NoIndication';
        disabledRules[resultIndicationThreshold.propertyName] = (deltaOptions) => deltaOptions.resultIndicationMode() === 'NoIndication';
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties,
            disabledFilterRules: disabledRules,
            visibilityFilterRules: visibleRules
        });
    }
    getSparklineWrapper(model) {
        var properties = [
            showStartEndValues,
            {
                container: sparklineOptions,
                properties: SharedComposers.getSparklineOptionsProperties()
            }
        ];
        return new ObjectPropertiesWrapper({
            model: model,
            properties: properties
        });
    }
    getFormatRulesWrapper(model, dashboardItem) {
        var collectionEditorOptions = {
            propertyName: classCaption.propertyName,
            createNewItemHandler: () => DataDashboardItem._createFormatRule(null, {
                '@ItemType': 'GridItemFormatRule',
                '@DataItem': model.actualDataItem && model.actualDataItem.uniqueName() || undefined,
                '@DataItemApplyTo': model.actualDataItem && model.actualDataItem.uniqueName() || undefined
            }),
            editItemHandler: this.editRuleHandler,
            visibleItemsFilter: (rule) => {
                let uniqueName = model.actualDataItem && model.actualDataItem.uniqueName() || undefined;
                return rule.dataItemName() === uniqueName || rule.dataItemApplyToName() === uniqueName;
            },
        };
        return new ObjectPropertiesWrapper({
            model: dashboardItem,
            properties: [Object.assign(Object.assign({}, formatRules), { formAdapterItem: collectionEditor(collectionEditorOptions) })]
        });
    }
}
