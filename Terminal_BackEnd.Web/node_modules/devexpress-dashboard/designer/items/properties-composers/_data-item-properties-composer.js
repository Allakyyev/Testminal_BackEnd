/**
* DevExpress Dashboard (_data-item-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { DifferenceCalculation } from '../../../model/data-item/calculations/difference-calculation';
import { MovingCalculation } from '../../../model/data-item/calculations/moving-calculation';
import { PercentOfTotalCalculation } from '../../../model/data-item/calculations/percent-of-total-calculation';
import { RankCalculation } from '../../../model/data-item/calculations/rank-calculation';
import { RunningTotalCalculation } from '../../../model/data-item/calculations/running-total-calculation';
import { AcceptableShapingType } from '../../../model/data-item/data-item';
import { Dimension } from '../../../model/data-item/dimension';
import { Measure } from '../../../model/data-item/measure';
import { dateTimeFormat } from '../../../model/data-item/metadata/_data-item';
import { namelessDateFormat, namelessDateHourFormat, namelessDateHourMinuteFormat, namelessDateTimeWithSecondsFormat, namelessDayOfWeekFormat, namelessExactDateFormat, namelessHourFormat, namelessMonthFormat, namelessQuarterFormat, namelessYearFormat } from '../../../model/data-item/metadata/_data-item-format';
import { dateTimeGroupInterval, rangeDateTimeGroupInterval, realSortMode, sortOrderNonOlap, sortOrderOlap, textGroupInterval, topNOptionsCount, topNOptionsEnabled, topNOptionsMeasure, topNOptionsMode, topNOptionsModeValues, topNOptionsShowOthers } from '../../../model/data-item/metadata/_dimension';
import { calculations, measureFilterString, summaryTypeTemplate } from '../../../model/data-item/metadata/_measure';
import { DataField } from '../../../model/data-sources/_data-field';
import { CellsItemFormatRule } from '../../../model/format-rules/cells-item-format-rule';
import { classCaption } from '../../../model/format-rules/metadata/_dashboard-item-format-rule';
import { safeComputed } from '../../../model/internal/_knockout-utils';
import { wrapFuncWithUndoRedo } from '../../../model/internal/_undo-engine-helper';
import { DataDashboardItem } from '../../../model/items/data-dashboard-item';
import { formatRules } from '../../../model/items/metadata/_data-dashboard-item';
import { name } from '../../../model/metadata/_base-metadata';
import { CalculationSurface } from '../../calculations/items/surfaces/_calculation-surface';
import { createItemFilterOptions } from '../../filtering/_filter-utils';
import { ItemFilterDisplayNameProvider } from '../../filtering/_item-filter-display-name-provider';
import { ItemFilterItemsProvider } from '../../filtering/_item-filter-items-provider';
import { collectionEditor, editableListEditor, filterEditor } from '../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../form-adapter/_object-properties-wrapper';
import { AccordionTab, BindingAccordionTab, KnownTabs } from '../../properties-controller/_accordion-tab';
import { PropertiesController } from '../../properties-controller/_properties-controller';
import { CollectionEditorEditItemArguments } from '../../ui-widgets/collection-editor/_collection-editor-viewmodel';
import { getDataItemDisplayName } from '../../_display-name-provider';
import { getCalculationArgumentExpression } from './_calculation-properties-composer';
import { SharedComposers } from './_shared-composers';
export class DataItemsPropertiesComposer {
    static _addConstraint(wrapper, condition, propertiesInCondition) {
        let rulesToAdd = {};
        wrapper.getInfo().map(propInfo => propInfo.propertyName).forEach(propName => rulesToAdd[propName] = condition);
        DataItemsPropertiesComposer._mergeRules(wrapper.visibilityFilterRules, rulesToAdd, 'and');
        propertiesInCondition.forEach(prop => {
            if (wrapper.getInfo().filter(p => p.propertyName === prop.info.propertyName).length === 0) {
                wrapper.addProperty(prop.value, prop.info);
                wrapper.visibilityFilterRules[prop.info.propertyName] = () => false;
            }
        });
    }
    static _mergeRules(into, rules, operator) {
        Object.keys(rules).forEach(propName => {
            let currentRule = into[propName];
            let ruleToAdd = rules[propName];
            let newRule = currentRule ? [currentRule, operator, ruleToAdd] :
                operator === 'and' ? ruleToAdd : [];
            into[propName] = newRule;
        });
    }
    composeTabs(model, args) {
        if (args.constraint === undefined)
            args.constraint = () => true;
        if (args.propertiesController === undefined)
            args.propertiesController = new PropertiesController();
        var dataField = args.choosenField.peek(), bindingTab = new BindingAccordionTab(KnownTabs.Binding, 'DashboardWebStringId.Tabs.Binding'), optionsTab = new AccordionTab(KnownTabs.UnwrappedDataItem, 'DashboardWebStringId.Options'), dataShapingTab = new AccordionTab(KnownTabs.DataShaping, 'DashboardWebStringId.Tabs.DataShaping'), numericFormatTab = new AccordionTab(KnownTabs.NumericFormat, 'DashboardWebStringId.Tabs.Format'), dateTimeFormatTab = new AccordionTab(KnownTabs.DateTimeFormat, 'DashboardWebStringId.Tabs.Format'), topNTab = new AccordionTab(KnownTabs.TopN, 'DashboardStringId.CommandFormatRuleTopN'), calculationsTab = new AccordionTab(KnownTabs.Calculations, 'DashboardWebStringId.Calculations'), filterTab = new AccordionTab(KnownTabs.MeasureFilter, 'DashboardWebStringId.AccordionTab.MeasureFilter'), result = [bindingTab, optionsTab, dataShapingTab, numericFormatTab, dateTimeFormatTab, topNTab, calculationsTab, filterTab];
        optionsTab.orderNo = 90;
        calculationsTab.orderNo = 190;
        filterTab.orderNo = 195;
        numericFormatTab.orderNo = 200;
        dateTimeFormatTab.orderNo = 205;
        topNTab.orderNo = 210;
        this.fillBindingTab(bindingTab, model, args.choosenField, args.dataSourceBrowser, args.dataDashboardItem, args.constraint);
        var dataItem = model.dataItem();
        if (dataItem) {
            var fieldType = dataField && dataField.fieldType();
            if (args.unwrappedDataItem) {
                this.fillOptionsTab(optionsTab, dataItem, model, args.dataDashboardItem);
            }
            if (dataItem instanceof Dimension) {
                let measures = args.dataDashboardItem._measures.filter(measure => !measure._hasCalculation());
                this.fillDataShapingPropertiesTab(dataShapingTab, args.dataDashboardItem, model, dataField, measures, args.dataSourceBrowser);
                if (args.dataDashboardItem._isTopNEnabled(dataItem)) {
                    this.fillTopNTab(topNTab, args.dataDashboardItem, dataItem, dataField, measures, model._specifics.supportsTopNOther, args.dataSourceBrowser);
                }
                if (!model._specifics.skipFormatting && dataField && !DataField.isOlap(dataField.dataMember())) {
                    if (DataField.isNumeric(dataField)) {
                        numericFormatTab.tabModel(SharedComposers.getNumericFormatWrapper(dataItem.numericFormat));
                    }
                    else if (fieldType === 'DateTime') {
                        this.fillDimensionDatetimeFormatTab(dateTimeFormatTab, dataItem);
                    }
                }
                else if (model._specifics.forceAddOlapExactDateFormat && dataField && fieldType === 'DateTime' && DataField.isOlap(dataField.dataMember())) {
                    this.fillDataItemExactDatetimeFormatTab(dateTimeFormatTab, dataItem);
                }
            }
            if (dataItem instanceof Measure && !model._specifics.isAttribute) {
                if (args.dataDashboardItem._isCalculationSupported() && !DataField.isOlap(dataItem.dataMember())) {
                    this.fillCalculationsTab(calculationsTab, dataItem, args.dataDashboardItem, args.dataSourceBrowser, args.propertiesController);
                }
                if (!model._specifics.skipFormatting) {
                    let numericFormatWrapper = SharedComposers.getNumericFormatWrapper(dataItem.numericFormat);
                    if (!DataField.isNumeric(dataField)) {
                        DataItemsPropertiesComposer._addConstraint(numericFormatWrapper, [
                            [summaryTypeTemplate.propertyName, '<>', 'Min'], 'and',
                            [summaryTypeTemplate.propertyName, '<>', 'Max'], 'and',
                            [summaryTypeTemplate.propertyName, '<>', 'Mode']
                        ], [{ info: summaryTypeTemplate, value: dataItem.summaryType }]);
                    }
                    numericFormatTab.tabModel(numericFormatWrapper);
                    if (fieldType === 'DateTime') {
                        let exactDateWrapper = this._createExactDatePropertiesWrapper(dataItem);
                        DataItemsPropertiesComposer._addConstraint(exactDateWrapper, [
                            [summaryTypeTemplate.propertyName, '=', 'Min'], 'or',
                            [summaryTypeTemplate.propertyName, '=', 'Max'], 'or',
                            [summaryTypeTemplate.propertyName, '=', 'Mode']
                        ], [{ info: summaryTypeTemplate, value: dataItem.summaryType }]);
                        dateTimeFormatTab.tabModel(exactDateWrapper);
                    }
                }
                this._fillFilterTab(filterTab, dataItem, args.dataDashboardItem, args.dataSourceBrowser);
            }
        }
        return result;
    }
    fillBindingTab(bindingTab, model, choosenField, dataSourceBrowser, dataDashboardItem, constraint) {
        bindingTab.tabModel({
            choosenField: ko.observable(choosenField),
            dataItemLink: model,
            constraint: constraint,
            dataSourceBrowser: dataSourceBrowser,
            dataMemberPath: ko.observable(ko.computed(() => {
                if (dataDashboardItem.dataSource() && dataDashboardItem.dataMember()) {
                    return [dataDashboardItem.dataSource(), dataDashboardItem.dataMember()].join('.');
                }
                else if (dataDashboardItem.dataSource()) {
                    return dataDashboardItem.dataSource();
                }
                return '';
            })),
            additionalProperties: ko.observable(ko.pureComputed(() => {
                if (model._specifics.isAttribute || !choosenField())
                    return null;
                var properties = [];
                var dataItem = model.dataItem();
                if (dataItem instanceof Measure) {
                    var summaryTypeMeta = DataDashboardItem._getAvaliableSummaryTypeInfo(choosenField(), model._specifics.acceptableShapingType, dataItem);
                    if (summaryTypeMeta) {
                        properties.push(summaryTypeMeta);
                    }
                }
                if ((model.dataItem() instanceof Dimension)
                    && (!DataField.isOlap(model.dataItem().dataMember()))
                    && (choosenField() && choosenField().fieldType() === 'DateTime')) {
                    if (model._specifics.acceptableShapingType !== AcceptableShapingType.RangeDate) {
                        properties.push(dateTimeGroupInterval);
                    }
                    else {
                        properties.push(rangeDateTimeGroupInterval);
                    }
                }
                if (properties.length) {
                    return new ObjectPropertiesWrapper({
                        model: model.dataItem(),
                        properties: properties
                    });
                }
                return null;
            })),
            summary: ko.pureComputed(() => {
                var dataItemLink = bindingTab.tabModel() && bindingTab.tabModel().dataItemLink;
                return dataItemLink.dataItem() && dataItemLink.dataItem().dataMember() || '';
            }),
            summaryHint: ko.pureComputed(() => {
                var dataItemLink = bindingTab.tabModel() && bindingTab.tabModel().dataItemLink;
                return dataItemLink.dataItem() && (dataItemLink.dataItem().dataMember() + ' (' + dataItemLink.uniqueName() + ')') || '';
            })
        });
    }
    fillOptionsTab(tab, dataItem, model, dataDashboardItem) {
        var properties = [];
        properties.push(name);
        var newProperties = model
            ._specifics
            .customOptionsProperties
            .filter(p => !p.filter || p.filter(dataItem));
        properties = properties.concat(newProperties.map(p => p.serializationInfo));
        var disabledRules = {};
        newProperties
            .filter(x => !!x.disabledRule)
            .forEach((property) => {
            disabledRules[property.serializationInfo.propertyName] = (m) => { return property.disabledRule(dataItem); };
        });
        tab.tabModel(new ObjectPropertiesWrapper({
            model: dataItem,
            properties: properties,
            disabledFilterRules: disabledRules
        }));
    }
    fillDataShapingPropertiesTab(tab, dataDashboardItem, model, dataField, measures, dataSourceBrowser) {
        var dataItem = model.dataItem();
        var disableRules = {};
        if (dataItem) {
            var fieldType = dataField && dataField.fieldType();
            ko.computed(() => {
                var properties = [];
                if (dataItem instanceof Dimension) {
                    var topNEnabledFunc = () => dataItem.topNOptionsEnabled();
                    if (dataDashboardItem._isSortingEnabled()) {
                        if (dataField && DataField.isOlap(dataItem.dataMember())) {
                            properties.push(sortOrderOlap);
                            disableRules[sortOrderOlap.propertyName] = topNEnabledFunc;
                        }
                        else {
                            properties.push(sortOrderNonOlap);
                            disableRules[sortOrderNonOlap.propertyName] = topNEnabledFunc;
                        }
                        var values = [];
                        if (!DataField.isOlap(dataItem.dataMember())) {
                            values.push({
                                value: 'DXValue',
                                displayValue: 'DashboardStringId.CommandDimensionSortModeValue'
                            });
                        }
                        else {
                            values.push({
                                value: 'DXDisplayText',
                                displayValue: 'DashboardStringId.CommandDimensionSortModeDisplayText'
                            });
                            values.push({
                                value: 'DXValue',
                                displayValue: 'DashboardStringId.CommandDimensionSortModeValue'
                            });
                            values.push({
                                value: 'DXID',
                                displayValue: 'DashboardStringId.CommandDimensionSortModeID'
                            });
                            values.push({
                                value: 'DXKey',
                                displayValue: 'DashboardStringId.CommandDimensionSortModeKey'
                            });
                        }
                        properties.push(Object.assign({ valuesArray: values.concat(measures.filter(m => m instanceof Measure && !m.calculation.calculation() && !m.expression()).map(m => ({
                                value: m.uniqueName(),
                                displayValue: getDataItemDisplayName(dataSourceBrowser, dataDashboardItem, m)
                            }))) }, realSortMode));
                        disableRules[realSortMode.propertyName] = topNEnabledFunc;
                    }
                    switch (fieldType) {
                        case 'DateTime':
                            break;
                        case 'Text':
                            properties.push(textGroupInterval);
                            break;
                    }
                }
                properties = properties.concat(model
                    ._specifics
                    .customDataShapingProperties
                    .filter(p => !p.filter || p.filter(dataField))
                    .map(p => p.serializationInfo));
                var tabModel = properties.length > 0 ?
                    new ObjectPropertiesWrapper({
                        model: dataItem,
                        properties: properties,
                        disabledFilterRules: disableRules
                    })
                    : null;
                tab.tabModel(tabModel);
            });
        }
    }
    _createExactDateProperties() {
        let properties = [
            namelessYearFormat,
            namelessDateFormat,
            namelessDateHourFormat,
            namelessDateHourMinuteFormat,
            namelessDateTimeWithSecondsFormat
        ];
        let visibilityRules = {};
        visibilityRules[namelessYearFormat.propertyName] = [namelessExactDateFormat.propertyName, '=', 'Year'];
        visibilityRules[namelessDateFormat.propertyName] = [namelessExactDateFormat.propertyName, '=', 'Day'];
        visibilityRules[namelessDateHourFormat.propertyName] = [namelessExactDateFormat.propertyName, '=', 'Hour'];
        visibilityRules[namelessDateHourMinuteFormat.propertyName] = [namelessExactDateFormat.propertyName, '=', 'Minute'];
        visibilityRules[namelessDateTimeWithSecondsFormat.propertyName] = [namelessExactDateFormat.propertyName, '=', 'Second'];
        return { properties, visibilityRules };
    }
    fillDataItemExactDatetimeFormatTab(tab, model) {
        tab.tabModel(this._createExactDatePropertiesWrapper(model));
    }
    _createExactDatePropertiesWrapper(model) {
        let exactDateProperties = this._createExactDateProperties();
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [
                {
                    container: dateTimeFormat,
                    properties: [namelessExactDateFormat]
                },
                {
                    container: dateTimeFormat,
                    properties: exactDateProperties.properties
                }
            ],
            visibilityFilterRules: exactDateProperties.visibilityRules
        });
    }
    fillDimensionDatetimeFormatTab(tab, model) {
        var visibilityRules = {};
        var properties = [
            namelessExactDateFormat,
            namelessYearFormat,
            namelessMonthFormat,
            namelessQuarterFormat,
            namelessDayOfWeekFormat,
            namelessHourFormat,
            namelessDateFormat,
            namelessDateHourFormat,
            namelessDateHourMinuteFormat,
            namelessDateTimeWithSecondsFormat
        ];
        visibilityRules[dateTimeGroupInterval.propertyName] = () => false;
        visibilityRules[namelessYearFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'Year'];
        visibilityRules[namelessQuarterFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'Quarter'];
        visibilityRules[namelessMonthFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'Month'];
        visibilityRules[namelessHourFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'Hour'];
        visibilityRules[namelessDayOfWeekFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'DayOfWeek'];
        visibilityRules[namelessDateFormat.propertyName] = [
            [dateTimeGroupInterval.propertyName, '=', 'DayMonthYear'],
            'or',
            [dateTimeGroupInterval.propertyName, '=', 'WeekYear']
        ];
        visibilityRules[namelessDateHourFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'DateHour'];
        visibilityRules[namelessDateHourMinuteFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'DateHourMinute'];
        visibilityRules[namelessDateTimeWithSecondsFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'DateHourMinuteSecond'];
        visibilityRules[namelessExactDateFormat.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'None'];
        let exactDateProperties = this._createExactDateProperties();
        let exactDateIntervalConstraints = {};
        exactDateProperties.properties.forEach(edProp => exactDateIntervalConstraints[edProp.propertyName] = [dateTimeGroupInterval.propertyName, '=', 'None']);
        DataItemsPropertiesComposer._mergeRules(exactDateProperties.visibilityRules, exactDateIntervalConstraints, 'and');
        DataItemsPropertiesComposer._mergeRules(visibilityRules, exactDateProperties.visibilityRules, 'or');
        tab.tabModel(new ObjectPropertiesWrapper({
            model: model,
            properties: [
                dateTimeGroupInterval,
                {
                    container: dateTimeFormat,
                    properties: properties
                }
            ],
            visibilityFilterRules: visibilityRules
        }));
    }
    fillTopNTab(tab, dataDashboardItem, dataItem, dataField, measures, supportsTopNOther, dataSourceBrowser) {
        var disabledRules = {};
        var isTopNUnavailable = () => measures.length === 0;
        var topNOptionsDisabled = () => !dataItem.topNOptionsEnabled() || isTopNUnavailable();
        disabledRules[topNOptionsEnabled.propertyName] = isTopNUnavailable;
        disabledRules[topNOptionsCount.propertyName] = topNOptionsDisabled;
        disabledRules[topNOptionsMode.propertyName] = topNOptionsDisabled;
        disabledRules[topNOptionsMeasure.propertyName] = topNOptionsDisabled;
        disabledRules[topNOptionsShowOthers.propertyName] = topNOptionsDisabled;
        var visibilityRules = {};
        visibilityRules[topNOptionsShowOthers.propertyName] = () => supportsTopNOther;
        var properties = [
            topNOptionsEnabled,
            topNOptionsMode,
            topNOptionsCount,
            Object.assign({ valuesArray: measures.map((m) => { return { value: m.uniqueName(), displayValue: getDataItemDisplayName(dataSourceBrowser, dataDashboardItem, m) }; }) }, topNOptionsMeasure)
        ];
        if (dataField && !DataField.isOlap(dataField.dataMember())) {
            properties.push(topNOptionsShowOthers);
        }
        tab.tabModel(new ObjectPropertiesWrapper({
            model: dataItem,
            properties: properties,
            disabledFilterRules: disabledRules,
            visibilityFilterRules: visibilityRules,
            summary: ko.computed(() => {
                if (!topNOptionsDisabled()) {
                    if (!dataItem.topNOptionsMeasureName()) {
                        dataItem.topNOptionsMeasureName(measures[0] && measures[0].uniqueName());
                    }
                    var topNDataItem = measures.filter(di => di.uniqueName.peek() === dataItem.topNOptionsMeasureName())[0];
                    var modeDisplayValue = getLocalizationById(topNOptionsModeValues[dataItem.topNOptionsMode()]);
                    return modeDisplayValue + ' ' + dataItem.topNOptionsCount() + ' - ' + (!!topNDataItem ? topNDataItem.dataMember() : '');
                }
                return '';
            })
        }));
    }
    fillCalculationsTab(tab, measure, dataDashboardItem, dataSourceBrowser, propertiesController) {
        var noneCalculation = { title: 'DashboardStringId.CalculationTypeNone', data: { type: undefined } };
        var expressionCalculation = { title: 'DashboardStringId.CalculationTypeExpression', data: { type: undefined } };
        var calculationsInfo = Object.assign({}, calculations);
        var disabledRules = {};
        disabledRules[calculationsInfo.propertyName] = () => {
            return dataDashboardItem
                ._dimensions
                .some(dimension => {
                return (dimension.topNOptionsEnabled() && dimension.topNOptionsMeasureName() === measure.uniqueName()) || (dimension.sortMeasure() === measure.uniqueName());
            });
        };
        var availableCalculations = [
            noneCalculation,
            { title: 'DashboardStringId.CalculationTypePercentOfTotal', data: { type: PercentOfTotalCalculation } },
            { title: 'DashboardStringId.CalculationTypeRunningTotal', data: { type: RunningTotalCalculation } },
            { title: 'DashboardStringId.CalculationTypeDifference', data: { type: DifferenceCalculation, isEqual: (calc) => calc.differenceType() !== 'Percentage' } },
            { title: 'DashboardStringId.CalculationTypePercentageDifference', data: { type: DifferenceCalculation, default: { '@DifferenceType': 'Percentage' }, isEqual: (calc) => calc.differenceType() === 'Percentage' } },
            { title: 'DashboardStringId.CalculationTypeMovingCalculation', data: { type: MovingCalculation } },
            { title: 'DashboardStringId.CalculationTypeRank', data: { type: RankCalculation } },
            expressionCalculation
        ];
        var isEqual = (definition) => {
            return !!definition.data.type && measure.calculation.calculation() instanceof definition.data.type && (!definition.data.isEqual || definition.data.isEqual(measure.calculation.calculation()));
        };
        var selectedPredefinedCalculation = ko.computed({
            read: () => {
                var result = !!measure.expression() ? expressionCalculation : undefined;
                if (!result) {
                    result = availableCalculations.filter(definition => isEqual(definition))[0] || noneCalculation;
                }
                return result;
            },
            write: wrapFuncWithUndoRedo((val) => {
                if (val !== noneCalculation) {
                    if (val === expressionCalculation) {
                        if (!measure.expression()) {
                            getCalculationArgumentExpression(measure, dataDashboardItem, dataSourceBrowser).done(expr => {
                                measure.expression(expr);
                            });
                            measure.windowDefinition.windowDefinition(dataDashboardItem._getDefaultCalculationWindowDefinition());
                        }
                    }
                    else if (!isEqual(val)) {
                        measure.expression(undefined);
                        measure.calculation.calculation(new (val.data.type)(val.data.default));
                        measure.windowDefinition.windowDefinition(dataDashboardItem._getDefaultCalculationWindowDefinition());
                    }
                }
                else {
                    measure.expression(undefined);
                    measure.calculation.calculation(undefined);
                    measure.windowDefinition.windowDefinition(undefined);
                }
            })
        });
        const singleChoiceEditorOptions = {
            propertyName: 'title',
            dataSource: availableCalculations,
            enableEditItem: (calcDefinition) => calcDefinition !== noneCalculation,
            editItemHandler: (calcDefinition) => {
                if (calcDefinition !== noneCalculation) {
                    var surface = new CalculationSurface(calcDefinition, measure, dataDashboardItem, dataSourceBrowser, propertiesController);
                    surface.startEditing(new CollectionEditorEditItemArguments());
                }
            },
        };
        tab.tabModel(new ObjectPropertiesWrapper({
            model: {
                calculations: selectedPredefinedCalculation,
            },
            properties: [Object.assign(Object.assign({}, calculationsInfo), { formAdapterItem: editableListEditor(singleChoiceEditorOptions) })],
            disabledFilterRules: disabledRules,
            summary: ko.computed(() => selectedPredefinedCalculation().title !== noneCalculation.title ? selectedPredefinedCalculation().title : '')
        }));
    }
    _fillFilterTab(tab, model, dashboardItem, dataSourceBrowser) {
        if (!DataField.isOlap(model.dataMember())) {
            let measureFilterEditorParams = {
                fieldListProvider: ko.observable(new ItemFilterItemsProvider(dataSourceBrowser, dataSourceBrowser, dataSourceBrowser.parameters, dashboardItem, (di) => { return di instanceof Dimension; })),
                options: createItemFilterOptions(model.filterString, undefined, dataSourceBrowser, { text: 'MeasureFilter', localizationId: 'DashboardWebStringId.AccordionTab.MeasureFilter' }),
                displayNameProvider: new ItemFilterDisplayNameProvider(dashboardItem, dataSourceBrowser)
            };
            let wrapper = new ObjectPropertiesWrapper({
                model: model,
                properties: [
                    Object.assign(Object.assign({}, measureFilterString), { formAdapterItem: filterEditor(measureFilterEditorParams) })
                ],
                summary: safeComputed({ filterString: model.filterString }, (args) => { return !!args.filterString ? getLocalizationById('DashboardWebStringId.ButtonOn') : ''; }),
                visibilityFilterRules: {
                    [measureFilterString.propertyName]: () => !model.expression(),
                }
            });
            tab.tabModel(wrapper);
        }
    }
    static getCellFormatRuleCreator(dataItem, dataItemApplyTo, formatRuleItemType) {
        return () => {
            return DataDashboardItem._createFormatRule(null, {
                '@ItemType': formatRuleItemType,
                '@DataItem': dataItem.uniqueName(),
                '@DataItemApplyTo': dataItemApplyTo.uniqueName()
            });
        };
    }
    static getCellFormatRuleFilter(dataItem) {
        return (rule) => {
            if (rule instanceof CellsItemFormatRule) {
                let uniqueName = dataItem.uniqueName();
                return rule.dataItemName() === uniqueName || rule.dataItemApplyToName() === uniqueName;
            }
            return false;
        };
    }
    static getFormatRulesWrapper(model, createNewItemHandler, visibleItemsFilter, editHandler) {
        var collectionEditorOptions = Object.assign(Object.assign({ propertyName: classCaption.propertyName, createNewItemHandler: createNewItemHandler }, classCaption), { editItemHandler: editHandler, visibleItemsFilter: visibleItemsFilter });
        return new ObjectPropertiesWrapper({
            model: model,
            properties: [Object.assign(Object.assign({}, formatRules), { formAdapterItem: collectionEditor(collectionEditorOptions) })]
        });
    }
}
