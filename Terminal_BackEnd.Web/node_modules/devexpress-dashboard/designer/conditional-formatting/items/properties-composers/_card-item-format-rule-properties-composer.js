/**
* DevExpress Dashboard (_card-item-format-rule-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../../../data/localization/_default';
import { CardRow, CardRowTextElement, FormatConditionExpression } from '../../../../model';
import { CardItemDeltaFormatRule } from '../../../../model/format-rules/card-item-delta-format-rule';
import { CardItemFormatRule } from '../../../../model/format-rules/card-item-format-rule';
import { dimensionId, elementTypeApplyTo, textId } from '../../../../model/format-rules/metadata/_card-format-rule-row-element';
import { cardId, deltaValueType } from '../../../../model/format-rules/metadata/_card-item-delta-format-rule';
import { cardItemformatRuleDataItem } from '../../../../model/format-rules/metadata/_card-item-format-rule';
import { cardLayoutElement } from '../../../../model/format-rules/metadata/_card-item-format-rule-base';
import { cardFormatRuleLayoutElementValuesMap } from '../../../../model/items/card/metadata/_card-layout-template-element';
import { deltaValueTypeMap } from '../../../../model/items/options/metadata/_delta-options';
import { itemType } from '../../../../model/metadata/_base-metadata';
import { buttonGroupEditor, dynamicSelectBoxEditor } from '../../../form-adapter/_form-adapter-editors';
import { getDataItemContainerDisplayName, getDataItemDisplayName } from '../../../_display-name-provider';
import { createDataTypeObservable, createDeltaDataTypeObservable, FormatRulePropertiesComposer } from './_shared-format-rule-properties-composer';
function getCardItemFormatRuleDataItems(dashboardItem) {
    return dashboardItem.seriesDimensions().concat(dashboardItem.hiddenMeasures());
}
export function isDataItemFormatRuleAvaliable(dashboardItem) {
    return getCardItemFormatRuleDataItems(dashboardItem).length > 0;
}
export function createCardItemFormatRulePropertiesComposer(selectedRuleContainer) {
    return new FormatRulePropertiesComposer({
        createDataTypeObservable: createDataTypeObservable,
        getCommonFormatRuleProperties: (formatRule, dashboardItem, dataSourceBrowser) => {
            let propertiesInfo = {
                properties: [],
                disabledFilterRules: {},
                dynamicEditorRules: {},
                visibilityFilterRules: {}
            };
            var dataItems = getCardItemFormatRuleDataItems(dashboardItem);
            let dataItemsDisplayText = ko.pureComputed(() => dataItems.map(dataItem => {
                return {
                    value: dataItem.uniqueName(),
                    displayValueId: getDataItemDisplayName(dataSourceBrowser, dashboardItem, dataItem)
                };
            }));
            if (!formatRule.dataItemName() && dataItems.length) {
                formatRule.dataItemName(dataItems[0].uniqueName());
            }
            propertiesInfo.properties.push(Object.assign(Object.assign({}, cardItemformatRuleDataItem), { formAdapterItem: dynamicSelectBoxEditor({ values: dataItemsDisplayText }) }));
            return getCommonCardFormatRuleProperties(formatRule, dashboardItem, propertiesInfo, selectedRuleContainer);
        },
        getMiscFormatRuleProperties: () => ({ properties: [] }),
        conditionTypeFilter: cardItemConditionTypeFilters,
        getConditionFormatRuleProperties: getConditionFormatRuleProperties,
    });
}
function cardItemDeltaFormatRuleCards(dashboardItem) {
    return dashboardItem.cards();
}
export function isDeltaFormatRuleAvaliable(dashboardItem) {
    return cardItemDeltaFormatRuleCards(dashboardItem).length > 0;
}
export function createCardItemDeltaFormatRulePropertiesComposer(selectedRuleContainer) {
    return new FormatRulePropertiesComposer({
        createDataTypeObservable: createDeltaDataTypeObservable,
        getCommonFormatRuleProperties: (formatRule, dashboardItem, dataSourceBrowser, requestRecalculation) => {
            let propertiesInfo = {
                properties: [],
                disabledFilterRules: {},
                dynamicEditorRules: {},
                visibilityFilterRules: {}
            };
            var card = cardItemDeltaFormatRuleCards(dashboardItem);
            let cardsDisplayText = ko.pureComputed(() => card.map(card => {
                return {
                    value: card._getDataId(),
                    displayValueId: getDataItemContainerDisplayName(dataSourceBrowser, dashboardItem, card)
                };
            }));
            if (!formatRule.cardId() && cardsDisplayText().length) {
                formatRule.cardId(cardsDisplayText()[0].value);
            }
            propertiesInfo.disabledFilterRules[cardId.propertyName] = _ => !!formatRule.condition();
            propertiesInfo.disabledFilterRules[deltaValueType.propertyName] = _ => !!formatRule.condition();
            propertiesInfo.properties.push(Object.assign(Object.assign({}, cardId), { formAdapterItem: dynamicSelectBoxEditor({ values: cardsDisplayText }) }));
            propertiesInfo.properties.push(Object.assign(Object.assign({}, deltaValueType), { simpleFormAdapterItem: 'selectBoxEditor', values: deltaValueTypeMap }));
            propertiesInfo.properties.push(Object.assign(Object.assign({}, deltaValueType), { replacementPropertyName: 'fakeDeltaValueTypeActual', sourceObject: ko.observable('ActualValue'), simpleFormAdapterItem: 'selectBoxEditor', values: { 'ActualValue': 'DashboardStringId.DeltaValueTypeActualValueCaption' } }));
            propertiesInfo.properties.push(Object.assign(Object.assign({}, deltaValueType), { sourceObject: ko.observable('TargetValue'), replacementPropertyName: 'fakeDeltaValueTypeTarget', simpleFormAdapterItem: 'selectBoxEditor', values: { 'TargetValue': 'DashboardStringId.DeltaValueTypeTargetValueCaption' } }));
            const getActualCard = () => dashboardItem.cards().filter(card => card._getDataId() === formatRule.cardId())[0];
            const hasActualDataItem = () => !!getActualCard().actualValue();
            const hasTargetDataItem = () => !!getActualCard().targetValue();
            requestRecalculation.add(_ => {
                if (dashboardItem.formatRules.indexOf(formatRule) === -1) {
                    if (hasActualDataItem() && !hasTargetDataItem())
                        formatRule.deltaValueType('ActualValue');
                    else if (!hasActualDataItem() && hasTargetDataItem()) {
                        formatRule.deltaValueType('TargetValue');
                    }
                }
            });
            propertiesInfo.visibilityFilterRules[deltaValueType.propertyName] = _ => hasActualDataItem() && hasTargetDataItem();
            propertiesInfo.visibilityFilterRules['fakeDeltaValueTypeActual'] = _ => hasActualDataItem() && !hasTargetDataItem();
            propertiesInfo.visibilityFilterRules['fakeDeltaValueTypeTarget'] = _ => !hasActualDataItem() && hasTargetDataItem();
            propertiesInfo.disabledFilterRules['fakeDeltaValueTypeActual'] = _ => true;
            propertiesInfo.disabledFilterRules['fakeDeltaValueTypeTarget'] = _ => true;
            return getCommonCardFormatRuleProperties(formatRule, dashboardItem, propertiesInfo, selectedRuleContainer);
        },
        getConditionFormatRuleProperties: getConditionFormatRuleProperties,
        getMiscFormatRuleProperties: () => ({ properties: [] }),
        conditionTypeFilter: cardItemConditionTypeFilters
    });
}
function getConditionFormatRuleProperties(formatRule, dashboardItem, dataSourceBrowser) {
    let layoutElementTypeValues = Object.keys(cardFormatRuleLayoutElementValuesMap).map(key => {
        return { value: key, displayValue: getLocalizationById(cardFormatRuleLayoutElementValuesMap[key]) };
    });
    layoutElementTypeValues.push({ value: 'Dimension', displayValue: getLocalizationById('DashboardWebStringId.FormatRuleApplyToDimensionElement') });
    layoutElementTypeValues.push({ value: 'Text', displayValue: getLocalizationById('DashboardWebStringId.FormatRuleApplyToTextElement') });
    let textEditorValues = getAllApplyToTextElements(formatRule, dashboardItem);
    let dimensionEditorValues = dashboardItem.seriesDimensions().map(dimension => {
        return { value: dimension.uniqueName(), displayValue: getDataItemDisplayName(dataSourceBrowser, dashboardItem, dimension) };
    });
    let visibilityFilterRules = {};
    visibilityFilterRules[dimensionId.propertyName] = (model) => model.elementTypeApplyTo() === 'Dimension';
    visibilityFilterRules[textId.propertyName] = (model) => model.elementTypeApplyTo() === 'Text';
    let properties = [{
            container: cardLayoutElement,
            properties: [
                Object.assign(Object.assign({}, elementTypeApplyTo), { valuesArray: layoutElementTypeValues }),
                Object.assign(Object.assign({}, dimensionId), { valuesArray: dimensionEditorValues }),
                Object.assign(Object.assign({}, textId), { valuesArray: textEditorValues })
            ]
        }];
    return {
        properties: properties,
        disabledFilterRules: {},
        dynamicEditorRules: {},
        visibilityFilterRules: visibilityFilterRules
    };
}
function getAllApplyToTextElements(formatRule, dashboardItem) {
    let isExpressionRule = formatRule.condition() instanceof FormatConditionExpression;
    let isHiddenMeasureRule = formatRule instanceof CardItemFormatRule && dashboardItem.hiddenMeasures().filter(measure => measure.uniqueName() === formatRule.dataItemName()).length > 0;
    let affectedCards = isExpressionRule || isHiddenMeasureRule ? dashboardItem.cards() : [(dashboardItem.cards()[dashboardItem._selectedElementIndex() || 0])];
    return affectedCards.map(card => getCardApplyToTextElements(card)).reduce((prev, curr) => [...prev, ...curr]);
}
function getCardApplyToTextElements(card) {
    let textElements = getCardRows(card).map(row => row.elements().filter(element => element instanceof CardRowTextElement));
    if (textElements.length > 0) {
        return textElements.reduce((prev, current) => [...prev, ...current])
            .map(textElement => {
            return { value: textElement.text(), displayValue: textElement.text() };
        });
    }
    else
        return [];
}
function getCardRows(card) {
    let layoutTemplate = card.layoutTemplate();
    let layout = layoutTemplate ? layoutTemplate.layout : null;
    return layout ? layout.rows().filter(element => element instanceof CardRow) : [];
}
export let cardItemConditionTypeFilters = {
    conditionTypeFilter: (conditionTypePropertyName) => {
        return ['conditionBar', 'conditionColorRangeBar', 'conditionGradientRangeBar'].indexOf(conditionTypePropertyName) === -1;
    }
};
function getCommonCardFormatRuleProperties(formatRule, dashboardItem, calculatedByProperties, selectedRuleContainer) {
    let propertiesInfo = {
        properties: [],
        disabledFilterRules: {},
        dynamicEditorRules: {},
        visibilityFilterRules: {}
    };
    let selectedRuleType = ko.observable(formatRule.itemType());
    selectedRuleType.subscribe(newSelectedContainer => {
        if (newSelectedContainer === 'CardItemFormatRule') {
            selectedRuleContainer(new CardItemFormatRule());
        }
        else if (newSelectedContainer === 'CardItemDeltaFormatRule') {
            selectedRuleContainer(new CardItemDeltaFormatRule());
        }
    });
    propertiesInfo.properties.push(Object.assign(Object.assign({}, itemType), { sourceObject: selectedRuleType, replacementPropertyName: 'selectedContainer', displayName: 'DashboardWebStringId.ConditionalFormatting.CalculatedBy', formAdapterItem: buttonGroupEditor([
            {
                displayValueId: 'DashboardWebStringId.ConditionalFormatting.CardRuleTypeCard',
                value: 'CardItemDeltaFormatRule'
            },
            {
                displayValueId: 'DashboardWebStringId.ConditionalFormatting.CardRuleTypeDataItem',
                value: 'CardItemFormatRule'
            }
        ]) }));
    propertiesInfo.disabledFilterRules['selectedContainer'] = m => !!formatRule.condition() || !isDeltaFormatRuleAvaliable(dashboardItem) || !isDataItemFormatRuleAvaliable(dashboardItem);
    propertiesInfo.properties.push(...calculatedByProperties.properties);
    propertiesInfo.disabledFilterRules = Object.assign(Object.assign({}, propertiesInfo.disabledFilterRules), calculatedByProperties.disabledFilterRules);
    propertiesInfo.dynamicEditorRules = Object.assign(Object.assign({}, propertiesInfo.dynamicEditorRules), calculatedByProperties.dynamicEditorRules);
    propertiesInfo.visibilityFilterRules = Object.assign(Object.assign({}, propertiesInfo.visibilityFilterRules), calculatedByProperties.visibilityFilterRules);
    return propertiesInfo;
}
