/**
* DevExpress Dashboard (_shared-format-rule-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { LegacySettings } from '../../../../common';
import { getLocalizationById } from '../../../../data/localization/_default';
import { CardItem, ChartItem, FormatConditionBar, FormatConditionColorRangeBar, FormatConditionDateOccurring, FormatConditionGradientRangeBar, FormatConditionRangeGradient, FormatConditionRangeSet, FormatConditionValue, GridItem, PivotItem, ScatterChartItem } from '../../../../model';
import { Dimension } from '../../../../model/data-item/dimension';
import { Measure } from '../../../../model/data-item/measure';
import { FilterDateType } from '../../../../model/enums';
import { FormatConditionAverage } from '../../../../model/format-rules/conditions/format-condition-average';
import { FormatConditionExpression } from '../../../../model/format-rules/conditions/format-condition-expression';
import { FormatConditionTopBottom } from '../../../../model/format-rules/conditions/format-condition-top-bottom';
import { barCurrentStyleSettings, barCurrentStyleSettingsType } from '../../../../model/format-rules/conditions/metadata/_format-condition-bar';
import { allowNegativeAxis, drawAxis, showBarOnly } from '../../../../model/format-rules/conditions/metadata/_format-condition-bar-options';
import { baseDateTypeValues, dateType, extendedDateTypeValues } from '../../../../model/format-rules/conditions/metadata/_format-condition-date-occuring';
import { formatConditionFilter } from '../../../../model/format-rules/conditions/metadata/_format-condition-expression';
import { formatConditionMaximum, formatConditionMinimum, maximumType, minimumType } from '../../../../model/format-rules/conditions/metadata/_format-condition-min-max-base';
import { _actualRankType, rank } from '../../../../model/format-rules/conditions/metadata/_format-condition-top-bottom';
import { conditionInCondition, formatConditionValue1, formatConditionValue2 } from '../../../../model/format-rules/conditions/metadata/_format-condition-value';
import { rangeSet, rangeValueType } from '../../../../model/format-rules/conditions/range/metadata/_format-condition-range-base';
import { segmentNumber } from '../../../../model/format-rules/conditions/range/metadata/_format-condition-range-gradient';
import { dataItemApplyTo, formatRuleDataItem } from '../../../../model/format-rules/metadata/_cells-item-format-rule';
import { condition, enabled } from '../../../../model/format-rules/metadata/_dashboard-item-format-rule';
import { barOptions, complexValueValue, styleSettings } from '../../../../model/format-rules/metadata/_format-rules-common';
import { NameGenerator } from '../../../../model/internal/_helper-classes';
import { safeSubscribe } from '../../../../model/internal/_knockout-utils';
import { ParameterHelper } from '../../../../model/parameters/_parameters-helper';
import { createItemFilterOptions } from '../../../filtering/_filter-utils';
import { ItemFilterDisplayNameProvider } from '../../../filtering/_item-filter-display-name-provider';
import { ItemFilterItemsProvider, getRealDimensionType } from '../../../filtering/_item-filter-items-provider';
import { conditionTypeEditor, dynamicSelectBoxEditor, filterEditor, flagsEnumTagBoxEditor, ruleRangesEditor, styleSettingsEditor } from '../../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../../form-adapter/_object-properties-wrapper';
import { AccordionTab, KnownTabs } from '../../../properties-controller/_accordion-tab';
export class FormatRulePropertiesComposer {
    constructor(_options) {
        this._options = _options;
    }
    composeTabs(model, args) {
        const commonTab = new AccordionTab(KnownTabs.FormatRuleCommon, 'DashboardWebStringId.AccordionTab.Common');
        const conditionTab = new AccordionTab(KnownTabs.FormatRuleCondition, 'DashboardWebStringId.ConditionalFormatting.Condition');
        const miscTab = new AccordionTab(KnownTabs.FormatRuleMisc, 'DashboardWebStringId.ConditionalFormatting.Miscellaneous');
        let additionalTabs = [];
        this._fillCommonFormatRuleCommonWrapper(commonTab, model, args.dashboardItem, args.dataSourceBrowser, args.requestRecalculation, args.specificTypeChanged);
        if (ko.unwrap(model && model.condition)) {
            this._fillConditionWrapper(conditionTab, model, args.dashboardItem, args.dataSourceBrowser);
            additionalTabs = this._options.getAdditionalTabs && this._options.getAdditionalTabs(model, args.dashboardItem, args.dataSourceBrowser);
            this._fillMiscWrapper(miscTab, model, args.dashboardItem, args.dataSourceBrowser);
        }
        return [commonTab, conditionTab, ...(additionalTabs || []), miscTab].filter(tab => !!tab);
    }
    _fillCommonFormatRuleCommonWrapper(tab, formatRule, dashboardItem, dataSourceBrowser, requestRecalculation, specificTypeChanged) {
        let propertiesInfo = this._options.getCommonFormatRuleProperties(formatRule, dashboardItem, dataSourceBrowser, requestRecalculation);
        let disabledRules = {};
        const dataType = this._options.createDataTypeObservable(formatRule, dashboardItem, dataSourceBrowser);
        disabledRules[formatRuleDataItem.propertyName] = () => !!ko.unwrap(formatRule.condition);
        disabledRules['typeChooser'] = function () { return !!ko.unwrap(formatRule.condition); };
        let wrapper = new ObjectPropertiesWrapper({
            model: formatRule,
            visibilityFilterRules: propertiesInfo.visibilityFilterRules,
            properties: propertiesInfo.properties,
            disabledFilterRules: Object.assign(Object.assign({}, disabledRules), propertiesInfo.disabledFilterRules)
        });
        addConditionEditor(wrapper, dataType, formatRule, dashboardItem, requestRecalculation, specificTypeChanged, this._options.conditionTypeFilter);
        tab.tabModel(wrapper);
    }
    _fillConditionWrapper(tab, model, dashboardItem, dataSourceBrowser) {
        let p = [];
        let visibilityRules = {};
        visibilityRules[rangeValueType.propertyName] = () => model.condition() && !model.condition().dateTimeGroupInterval();
        const isChartItem = dashboardItem instanceof ChartItem || dashboardItem instanceof ScatterChartItem;
        const isAppearanceItem = dashboardItem instanceof GridItem
            || dashboardItem instanceof PivotItem
            || dashboardItem instanceof CardItem;
        const enableCustomStyles = isChartItem || isAppearanceItem;
        const restrictToColor = !isAppearanceItem;
        let simpleStylesAppearance = isChartItem ? 'RichColors' : 'Appearance';
        let barStylesAppearance = 'AllColors';
        let gradientStylesAppearance = 'GradientColors';
        let simpleStyleSettingsEditorOptions = {
            allowChangeViewMode: !isChartItem,
            appearanceMode: simpleStylesAppearance,
            isEmptyAllowed: false,
            enableCustomStyles,
            restrictToColor
        };
        let barStyleSettingsEditorOptions = {
            allowChangeViewMode: false,
            appearanceMode: barStylesAppearance,
            isEmptyAllowed: false,
            enableCustomStyles,
            restrictToColor
        };
        switch (model.condition() && model.condition().constructor) {
            case FormatConditionValue:
                const { simpleFormAdapterItem, editorOptions } = ParameterHelper.getEditorType(model.condition()[formatConditionValue1.propertyName].type());
                p.push({
                    container: condition,
                    properties: [{
                            container: formatConditionValue1,
                            properties: [
                                Object.assign({ simpleFormAdapterItem,
                                    editorOptions, displayName: 'DashboardStringId.ValueCaption', replacementPropertyName: 'value1_value' }, complexValueValue)
                            ]
                        }, {
                            container: formatConditionValue2,
                            properties: [Object.assign({ simpleFormAdapterItem,
                                    editorOptions, displayName: 'DashboardStringId.Value2Caption', replacementPropertyName: 'value2_value' }, complexValueValue)]
                        }, Object.assign(Object.assign({}, styleSettings), { formAdapterItem: styleSettingsEditor(simpleStyleSettingsEditorOptions) }), conditionInCondition,]
                });
                visibilityRules['value2_value'] =
                    [conditionInCondition.propertyName, 'contains', 'Between'];
                visibilityRules[conditionInCondition.propertyName] = () => false;
                break;
            case FormatConditionTopBottom:
                p.push({
                    container: condition,
                    properties: [
                        Object.assign(Object.assign({}, styleSettings), { formAdapterItem: styleSettingsEditor(simpleStyleSettingsEditorOptions) }),
                        rank,
                        _actualRankType
                    ]
                });
                break;
            case FormatConditionAverage:
                p.push({
                    container: condition,
                    properties: [
                        Object.assign(Object.assign({}, styleSettings), { formAdapterItem: styleSettingsEditor(simpleStyleSettingsEditorOptions) }),
                    ]
                });
                break;
            case FormatConditionDateOccurring:
                p.push({
                    container: condition,
                    properties: [
                        Object.assign(Object.assign({}, styleSettings), { formAdapterItem: styleSettingsEditor(simpleStyleSettingsEditorOptions) }),
                        Object.assign(Object.assign({}, dateType), { formAdapterItem: flagsEnumTagBoxEditor({
                                values: baseDateTypeValues.concat(LegacySettings.showExtendedDateOccurringList ? extendedDateTypeValues : []),
                                enumDeclaration: FilterDateType
                            }) })
                    ]
                });
                break;
            case FormatConditionExpression:
                let expressionCondition = model.condition();
                let ruleExpressionEditorParams = {
                    fieldListProvider: ko.observable(new ItemFilterItemsProvider(dataSourceBrowser, dataSourceBrowser, dataSourceBrowser.parameters, dashboardItem, (di) => dashboardItem._conditionFormattingExpressionEditorFilter(di))),
                    options: createItemFilterOptions(expressionCondition.expression, expressionCondition, dataSourceBrowser, { text: 'Expression', localizationId: 'DashboardStringId.CommandFormatRuleExpression' }),
                    displayNameProvider: new ItemFilterDisplayNameProvider(dashboardItem, dataSourceBrowser)
                };
                p.push({
                    container: condition,
                    properties: [
                        Object.assign(Object.assign({}, formatConditionFilter), { formAdapterItem: filterEditor(ruleExpressionEditorParams) }),
                        Object.assign(Object.assign({}, styleSettings), { formAdapterItem: styleSettingsEditor(simpleStyleSettingsEditorOptions) }),
                    ]
                });
                break;
            case FormatConditionBar:
                p.push({
                    container: condition,
                    properties: [
                        minimumType,
                        formatConditionMinimum,
                        maximumType,
                        formatConditionMaximum,
                        barCurrentStyleSettingsType,
                        Object.assign(Object.assign({}, barCurrentStyleSettings), { formAdapterItem: styleSettingsEditor(barStyleSettingsEditorOptions) }),
                        {
                            container: barOptions,
                            properties: [
                                allowNegativeAxis,
                                drawAxis,
                                showBarOnly
                            ]
                        }
                    ]
                });
                visibilityRules[formatConditionMinimum.propertyName] = [minimumType.propertyName, '<>', 'Automatic'];
                visibilityRules[formatConditionMaximum.propertyName] = [maximumType.propertyName, '<>', 'Automatic'];
                break;
            case FormatConditionColorRangeBar:
                p.push({
                    container: condition,
                    properties: [
                        rangeValueType,
                        Object.assign(Object.assign({}, rangeSet), { formAdapterItem: ruleRangesEditor({ condition: model.condition(), appearanceMode: barStylesAppearance, enableCustomStyles, restrictToColor: true }) }),
                        {
                            container: barOptions,
                            properties: [
                                allowNegativeAxis,
                                drawAxis,
                                showBarOnly
                            ]
                        }
                    ]
                });
                break;
            case FormatConditionGradientRangeBar:
                p.push({
                    container: condition,
                    properties: [
                        rangeValueType,
                        segmentNumber,
                        Object.assign(Object.assign({}, rangeSet), { formAdapterItem: ruleRangesEditor({ condition: model.condition(), appearanceMode: gradientStylesAppearance, enableCustomStyles, restrictToColor: true }) }),
                        {
                            container: barOptions,
                            properties: [
                                allowNegativeAxis,
                                drawAxis,
                                showBarOnly
                            ]
                        }
                    ]
                });
                break;
            case FormatConditionRangeGradient:
                p.push({
                    container: condition,
                    properties: [
                        rangeValueType,
                        segmentNumber,
                        Object.assign(Object.assign({}, rangeSet), { formAdapterItem: ruleRangesEditor({ condition: model.condition(), appearanceMode: gradientStylesAppearance, enableCustomStyles, restrictToColor }) }),
                    ]
                });
                break;
            case FormatConditionRangeSet:
                p.push({
                    container: condition,
                    properties: [
                        rangeValueType,
                        Object.assign(Object.assign({}, rangeSet), { formAdapterItem: ruleRangesEditor({ condition: model.condition(), appearanceMode: simpleStylesAppearance, enableCustomStyles, restrictToColor }) }),
                    ]
                });
                break;
            case undefined:
                break;
            default:
                throw new Error('Unsupported formatting rule condition');
        }
        var additionProperties = this._options.getConditionFormatRuleProperties(model, dashboardItem, dataSourceBrowser);
        let wrapper = new ObjectPropertiesWrapper({
            model: model,
            properties: p.concat(additionProperties.properties),
            visibilityFilterRules: Object.assign(Object.assign({}, visibilityRules), additionProperties.visibilityFilterRules),
            disabledFilterRules: additionProperties.disabledFilterRules,
            dynamicEditorRules: additionProperties.dynamicEditorRules
        });
        tab.tabModel(wrapper);
    }
    _fillMiscWrapper(tab, model, dashboardItem, dataSourceBrowser) {
        let miscProperties = this._options.getMiscFormatRuleProperties(model, dashboardItem, dataSourceBrowser);
        let wrapper = new ObjectPropertiesWrapper({
            model: model,
            properties: [
                enabled,
                ...miscProperties.properties
            ],
            disabledFilterRules: miscProperties.disabledFilterRules,
            dynamicEditorRules: miscProperties.dynamicEditorRules,
            visibilityFilterRules: miscProperties.visibilityFilterRules
        });
        tab.tabModel(wrapper);
    }
}
export function createDeltaDataTypeObservable(model, dashboardItem, dataSourceBrowser) {
    const dataType = ko.observable(model.condition() && model.condition().dataType());
    let fillDataTypeForDelta = () => {
        let fillDataTypes = (measure) => {
            dataSourceBrowser.findDataField(dashboardItem.dataSource(), dashboardItem.dataMember(), measure.dataMember()).done(field => {
                let summaryType = measure.summaryType();
                if ((summaryType === 'Count') || (summaryType === 'CountDistinct')) {
                    dataType('Integer');
                    model.condition() && model.condition().dataType(dataType());
                }
                else if (['Sum', 'Average', 'StdDev', 'StdDevp', 'Var', 'VarP'].indexOf(summaryType) !== -1) {
                    dataType('Decimal');
                    model.condition() && model.condition().dataType(dataType());
                }
                else {
                    dataType(field.fieldType());
                    model.condition() && model.condition().dataType(dataType());
                }
            });
        };
        let kpiElement = dashboardItem.cards().filter(card => card._getDataId() === model.cardId())[0];
        let deltaValueType = model.deltaValueType();
        if (deltaValueType === 'ActualValue') {
            fillDataTypes(kpiElement.actualValue());
        }
        else if (deltaValueType === 'TargetValue') {
            fillDataTypes(kpiElement.targetValue());
        }
        else {
            dataType('Decimal');
            model.condition() && model.condition().dataType(dataType());
        }
    };
    fillDataTypeForDelta();
    model.cardId.subscribe(containerId => {
        fillDataTypeForDelta();
    });
    model.deltaValueType.subscribe(deltaValueTypeId => {
        fillDataTypeForDelta();
    });
    return { dataType: dataType, dateTimeGroupInterval: ko.observable() };
}
export function createDataTypeObservable(formatRule, dashboardItem, dataSourceBrowser) {
    const dataItemCalculateBy = dashboardItem.dataItems().filter(d => formatRule.dataItemName() === d.uniqueName())[0];
    const dateTimeGroupInterval = ko.observable(dataItemCalculateBy instanceof Dimension ? dataItemCalculateBy.dateTimeGroupInterval() : undefined);
    const dataType = ko.observable(formatRule.condition() && formatRule.condition().dataType());
    let fillDataType = uniqueName => dashboardItem
        .dataItems()
        .filter(dataItem => uniqueName === dataItem.uniqueName() && !!dataItem.dataMember())
        .map(dataItem => ({
        dataItem: dataItem,
        fieldPromise: dataSourceBrowser.findDataField(dashboardItem.dataSource(), dashboardItem.dataMember(), dataItem.dataMember())
    }))
        .forEach(d => d.fieldPromise.done(field => {
        let newDataType = field.fieldType();
        if (d.dataItem instanceof Dimension) {
            newDataType = getRealDimensionType(d.dataItem, field);
            dateTimeGroupInterval(field.fieldType() === 'DateTime' ? d.dataItem.dateTimeGroupInterval() : undefined);
            formatRule.condition() && formatRule.condition().dateTimeGroupInterval(dateTimeGroupInterval());
        }
        if (d.dataItem instanceof Measure) {
            let summaryType = d.dataItem.summaryType();
            if ((summaryType === 'Count') || (summaryType === 'CountDistinct')) {
                newDataType = 'Integer';
            }
            else if (['Sum', 'Average', 'StdDev', 'StdDevp', 'let', 'letp'].indexOf(summaryType) !== -1) {
                newDataType = 'Decimal';
            }
        }
        dataType(newDataType);
        formatRule.condition() && formatRule.condition().dataType(dataType());
    }));
    if (!dataType() && formatRule.dataItemName())
        fillDataType(formatRule.dataItemName());
    formatRule.dataItemName.subscribe(fillDataType);
    return { dataType: dataType, dateTimeGroupInterval: dateTimeGroupInterval };
}
export function addConditionEditor(wrapper, dataTypeInfo, formatRuleModel, dashboardItem, requestRecalculation, specificTypeChanged, conditionTypeFilter) {
    const originalConditionType = formatRuleModel._classId;
    const conditionType = ko.observable(formatRuleModel._classId).extend({ notify: 'always' });
    const specificType = ko.observable(formatRuleModel.condition() && formatRuleModel.condition().getSpecificType());
    wrapper.addProperty(ko.observable(), {
        propertyName: 'typeChooser',
        displayName: 'DashboardWebStringId.ConditionType',
        formAdapterItem: conditionTypeEditor({ dataType: dataTypeInfo.dataType, conditionType, specificType, filters: conditionTypeFilter })
    });
    specificType.subscribe((newSpecificType) => {
        let condition = formatRuleModel.condition(), newRule = !condition, changedConditionType = originalConditionType !== conditionType(), realConditionType = conditionType().split('_')[0];
        if (newRule || changedConditionType) {
            formatRuleModel._changeConditionType(realConditionType);
            condition = formatRuleModel.condition();
            condition.dataType(dataTypeInfo.dataType());
            condition.dateTimeGroupInterval(dataTypeInfo.dateTimeGroupInterval());
        }
        condition.setSpecificType(newSpecificType);
        if (newRule) {
            formatRuleModel.name(NameGenerator.generateName(getLocalizationById('DashboardWebStringId.FormatRule') + ' ', dashboardItem.formatRules(), 'name', 1));
        }
        if (newRule || changedConditionType) {
            requestRecalculation.fire();
        }
        specificTypeChanged();
    });
}
export function getCommonCellsFormatRuleProperties(formatRule, getDataItems, getApplyToDataItems) {
    const dataItems = ko.pureComputed(() => getDataItems().map((m) => ({ value: ko.unwrap(m.uniqueName), displayValueId: ko.unwrap(m.displayName) })));
    const applyToDataItems = ko.pureComputed(() => getApplyToDataItems().map((m) => ({ value: ko.unwrap(m.uniqueName), displayValueId: ko.unwrap(m.displayName) })));
    if (!formatRule.dataItemName() && dataItems().length) {
        formatRule.dataItemName(ko.unwrap(dataItems()[0].value));
    }
    const externalUpdateCallback = formUpdateHandler => safeSubscribe({
        dataItemName: formatRule.dataItemApplyToName,
        applyToDataItems
    }, () => formUpdateHandler({ forceValidate: true }));
    const getApplyToPlaceHolder = () => {
        const dataItemApplyToInfo = applyToDataItems().filter(item => item.value === formatRule.dataItemApplyToName())[0];
        return dataItemApplyToInfo && dataItemApplyToInfo.displayValueId;
    };
    const commonProperties = [];
    commonProperties.push(Object.assign(Object.assign({}, formatRuleDataItem), { formAdapterItem: dynamicSelectBoxEditor({ values: dataItems }) }));
    commonProperties.push(Object.assign(Object.assign({}, dataItemApplyTo), { externalUpdateCallback, formAdapterItem: dynamicSelectBoxEditor({
            values: applyToDataItems,
            additionalOptions: () => ({
                placeholder: getApplyToPlaceHolder()
            }),
            comparableEditorOptions: ['placeholder']
        }), validationRules: [{
                type: 'custom',
                message: getLocalizationById('DashboardWebStringId.ConditionalFormatting.InvalidApplyToValue'),
                reevaluate: true,
                validationCallback: (e) => {
                    const applyToDataItemsNames = applyToDataItems().map(di => di.value);
                    return !e.value && applyToDataItemsNames.indexOf(formatRule.dataItemName()) !== -1
                        || !!e.value && applyToDataItemsNames.indexOf(e.value) !== -1;
                }
            }] }));
    return {
        properties: commonProperties
    };
}
