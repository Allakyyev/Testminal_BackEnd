/**
* DevExpress Dashboard (_pivot-item-format-rule-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../../../data/localization/_default';
import { FormatConditionAverage, FormatConditionRangeBase, FormatConditionTopBottom } from '../../../../model';
import { applyToRow, dataItemApplyTo } from '../../../../model/format-rules/metadata/_cells-item-format-rule';
import { applyToColumn, intersectionLevelMode, intersectionLevelModeValues, pivotLevel, restrictedIntersectionLevelModeValues } from '../../../../model/format-rules/metadata/_pivot-item-format-rule';
import { pivotLevelColumn, pivotLevelRow } from '../../../../model/format-rules/metadata/_pivot-item-format-rule-level';
import { transformValuesDictionary } from '../../../form-adapter/_form-adapter';
import { dynamicSelectBoxEditor } from '../../../form-adapter/_form-adapter-editors';
import { SectionDescriptors } from '../../../items/_section-descriptors';
import { getDataItemDisplayName } from '../../../_display-name-provider';
import { createDataTypeObservable, FormatRulePropertiesComposer, getCommonCellsFormatRuleProperties } from './_shared-format-rule-properties-composer';
export function createPivotItemFormatRulePropertiesComposer() {
    return new FormatRulePropertiesComposer({
        createDataTypeObservable: createDataTypeObservable,
        getCommonFormatRuleProperties: (formatRule, dashboardItem, dataSourceBrowser) => {
            let info = getCommonCellsFormatRuleProperties(formatRule, grabDataItems(dashboardItem, dataSourceBrowser), grapApplyToItems(dashboardItem, dataSourceBrowser));
            if (!info.disabledFilterRules)
                info.disabledFilterRules = {};
            info.disabledFilterRules[dataItemApplyTo.propertyName] = (m) => {
                let pivot = dashboardItem;
                return !(pivot.values().filter(v => v.uniqueName() === m.dataItemName()).length
                    || pivot.hiddenMeasures().filter(v => v.uniqueName() === m.dataItemName()).length);
            };
            return info;
        },
        getConditionFormatRuleProperties: () => ({ properties: [] }),
        getMiscFormatRuleProperties: getMiscFormatRuleProperties
    });
}
function getMiscFormatRuleProperties(formatRule, pivot, dataSourceBrowser) {
    let visibilityRules = {};
    let properties = [];
    let intersectionLevelModeValuesObservable = ko.observable(transformValuesDictionary(intersectionLevelModeValues));
    ko.computed(() => {
        if ((formatRule.condition() instanceof FormatConditionRangeBase && formatRule.condition().valueType() !== 'Number')
            || formatRule.condition() instanceof FormatConditionTopBottom
            || formatRule.condition() instanceof FormatConditionAverage) {
            intersectionLevelModeValuesObservable(transformValuesDictionary(restrictedIntersectionLevelModeValues));
        }
        else {
            intersectionLevelModeValuesObservable(transformValuesDictionary(intersectionLevelModeValues));
        }
    });
    properties.push(Object.assign(Object.assign({}, intersectionLevelMode), { formAdapterItem: dynamicSelectBoxEditor({ values: intersectionLevelModeValuesObservable }) }));
    properties.push({
        container: pivotLevel,
        properties: [
            Object.assign({ valuesArray: [{ value: null, displayValue: '[Grand Total]' }].concat(pivot.columns().map(m => ({ value: m.uniqueName(), displayValue: getDataItemDisplayName(dataSourceBrowser, pivot, m) }))) }, pivotLevelColumn),
            Object.assign({ valuesArray: [{ value: null, displayValue: '[Grand Total]' }].concat(pivot.rows().map(m => ({ value: m.uniqueName(), displayValue: getDataItemDisplayName(dataSourceBrowser, pivot, m) }))) }, pivotLevelRow)
        ]
    });
    properties.push(applyToColumn);
    properties.push(applyToRow);
    let isMeasure = !!pivot.values().filter(v => v.uniqueName() === formatRule.dataItemApplyToName()).length;
    visibilityRules[applyToRow.propertyName] = m => !formatRule.condition()._isApplyToRowColumnRestricted && isMeasure;
    visibilityRules[applyToColumn.propertyName] = m => !formatRule.condition()._isApplyToRowColumnRestricted && isMeasure;
    visibilityRules[pivotLevelColumn.propertyName] =
        [intersectionLevelMode.propertyName, '=', 'SpecificLevel'];
    visibilityRules[pivotLevelRow.propertyName] =
        [intersectionLevelMode.propertyName, '=', 'SpecificLevel'];
    return {
        properties: properties,
        visibilityFilterRules: visibilityRules
    };
}
function grabDataItems(dashboardItem, dataSourceBrowser) {
    return () => grapApplyToItems(dashboardItem, dataSourceBrowser)()
        .concat(dashboardItem
        .hiddenMeasures()
        .map(m => ({
        uniqueName: m.uniqueName(),
        displayName: getLocalizationById(SectionDescriptors.HiddenMeasures.title) + ' - ' + getDataItemDisplayName(dataSourceBrowser, dashboardItem, m)
    })));
}
function grapApplyToItems(pivot, dataSourceBrowser) {
    return () => pivot.values().map(m => ({
        uniqueName: m.uniqueName(),
        displayName: getLocalizationById(SectionDescriptors.Values.title) + ' - ' + getDataItemDisplayName(dataSourceBrowser, pivot, m)
    })).concat(pivot.columns().map(d => ({
        uniqueName: d.uniqueName(),
        displayName: getLocalizationById(SectionDescriptors.Columns.title) + ' - ' + getDataItemDisplayName(dataSourceBrowser, pivot, d)
    }))).concat(pivot.rows().map(d => ({
        uniqueName: d.uniqueName(),
        displayName: getLocalizationById(SectionDescriptors.Rows.title) + ' - ' + getDataItemDisplayName(dataSourceBrowser, pivot, d)
    })));
}
