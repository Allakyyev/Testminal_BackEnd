/**
* DevExpress Dashboard (_chart-item-format-rule-properties-composer.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { FormatConditionRangeGradientPredefinedType, FormatConditionRangeSetPredefinedType } from '../../../../model';
import { FormatConditionRangeBase } from '../../../../model/format-rules/conditions/range/format-condition-range-base';
import { applyToChartElement, dataItemApplyToName } from '../../../../model/format-rules/metadata/_chart-item-format-rule';
import { dataItemName, displayName, showInLegend } from '../../../../model/format-rules/metadata/_chart-item-format-rule-base';
import { getChartApplyToDataItems, getChartCFSeries } from '../../../../model/internal/_chart-utils';
import { RangeSeries, SimpleSeries } from '../../../../model/items/chart/chart-series';
import { dynamicSelectBoxEditor } from '../../../form-adapter/_form-adapter-editors';
import { ObjectPropertiesWrapper } from '../../../form-adapter/_object-properties-wrapper';
import { AccordionTab, KnownTabs } from '../../../properties-controller/_accordion-tab';
import { getDataItemDisplayName } from '../../../_display-name-provider';
import { createDataTypeObservable, FormatRulePropertiesComposer } from './_shared-format-rule-properties-composer';
export function createChartItemFormatRulePropertiesComposer() {
    const opts = {
        conditionTypeFilter: chartFormatRuleConditionFilters,
        createDataTypeObservable: createDataTypeObservable,
        getCommonFormatRuleProperties: (model, dashboardItem, dataSourceBrowser, ruleAdded) => getCommonChartFormatRuleProperties(model, getDataItems(dashboardItem, dataSourceBrowser), getChartApplyToDataItems(dashboardItem, dataSourceBrowser)),
        getConditionFormatRuleProperties: (model, dashboardItem, dataSourceBrowser) => ({
            properties: [applyToChartElement],
            visibilityFilterRules: {
                [applyToChartElement.propertyName]: _ => canChangeApplyToElement(dashboardItem, model)
            }
        }),
        getMiscFormatRuleProperties: () => ({ properties: [] }),
        getAdditionalTabs: (formatRule) => getChartFormatRuleLegendSettingsTab(formatRule),
    };
    return new FormatRulePropertiesComposer(opts);
}
function getCommonChartFormatRuleProperties(formatRule, getDataItems, getApplyToDataItems) {
    const dataItems = ko.pureComputed(() => getDataItems().map((m) => ({ value: ko.unwrap(m.uniqueName), displayValueId: ko.unwrap(m.displayName) })));
    const applyToDataItems = ko.pureComputed(() => getApplyToDataItems().map((m) => ({ value: ko.unwrap(m.uniqueName), displayValueId: ko.unwrap(m.displayName) })));
    if (!formatRule.dataItemName() && dataItems().length) {
        formatRule.dataItemName(ko.unwrap(dataItems()[0].value));
    }
    const applyToDataItemsNames = applyToDataItems().map(di => ko.unwrap(di.value));
    if (!formatRule.dataItemApplyToName() && applyToDataItemsNames.length) {
        formatRule.dataItemApplyToName(applyToDataItemsNames[0]);
    }
    const commonProperties = [];
    commonProperties.push(Object.assign(Object.assign({}, dataItemName), { formAdapterItem: dynamicSelectBoxEditor({ values: dataItems }) }));
    commonProperties.push(Object.assign(Object.assign({}, dataItemApplyToName), { formAdapterItem: dynamicSelectBoxEditor({ values: applyToDataItems }) }));
    return {
        properties: commonProperties
    };
}
function getDataItems(dashboardItem, dataSourceBrowser) {
    return () => []
        .concat(...getChartCFSeries(dashboardItem).map(s => s._measures), dashboardItem.arguments(), dashboardItem.seriesDimensions(), dashboardItem.hiddenMeasures())
        .map(dataItem => ({
        uniqueName: dataItem.uniqueName(),
        displayName: getDataItemDisplayName(dataSourceBrowser, dashboardItem, dataItem)
    }));
}
function canChangeApplyToElement(chartItem, formatRule) {
    const unsupportedSimpleSeriesTypes = ['Bar', 'StackedBar', 'FullStackedBar', 'Point'];
    const unsupportedRangeSeriesTypes = ['SideBySideRangeBar'];
    const selectedSeries = chartItem
        .panes()
        .reduce((seriesCollection, pane) => [...seriesCollection, ...pane.series()], [])
        .filter(series => series._measures.some(measure => measure.uniqueName() === formatRule.dataItemApplyToName()))[0];
    return (selectedSeries instanceof SimpleSeries && unsupportedSimpleSeriesTypes.indexOf(selectedSeries.seriesType()) === -1)
        || (selectedSeries instanceof RangeSeries && unsupportedRangeSeriesTypes.indexOf(selectedSeries.seriesType()) === -1);
}
export const chartFormatRuleConditionFilters = {
    conditionTypeFilter: (name, subType) => {
        const disabledTypes = [{
                name: 'conditionBar'
            }, {
                name: 'conditionColorRangeBar'
            }, {
                name: 'conditionGradientRangeBar'
            }, {
                name: 'conditionRangeSet',
                subType: 'icons'
            }];
        return disabledTypes.filter(item => item.name === name && (!item.subType || item.subType === subType)).length === 0;
    },
    rangeGradientPredefinedTypeFilter: (type) => {
        var validTypes = [
            FormatConditionRangeGradientPredefinedType.YellowGreen,
            FormatConditionRangeGradientPredefinedType.GreenYellow,
            FormatConditionRangeGradientPredefinedType.YellowRed,
            FormatConditionRangeGradientPredefinedType.RedYellow,
            FormatConditionRangeGradientPredefinedType.BlueRed,
            FormatConditionRangeGradientPredefinedType.RedBlue,
            FormatConditionRangeGradientPredefinedType.YellowBlue,
            FormatConditionRangeGradientPredefinedType.BlueYellow,
            FormatConditionRangeGradientPredefinedType.GreenBlue,
            FormatConditionRangeGradientPredefinedType.BlueGreen,
            FormatConditionRangeGradientPredefinedType.GreenYellowRed,
            FormatConditionRangeGradientPredefinedType.RedYellowGreen,
            FormatConditionRangeGradientPredefinedType.BlueYellowRed,
            FormatConditionRangeGradientPredefinedType.RedYellowBlue,
            FormatConditionRangeGradientPredefinedType.GreenYellowBlue,
            FormatConditionRangeGradientPredefinedType.BlueYellowGreen
        ];
        return validTypes.indexOf(type) !== -1;
    },
    rangeSetPredefinedTypeFilter: (type) => {
        var validTypes = [
            FormatConditionRangeSetPredefinedType.ColorsRedGreen,
            FormatConditionRangeSetPredefinedType.ColorsRedGreenBlue,
            FormatConditionRangeSetPredefinedType.ColorsRedYellowGreenBlue,
            FormatConditionRangeSetPredefinedType.ColorsRedOrangeYellowGreenBlue
        ];
        return validTypes.indexOf(type) !== -1;
    }
};
export function getChartFormatRuleLegendSettingsTab(formatRule) {
    const tab = new AccordionTab(KnownTabs.FormatRuleChartLegend, 'DashboardWebStringId.AccordionTab.ChartLegend');
    const wrapper = new ObjectPropertiesWrapper({
        model: formatRule,
        properties: [displayName, showInLegend],
        disabledFilterRules: {
            [showInLegend.propertyName]: _ => !(formatRule.displayName() || formatRule.condition() instanceof FormatConditionRangeBase)
        },
        visibilityFilterRules: {
            [displayName.propertyName]: _ => !(formatRule.condition() instanceof FormatConditionRangeBase)
        }
    });
    tab.tabModel(wrapper);
    return [tab];
}
