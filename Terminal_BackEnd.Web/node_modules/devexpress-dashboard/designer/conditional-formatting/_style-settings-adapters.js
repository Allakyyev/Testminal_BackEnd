/**
* DevExpress Dashboard (_style-settings-adapters.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { getLocalizationById } from '../../data/localization/_default';
import { Color } from '../../model/color';
import { AppearanceSettings } from '../../model/format-rules/style-settings/appearance-settings';
import { BarStyleSettings } from '../../model/format-rules/style-settings/bar-style-settings';
import { ColorStyleSettings } from '../../model/format-rules/style-settings/color-style-settings';
import { IconSettings } from '../../model/format-rules/style-settings/icon-settings';
import { appearanceType, fontFamily, fontStyle } from '../../model/format-rules/style-settings/metadata/_appearance-settings';
import { iconType } from '../../model/format-rules/style-settings/metadata/_icon-settings';
import { emptyStyleType } from '../../model/format-rules/style-settings/metadata/_style-settings-base';
import { appearanceSettingsProvider } from '../../viewer-parts/conditional-formatting/_appearance-settings-provider';
import { styleSettingsProvider } from '../../viewer-parts/conditional-formatting/_style-settings-provider';
import { convertCssPropertyWrappersToObject } from '../../viewer-parts/viewer/_cssHelper';
import { Palette } from './_style-settings-palette';
const colorStyleSettingsAdapter = {
    getCssStyles: (item) => {
        const predefinedColor = item.predefinedColor();
        if (predefinedColor === 'Custom' || predefinedColor === emptyStyleType) {
            return { 'background-color': item.color() && item.color().css };
        }
        return convertCssPropertyWrappersToObject(appearanceSettingsProvider.toCssProperties(predefinedColor));
    },
    getCssClasses: (item, isEmptyAllowed, isRange) => {
        const isEmpty = isEmptyAllowed && item.predefinedColor() === emptyStyleType;
        const restrictToColor = true;
        const isGradient = false;
        const isLabel = colorStyleSettingsAdapter.isEmptyCustomStyle(item) || (colorStyleSettingsAdapter.getLabelText(item, isRange, isGradient, restrictToColor) !== '');
        const isTransparent = item.predefinedColor() === 'GradientTransparent';
        return [
            isEmpty ? 'dx-dashboard-appearance-item-empty' : '',
            isLabel ? 'dx-dashboard-appearance-item-label' : '',
            isRange ? 'dx-dashboard-range-appearance-item' : 'dx-dashboard-appearance-item',
            isTransparent && !isRange ? 'dx-dashboard-appearance-item-label dx-dashboard-appearance-item-transparent' : ''
        ];
    },
    getLocalizedCaption: (item) => getLocalizationById(appearanceType.values[item.predefinedColor()]),
    getLabelText: (item, isRange, isGradient) => {
        const labelText = Palette.getLabelText(item.predefinedColor(), isGradient ? getLocalizationById('DashboardWebStringId.EditorAutomaticValue') : getLocalizationById('DashboardWebStringId.FormatConditionRangeSetNoStyleCaption'));
        return (!isRange || isRange && item.predefinedColor() !== emptyStyleType) ? labelText : '';
    },
    getPredefinedStyle: (item) => item.predefinedColor(),
    setPredefinedStyle: (item, style) => item.predefinedColor(style),
    hasCustomStyle: (item) => item.predefinedColor() === 'Custom',
    isEmptyCustomStyle: (item) => colorStyleSettingsAdapter.hasCustomStyle(item) && !item.color(),
    getCustomColor: (item) => item.color() && item.color().css,
    getCustomAppearance: (item) => null,
    setCustomColor: (item, style) => item.color(style && Color.fromRgbaString(style)),
    setCustomAppearance: () => { },
};
const iconStyleSettingsAdapter = {
    getCssStyles: () => ({}),
    getCssClasses: (item, isEmptyAllowed, isRange) => {
        if (isEmptyAllowed && item.iconType() === emptyStyleType) {
            return [
                'dx-dashboard-appearance-item',
                'dx-dashboard-appearance-item-label',
                'dx-dashboard-appearance-item-empty'
            ];
        }
        return [
            isRange ? 'dx-dashboard-rangeicon' : 'dx-dashboard-icon-item',
            styleSettingsProvider.toIconCssClass(item.iconType())
        ];
    },
    getLocalizedCaption: (item) => getLocalizationById(iconType.values[item.iconType()]),
    getLabelText: (item, isRange, isGradient) => {
        const labelText = Palette.getLabelText(item.iconType(), isGradient ? getLocalizationById('DashboardWebStringId.EditorAutomaticValue') : getLocalizationById('DashboardWebStringId.FormatConditionRangeSetNoStyleCaption'));
        return (!isRange || isRange && item.iconType() !== emptyStyleType) ? labelText : '';
    },
    getPredefinedStyle: (item) => item.iconType(),
    setPredefinedStyle: (item, style) => item.iconType(style),
    hasCustomStyle: () => false,
    isEmptyCustomStyle: () => false,
    getCustomColor: () => null,
    getCustomAppearance: () => null,
    setCustomColor: () => { },
    setCustomAppearance: () => { },
};
export const appearanceStyleSettingsAdapter = {
    getCssStyles: (item) => {
        if (item.appearanceType() !== emptyStyleType && !appearanceStyleSettingsAdapter.hasCustomStyle(item)) {
            return convertCssPropertyWrappersToObject(appearanceSettingsProvider.toCssProperties(item.appearanceType()));
        }
        const customCss = convertCssPropertyWrappersToObject(appearanceSettingsProvider.toCustomCssProperties(item));
        return customCss;
    },
    getCssClasses: (item, isEmptyAllowed, isRange, isGradient = false, restrictToColor = false) => {
        const _isEmptyAppearanceItem = () => isEmptyAllowed && item.appearanceType() === emptyStyleType;
        const _isTransparent = () => item.appearanceType() === 'GradientTransparent';
        const _isLabel = () => (item.appearanceType() === 'GradientTransparent')
            || (appearanceStyleSettingsAdapter.getLabelText(item, isRange, isGradient, restrictToColor) !== '' && !Palette.richColors.includes(item.appearanceType()))
            || (appearanceStyleSettingsAdapter.isEmptyCustomStyle(item));
        return [
            isRange ? 'dx-dashboard-range-appearance-item' : 'dx-dashboard-appearance-item',
            _isEmptyAppearanceItem() ? 'dx-dashboard-appearance-item-empty' : '',
            _isLabel() ? 'dx-dashboard-appearance-item-label' : '',
            _isTransparent() && !isRange ? 'dx-dashboard-appearance-item-transparent' : ''
        ];
    },
    getLocalizedCaption: (item) => getLocalizationById(appearanceType.values[item.appearanceType()]),
    getLabelText: (item, isRange, isGradient, restrictToColor) => {
        const customAppearance = appearanceStyleSettingsAdapter.getCustomAppearance(item);
        if (customAppearance && !isGradient) {
            return Palette.getCustomLabelText(customAppearance);
        }
        const labelText = Palette.getLabelText(item.appearanceType(), isGradient ? getLocalizationById('DashboardWebStringId.EditorAutomaticValue') : getLocalizationById('DashboardWebStringId.FormatConditionRangeSetNoStyleCaption'));
        return (!restrictToColor && (!isRange || isRange && item.appearanceType() !== emptyStyleType)
            || (restrictToColor && !isRange && item.appearanceType() === emptyStyleType)) ? labelText : '';
    },
    getPredefinedStyle: (item) => item.appearanceType(),
    setPredefinedStyle: (item, style) => item.appearanceType(style),
    hasCustomStyle: (item) => item.appearanceType() === 'Custom',
    isEmptyCustomStyle: (item) => {
        return appearanceStyleSettingsAdapter.hasCustomStyle(item)
            && !item.foreColor() && !item.backColor()
            && item.fontStyle() === fontStyle.defaultVal
            && item.fontFamily() === fontFamily.defaultVal;
    },
    getCustomColor: (item) => item.backColor() && item.backColor().css,
    getCustomAppearance: (item) => {
        var _a, _b;
        return !appearanceStyleSettingsAdapter.hasCustomStyle(item) || appearanceStyleSettingsAdapter.isEmptyCustomStyle(item) ? null : ({
            fontFamily: item.fontFamily(),
            fontStyle: item.fontStyle(),
            backColor: (_a = item.backColor()) === null || _a === void 0 ? void 0 : _a.css,
            foreColor: (_b = item.foreColor()) === null || _b === void 0 ? void 0 : _b.css
        });
    },
    setCustomColor: (item, style) => item.backColor(style && Color.fromRgbaString(style)),
    setCustomAppearance: (item, style) => {
        item.fontFamily(style && style.fontFamily);
        item.fontStyle(style ? style.fontStyle : null);
        item.backColor(style && style.backColor && Color.fromRgbaString(style.backColor));
        item.foreColor(style && style.foreColor && Color.fromRgbaString(style.foreColor));
    },
};
export function styleSettingsAdapter(item, itemType) {
    let adapter;
    switch (itemType || item.constructor) {
        case AppearanceSettings:
            itemType = AppearanceSettings;
            adapter = appearanceStyleSettingsAdapter;
            break;
        case IconSettings:
            itemType = IconSettings;
            adapter = iconStyleSettingsAdapter;
            break;
        case BarStyleSettings:
            itemType = BarStyleSettings;
            adapter = colorStyleSettingsAdapter;
            break;
        case ColorStyleSettings:
            itemType = ColorStyleSettings;
            adapter = colorStyleSettingsAdapter;
            break;
        default:
            throw new Error('Unknown StyleSettings type');
    }
    return {
        itemFactory: () => new itemType(),
        getCssStyles: () => adapter.getCssStyles(item),
        getCssClasses: (isEmptyAllowed, isRange, isGradient) => adapter.getCssClasses(item, isEmptyAllowed, isRange, isGradient),
        getLocalizedCaption: () => adapter.getLocalizedCaption(item),
        getLabelText: (isRange, isGradient, restrictToColor) => adapter.getLabelText(item, isRange, isGradient, restrictToColor),
        getPredefinedStyle: () => adapter.getPredefinedStyle(item),
        setPredefinedStyle: (style) => adapter.setPredefinedStyle(item, style),
        hasCustomStyle: () => adapter.hasCustomStyle(item),
        isEmptyCustomStyle: () => adapter.isEmptyCustomStyle(item),
        getCustomColor: () => adapter.getCustomColor(item),
        getCustomAppearance: () => adapter.getCustomAppearance(item),
        setCustomColor: (style) => adapter.setCustomColor(item, style),
        setCustomAppearance: (style) => adapter.setCustomAppearance(item, style),
    };
}
