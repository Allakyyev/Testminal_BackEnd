/**
* DevExpress Dashboard (_style-settings-editor.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { AppearanceSettings } from '../../model/format-rules/style-settings/appearance-settings';
import { IconSettings } from '../../model/format-rules/style-settings/icon-settings';
import { iconType } from '../../model/format-rules/style-settings/metadata/_icon-settings';
import { emptyStyleType } from '../../model/format-rules/style-settings/metadata/_style-settings-base';
import { conditionalFormattingEditor } from './custom-style-settings/_conditional-formatting-custom-color-storage';
import { styleSettingsAdapter } from './_style-settings-adapters';
import { Palette } from './_style-settings-palette';
export class StyleSettingsEditor {
    constructor(target, params) {
        this.customColorsSupported = false;
        this.allowChangeViewMode = false;
        this.isGradient = false;
        this.isEmptyAllowed = false;
        this.restrictToColor = false;
        this.numberOfCustomStyleItems = 8;
        this.value = target;
        this.isEmptyAllowed = params.isEmptyAllowed;
        this.isGradient = params.appearanceMode === 'GradientColors';
        this.allowChangeViewMode = (this.value() instanceof AppearanceSettings || this.value() instanceof IconSettings) && params.allowChangeViewMode;
        this.viewMode = ko.observable(this.value() instanceof IconSettings ? 'Icon' : 'Appearance');
        this.getAvailableFontFamilies = params.getAvailableFontFamilies;
        this.customColorsSupported = params.enableCustomStyles;
        if (params.restrictToColor)
            this.restrictToColor = params.restrictToColor;
        this.selectedChanged = params.selectedChanged;
        this.closeEditCell = params.closeEditCell || (() => { });
        const { predefinedStyles, predefinedIcons, customStyles } = this._createDataSources(params.appearanceMode, this.isEmptyAllowed, this.customColorsSupported, this.restrictToColor, this.value, conditionalFormattingEditor);
        this.list = predefinedStyles;
        this.iconList = predefinedIcons;
        this.customStyleItems = customStyles;
    }
    _setStyleType(styleSettingsModel, saveCustomStyle) {
        const oldSelectedStyle = this.value();
        if (this.value() !== styleSettingsModel) {
            this.value(styleSettingsModel);
        }
        if (this.selectedChanged) {
            this.selectedChanged(oldSelectedStyle, styleSettingsModel);
        }
        this.closeEditCell();
        switch (saveCustomStyle) {
            case 'SaveColor':
                const customColors = this.customStyleItems
                    .map(viewModel => viewModel.item)
                    .filter(model => !!model)
                    .map(model => styleSettingsAdapter(model).getCustomColor());
                conditionalFormattingEditor.customColorStorage.setValue(customColors);
                break;
            case 'SaveAppearance':
                const customAppearances = this.customStyleItems
                    .map(viewModel => viewModel.item)
                    .filter(model => !!model)
                    .map(model => styleSettingsAdapter(model).getCustomAppearance());
                conditionalFormattingEditor.customAppearanceStorage.setValue(customAppearances);
                break;
            case 'None':
            default:
                break;
        }
    }
    _createDataSources(mode, isEmptyAllowed, isCustomStyleEnabled, isCustomColorsOnly, selectedValue, customStylesProvider) {
        let predefinedAppearanceItems = [];
        let predefinedIconItems = [];
        let customStyleItems = null;
        let specificCustomItemType = undefined;
        switch (mode) {
            case 'Appearance':
                predefinedAppearanceItems = Palette.standard;
                predefinedIconItems = Object.keys(iconType.values).slice(1);
                specificCustomItemType = AppearanceSettings;
                break;
            case 'AllColors':
                predefinedAppearanceItems = Palette.allColors;
                break;
            case 'RichColors':
                predefinedAppearanceItems = Palette.richColors;
                break;
            case 'GradientColors':
                predefinedAppearanceItems = Palette.gradient;
                break;
        }
        if (isEmptyAllowed) {
            predefinedAppearanceItems = [emptyStyleType].concat(predefinedAppearanceItems);
            predefinedIconItems = predefinedIconItems.length ? [emptyStyleType].concat(predefinedIconItems) : [];
        }
        if (isCustomStyleEnabled) {
            const selectedItemAdapter = styleSettingsAdapter(selectedValue());
            if (isCustomColorsOnly) {
                customStyleItems = this._getCustomColorStyles(customStylesProvider.customColorStorage, selectedItemAdapter.hasCustomStyle() && selectedItemAdapter.getCustomColor())
                    .map(this.createItemViewModel(this.createCustomColorStyleSettingsModel(selectedValue(), specificCustomItemType), selectedValue));
            }
            else {
                customStyleItems = this._getCustomAppearanceStyles(customStylesProvider.customAppearanceStorage, selectedItemAdapter.hasCustomStyle() && selectedItemAdapter.getCustomAppearance())
                    .map(this.createItemViewModel(this.createCustomAppearanceStyleSettingsModel(selectedValue(), specificCustomItemType), selectedValue));
            }
        }
        return {
            predefinedStyles: predefinedAppearanceItems.map(this.createItemViewModel(this.createStyleSettingsModel(selectedValue(), specificCustomItemType), selectedValue)),
            predefinedIcons: predefinedIconItems.map(this.createItemViewModel(this.createStyleSettingsModel(selectedValue(), IconSettings), selectedValue)),
            customStyles: customStyleItems
        };
    }
    _getCustomColorStyles(storage, selectedStyle) {
        const styles = this._getStyles(storage);
        const colorFound = styles.indexOf(selectedStyle) > -1;
        return this._getCustomStyles(storage, styles, selectedStyle, colorFound);
    }
    _getCustomAppearanceStyles(storage, selectedStyle) {
        const styles = this._getStyles(storage);
        const appearanceFound = styles.some(style => {
            if (!style)
                return false;
            return Object.keys(style).every(key => style[key] === selectedStyle[key]);
        });
        return this._getCustomStyles(storage, styles, selectedStyle, appearanceFound);
    }
    _getStyles(storage) {
        const savedStyles = (storage && storage.getValue() || []);
        return savedStyles.concat(Array.apply(null, Array(Math.max(this.numberOfCustomStyleItems - savedStyles.length, 0))));
    }
    _getCustomStyles(storage, styles, selectedStyle, styleExists) {
        if (!!selectedStyle && !styleExists) {
            let i = 0;
            for (; i < styles.length; i++) {
                if (!styles[i]) {
                    styles[i] = selectedStyle;
                    storage.setValue(styles);
                    break;
                }
            }
            if (styles.length === i) {
                styles[styles.length - 1] = selectedStyle;
            }
        }
        return styles;
    }
    createStyleSettingsModel(selectedValue, stylesModelType) {
        return (item) => {
            const model = styleSettingsAdapter(selectedValue, stylesModelType).itemFactory();
            styleSettingsAdapter(model).setPredefinedStyle(item);
            return model;
        };
    }
    createCustomColorStyleSettingsModel(selectedValue, stylesModelType) {
        return (color) => {
            const model = this.createStyleSettingsModel(selectedValue, stylesModelType)('Custom');
            color && styleSettingsAdapter(model).setCustomColor(color);
            return model;
        };
    }
    createCustomAppearanceStyleSettingsModel(selectedValue, stylesModelType) {
        return (appearance) => {
            const model = this.createStyleSettingsModel(selectedValue, stylesModelType)('Custom');
            appearance && styleSettingsAdapter(model).setCustomAppearance(appearance);
            return model;
        };
    }
    createItemViewModel(modelFactory, selectedValue) {
        return (item) => {
            const itemModel = modelFactory(item);
            return {
                item: itemModel,
                clickHandler: (saveCustomStyle) => this._setStyleType(itemModel, saveCustomStyle),
                isSelected: ko.computed(() => !!itemModel.equals(selectedValue())),
                isEmptyAllowed: this.isEmptyAllowed,
                isRange: false,
                isGradient: this.isGradient,
                restrictToColor: this.restrictToColor,
                getAvailableFontFamilies: this.getAvailableFontFamilies
            };
        };
    }
}
ko.components.register('dx-dashboard-style-settings-editor', {
    viewModel: {
        createViewModel: (params) => {
            return new StyleSettingsEditor(ko.unwrap(params).target, ko.unwrap(params).options);
        }
    },
    template: { element: 'dx-dashboard-style-settings-editor' }
});
