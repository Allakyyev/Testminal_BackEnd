/**
* DevExpress Dashboard (_format-helper.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import dxConfig from 'devextreme/core/config';
import dateUtils from 'devextreme/core/utils/date';
import { format as stringFormat } from 'devextreme/core/utils/string';
import formatHelper from 'devextreme/format_helper';
import dateLocalization from 'devextreme/localization/date';
import numberLocalization from 'devextreme/localization/number';
import { type } from '../data/_utils';
import { DashboardPrivateSettings } from '../viewer-parts/legacy-settings';
import { getLocalizationById } from './localization/_default';
import { extend, isPlainObject } from './_jquery-helpers';
export let invariantCurrencyIdentifier = 'INVARIANT';
export let invariantCurrencySymbol = '¤';
export class DashboardFormatHelper {
    static defaultQuarterFormat() { return getLocalizationById('DashboardStringId.DateTimeQuarterFormat'); }
    static format(value, format) {
        if (isPlainObject(format) && format.format) {
            if (format.dateType)
                return this._formatDateEx(value, format);
            else if (type.isNumeric(value) && isFinite(value))
                return this._formatNumberEx(value, format);
        }
        return formatHelper.format(value, format);
    }
    static _applyNumberFormat(value, formatConfig) {
        var numberStr = (+value).toString(10);
        if ((/e/).test(numberStr)) {
            console.warn('The number ' + numberStr + ' out of (1e21, 1e-7) range can`t be formatted. The number will be displayed as is.');
            return value.toString();
        }
        var invariantCurrency = formatConfig.currency === invariantCurrencyIdentifier;
        if (invariantCurrency) {
            formatConfig.currency = 'USD';
        }
        var formattedValue = numberLocalization.format(value, formatConfig);
        if (formattedValue != null && formatConfig.currency != 'default') {
            var currencySymbol = '';
            var symbolAltNarrow = '';
            try {
                let symbolInfo = numberLocalization.getCurrencySymbol(formatConfig.currency);
                currencySymbol = symbolInfo['symbol'];
                symbolAltNarrow = symbolInfo['symbol-alt-narrow'];
            }
            catch (_a) { }
            try {
                let symbolInfo = numberLocalization._getCurrencySymbolInfo(formatConfig.currency);
                currencySymbol = symbolInfo.symbol;
                symbolAltNarrow = symbolInfo.symbol;
            }
            catch (_b) { }
            if (invariantCurrency) {
                symbolAltNarrow = invariantCurrencySymbol;
                formatConfig.currency = invariantCurrencyIdentifier;
            }
            if (!!symbolAltNarrow && symbolAltNarrow !== currencySymbol) {
                return formattedValue.replace(currencySymbol, symbolAltNarrow);
            }
        }
        return formattedValue;
    }
    static _getQuarterString(date, format) {
        var quarter = dateUtils.getQuarter(date.getMonth());
        switch (format) {
            case 'q':
                return this.romanDigits[quarter];
            case 'qq':
                return stringFormat(this.defaultQuarterFormat(), this.romanDigits[quarter]);
            case 'Q':
                return (quarter + 1).toString();
            case 'QQ':
                return stringFormat(this.defaultQuarterFormat(), (quarter + 1).toString());
        }
        return '';
    }
    static _formatDateEx(value, formatInfo) {
        var that = this, format = formatInfo.format.toLowerCase(), dateType = formatInfo.dateType, time, index, dateStr;
        if (!type.isDefined(value)) {
            return '';
        }
        if (dateType !== 'num' || format === 'dayofweek') {
            switch (format) {
                case 'monthyear':
                    return dateLocalization.format(value, 'monthandyear');
                case 'quarteryear':
                    return that._getQuarterString(value, 'QQ') + ' ' + value.getFullYear();
                case 'daymonthyear':
                case 'weekyear':
                    return dateLocalization.format(value, dateType + 'Date');
                case 'datehour':
                    time = new Date(value.getTime());
                    time.setMinutes(0);
                    dateStr = dateType === 'timeOnly' ? '' : dateLocalization.format(value, dateType + 'Date');
                    return dateType === 'timeOnly' ? dateLocalization.format(time, 'shorttime') : dateStr + ' ' + dateLocalization.format(time, 'shorttime');
                case 'datehourminute':
                    dateStr = dateType === 'timeOnly' ? '' : dateLocalization.format(value, dateType + 'Date');
                    return dateType === 'timeOnly' ? dateLocalization.format(value, 'shorttime') : dateStr + ' ' + dateLocalization.format(value, 'shorttime');
                case 'datehourminutesecond':
                    dateStr = dateType === 'timeOnly' ? '' : dateLocalization.format(value, dateType + 'Date');
                    return dateType === 'timeOnly' ? dateLocalization.format(value, 'longtime') : dateStr + ' ' + dateLocalization.format(value, 'longtime');
                case 'year':
                    dateStr = value.toString();
                    return (dateType === 'abbr') ? dateStr.slice(2, 4) : dateStr;
                case 'dateyear':
                    return (dateType === 'abbr') ? dateLocalization.format(value, 'shortyear') : dateLocalization.format(value, 'year');
                case 'quarter':
                    return stringFormat(that.defaultQuarterFormat(), value.toString());
                case 'month':
                    index = value - 1;
                    return dateLocalization.getMonthNames(dateType === 'abbr' ? 'abbreviated' : undefined)[index];
                case 'hour':
                    if (dateType === 'long') {
                        time = new Date();
                        time.setHours(value);
                        time.setMinutes(0);
                        return dateLocalization.format(time, 'shorttime');
                    }
                    return value.toString();
                case 'dayofweek':
                    index = type.isString(value) ? ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'].indexOf(value) : value;
                    if (dateType !== 'num') {
                        return dateLocalization.getDayNames(dateType === 'abbr' ? 'abbreviated' : undefined)[index];
                    }
                    return ((index - dateLocalization.firstDayOfWeekIndex() + 1 + 7) % 8).toString();
                default:
                    return value.toString();
            }
        }
        else {
            return value.toString();
        }
    }
    static _getMinimalPossibleValue(formatType, precision) {
        var maxPrecision = precision + 1;
        if (formatType === 'percent') {
            maxPrecision += 2;
        }
        return Math.pow(10, -maxPrecision);
    }
    static _formatNumberEx(value, formatInfo) {
        var that = this, formatType = formatInfo.format.toLowerCase(), formatSettings = that._getUnitFormatSettings(value, formatInfo), result = '', config;
        if (!type.isDefined(value)) {
            return '';
        }
        if (['currency', 'percent', 'fixedpoint'].indexOf(formatType) !== -1
            && formatSettings.precision >= 0
            && Math.abs(value) < that._getMinimalPossibleValue(formatType, formatSettings.precision)) {
            value = 0;
        }
        value = that._getNumberByPower(value, formatSettings.unitPower, 1000);
        if (['fixedpoint', 'currency', 'percent'].indexOf(formatType) !== -1) {
            config = that._generateNumericFormatConfig(Object.assign(Object.assign({}, formatSettings), { significantDigits: formatInfo.significantDigits, signsAfterPointCount: that._countSignsAfterPoint(value, formatType), formatType: formatType }), value);
        }
        switch (formatType) {
            case 'general':
                if (value === 0) {
                    return '0';
                }
                else if (Math.abs(value) < 0.0001) {
                    return this._applyNumberFormat(value, { type: 'exponential', precision: 2, minimumSignificantDigits: 1, maximumSignificantDigits: 20 });
                }
                else {
                    return this._applyNumberFormat(value, { useGrouping: false, minimumSignificantDigits: 1, maximumSignificantDigits: 20 });
                }
            case 'decimal':
                result = this._applyNumberFormat(value, that._normalizeFormatConfig(formatType, formatSettings.precision, value));
                break;
            case 'fixedpoint':
                result = this._applyNumberFormat(value, config);
                break;
            case 'currency':
                config.currency = formatInfo.currency || dxConfig().defaultCurrency;
                result = this._applyNumberFormat(value, config);
                break;
            case 'percent':
                config.style = 'percent';
                result = this._applyNumberFormat(value, config);
                break;
            case 'exponential':
                return this._applyNumberFormat(value, { type: 'exponential', precision: formatSettings.precision });
            default:
                throw "Illegal numeric format: '" + formatType + "'";
        }
        result = that._insertUnitPostfix(result, formatSettings.unitPower);
        return (formatInfo.plus && value > 0 ? '+' : '') + result;
    }
    static _getUnitFormatSettings(value, formatInfo) {
        var unitPower = formatInfo.unitPower || 0, precision = formatInfo.precision || 0, includeGroupSeparator = formatInfo.includeGroupSeparator || false, showTrailingZeros = formatInfo.showTrailingZeros === undefined ? true : formatInfo.showTrailingZeros, significantDigits = formatInfo.significantDigits || 1, absValue;
        if (unitPower.toString().toLowerCase() === 'auto') {
            showTrailingZeros = false;
            absValue = Math.abs(value);
            if (significantDigits < 1)
                significantDigits = 1;
            if (absValue >= 1000000000) {
                unitPower = 3;
                absValue /= 1000000000;
            }
            else if (absValue >= 1000000) {
                unitPower = 2;
                absValue /= 1000000;
            }
            else if (absValue >= 1000) {
                unitPower = 1;
                absValue /= 1000;
            }
            else
                unitPower = 0;
            if (absValue === 0)
                precision = 0;
            else if (absValue < 1) {
                precision = significantDigits;
                var smallValue = Math.pow(10, -significantDigits);
                while (absValue < smallValue) {
                    smallValue /= 10;
                    precision++;
                }
            }
            else {
                if (absValue >= 100)
                    precision = significantDigits - 3;
                else if (absValue >= 10)
                    precision = significantDigits - 2;
                else
                    precision = significantDigits - 1;
            }
        }
        if (precision < 0) {
            precision = 0;
        }
        return {
            unitPower: unitPower,
            precision: precision,
            showTrailingZeros: showTrailingZeros,
            includeGroupSeparator: includeGroupSeparator
        };
    }
    static _insertUnitPostfix(formattedNumber, unitPower) {
        var lastDigitReg = /(\d)([^\d]*)$/;
        return unitPower > 0
            ? formattedNumber.replace(lastDigitReg, '$1' + getLocalizationById(this.defaultLargeNumberFormatPostfixes[unitPower]) + '$2')
            : formattedNumber;
    }
    static _generateNumericFormatConfig(settings, value) {
        var that = this, config;
        if (!settings.showTrailingZeros) {
            settings.precision = Math.min(settings.precision, settings.signsAfterPointCount);
        }
        config = that._normalizeFormatConfig(settings.formatType, settings.precision, value);
        config.useGrouping = settings.includeGroupSeparator;
        if (settings.significantDigits && value) {
            extend(config, {
                minimumSignificantDigits: settings.showTrailingZeros ? settings.significantDigits : 1,
                maximumSignificantDigits: settings.significantDigits
            });
        }
        return config;
    }
    static _countSignsAfterPoint(num, formatType) {
        var strNum = String(num), pointPos = strNum.indexOf('.');
        if (formatType == 'percent') {
            pointPos += 2;
        }
        if (pointPos < 0) {
            return 0;
        }
        return strNum.substr(pointPos + 1, strNum.length).length;
    }
    static _excludeTrailingZeros(strValue, floatingSymbol) {
        var floatingIndex = strValue.indexOf(floatingSymbol), stopIndex, i;
        if (floatingIndex < 0)
            return strValue;
        stopIndex = strValue.length;
        for (i = stopIndex - 1; i >= floatingIndex && (strValue[i] === '0' || i === floatingIndex); i--) {
            stopIndex--;
        }
        return strValue.substring(0, stopIndex);
    }
    static _normalizeFormatConfig(format, precision, value) {
        var config = numberLocalization._normalizeFormatConfig(format, {
            precision,
            useCurrencyAccountingStyle: DashboardPrivateSettings.useCurrencyAccountingStyle
        }, value);
        if (format === 'decimal') {
            config = Object.assign(Object.assign({}, config), {
                minimumIntegerDigits: precision || 1,
                useGrouping: false,
                maximumFractionDigits: 0,
                round: value < 0 ? 'ceil' : 'floor'
            });
        }
        else {
            config = Object.assign(Object.assign({}, config), {
                minimumFractionDigits: precision,
                maximumFractionDigits: precision
            });
        }
        return config;
    }
    static _getNumberByPower(number, power, base) {
        var result = number;
        while (power > 0) {
            result = result / base;
            power--;
        }
        while (power < 0) {
            result = result * base;
            power++;
        }
        return result;
    }
}
DashboardFormatHelper.defaultLargeNumberFormatPostfixes = {
    1: 'DashboardStringId.NumericFormatUnitSymbolThousands',
    2: 'DashboardStringId.NumericFormatUnitSymbolMillions',
    3: 'DashboardStringId.NumericFormatUnitSymbolBillions',
    4: 'T'
};
DashboardFormatHelper.romanDigits = ['I', 'II', 'III', 'IV'];
