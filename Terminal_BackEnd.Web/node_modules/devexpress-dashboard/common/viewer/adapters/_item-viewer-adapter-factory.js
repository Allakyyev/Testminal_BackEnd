/**
* DevExpress Dashboard (_item-viewer-adapter-factory.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { DisposableObject } from '../../../model/disposable-object';
import { DashboardItem } from '../../../model/items/dashboard-item';
import { DataDashboardItem } from '../../../model/items/data-dashboard-item';
import { DateFilterItem } from '../../../model/items/filter-items/date-filter-item';
import { GridItem } from '../../../model/items/grid/grid-item';
import { MapItem } from '../../../model/items/map/map-item';
import { PivotItem } from '../../../model/items/pivot/pivot-item';
import { RangeFilterItem } from '../../../model/items/range-filter/range-filter-item';
import { DataItemViewerAdapter } from './_data-item-viewer-adapter';
import { GridItemViewerAdapter } from './_grid-item-viewer-adapter';
import { ItemViewerAdapterBase } from './_item-viewer-adapter-base';
import { MapItemViewerAdapter } from './_map-item-viewer-adapter';
import { PivotItemViewerAdapter } from './_pivot-item-viewer-adapter';
import { PredefinedPeriodsItemViewerAdapter } from './_predefined-periods-item-viewer-adapter';
class ViewerItemAdapterRecordElement {
    constructor(adapter, visualMode) {
        if (adapter)
            this.setAdapter(adapter, visualMode);
    }
    setAdapter(adapter, visualMode) {
        if (this.storage && (this.storage instanceof ItemViewerAdapterBase || visualMode === 'full'))
            throw new Error('Try to replace a primary dashboard item with the new one');
        if (!visualMode || visualMode === 'full') {
            this.storage = adapter;
        }
        else {
            if (!this.storage)
                this.storage = {};
            if (visualMode === 'caption') {
                this.storage.captionItem = adapter;
            }
            else {
                this.storage.contentItem = adapter;
            }
        }
    }
    suspend() {
        this.processMapRecordElement((adapter) => adapter.suspend());
    }
    resume() {
        this.processMapRecordElement((adapter) => adapter.resume());
    }
    dispose() {
        this.processMapRecordElement((adapter) => adapter.dispose());
        this.storage = null;
    }
    processMapRecordElement(handler) {
        if (!this.storage)
            return;
        if (this.storage instanceof ItemViewerAdapterBase) {
            handler(this.storage);
        }
        else {
            this.storage.captionItem && handler(this.storage.captionItem);
            this.storage.contentItem && handler(this.storage.contentItem);
        }
    }
}
export class ViewerItemAdaptersManager extends DisposableObject {
    constructor() {
        super(...arguments);
        this.viewerItemAdaptersMap = {};
        this.modelSubscriberDict = [
            { type: RangeFilterItem, ctor: PredefinedPeriodsItemViewerAdapter },
            { type: DateFilterItem, ctor: PredefinedPeriodsItemViewerAdapter },
            { type: GridItem, ctor: GridItemViewerAdapter },
            { type: PivotItem, ctor: PivotItemViewerAdapter },
            { type: MapItem, ctor: MapItemViewerAdapter },
            { type: DataDashboardItem, ctor: DataItemViewerAdapter },
            { type: DashboardItem, ctor: ItemViewerAdapterBase }
        ];
        this.createAdapterCore = (dashboardItem, element, context, localContext, beforeRender = (item) => { }) => {
            var modelSubscriberCtor = null;
            for (var i = 0; i < this.modelSubscriberDict.length; i++) {
                if (dashboardItem instanceof this.modelSubscriberDict[i].type) {
                    modelSubscriberCtor = this.modelSubscriberDict[i].ctor;
                    break;
                }
            }
            if (!modelSubscriberCtor) {
                modelSubscriberCtor = this.modelSubscriberDict[this.modelSubscriberDict.length - 1].ctor;
            }
            return (new modelSubscriberCtor(dashboardItem, element, context, localContext, beforeRender, () => this.releaseAdapter(dashboardItem, localContext && localContext.itemCreatingType === 'secondary')));
        };
    }
    releaseAdapter(dashboardItem, isSecondaryAdapter) {
        if (!dashboardItem || !dashboardItem.componentName())
            return;
        let mapRecord = this.viewerItemAdaptersMap[dashboardItem.componentName()];
        if (mapRecord && isSecondaryAdapter) {
            if (mapRecord.secondary) {
                mapRecord.secondary = null;
                mapRecord.primary && mapRecord.primary.resume();
            }
        }
        else {
            delete this.viewerItemAdaptersMap[dashboardItem.componentName()];
        }
    }
    create(dashboardItem, element, context, localContext, beforeRender = (item) => { }) {
        let itemComponentName = dashboardItem.componentName();
        this.viewerItemAdaptersMap[itemComponentName] = this.viewerItemAdaptersMap[itemComponentName] || {};
        let visualMode = localContext && localContext.visualMode && localContext.visualMode() || 'full';
        let newAdapter = this.createAdapterCore(dashboardItem, element, context, localContext, beforeRender);
        let mapRecord = this.viewerItemAdaptersMap[itemComponentName];
        if (localContext && localContext.itemCreatingType === 'secondary') {
            if (visualMode !== 'full')
                throw new Error('Try to create a secondary dashboard item with non-full visual mode');
            mapRecord.primary && mapRecord.primary.suspend();
            mapRecord.secondary = new ViewerItemAdapterRecordElement(newAdapter, visualMode);
        }
        else {
            if (!mapRecord.primary) {
                mapRecord.primary = new ViewerItemAdapterRecordElement(newAdapter, visualMode);
            }
            else {
                visualMode === 'full' && mapRecord.primary.dispose && mapRecord.primary.dispose();
                mapRecord.primary.setAdapter(newAdapter, visualMode);
            }
        }
        return newAdapter;
    }
    dispose() {
        Object.keys(this.viewerItemAdaptersMap).forEach(componentName => {
            let mapRecord = this.viewerItemAdaptersMap[componentName];
            if (mapRecord) {
                mapRecord.primary && mapRecord.primary.dispose();
                mapRecord.secondary && mapRecord.secondary.dispose();
            }
            delete this.viewerItemAdaptersMap[componentName];
        });
        super.dispose();
    }
}
