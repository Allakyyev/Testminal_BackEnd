/**
* DevExpress Dashboard (remote-service.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as $ from 'jquery';
import { createJQueryDeferred, jqueryQueryParam } from '../data/_jquery-helpers';
import { type } from '../data/_utils';
function findGloballyDefinedMethod(...path) {
    return path.reduce((acc, item) => {
        if (acc)
            return acc[item];
        return undefined;
    }, window);
}
function _getFileName(contentDisposition) {
    const utf8FileNameRegex = /filename\*=UTF-8''(.*?)$/i;
    const fileNameRegex = /^attachment; filename=\"?(.*?)\"?$/;
    let fileName = 'downloaded file';
    if (utf8FileNameRegex.test(contentDisposition)) {
        fileName = utf8FileNameRegex.exec(contentDisposition)[1];
    }
    else if (fileNameRegex.test(contentDisposition)) {
        fileName = fileNameRegex.exec(contentDisposition)[1];
    }
    return decodeURIComponent(fileName);
}
export class AjaxRemoteService {
    constructor(options = {}) {
        this.beforeSend = () => { };
        this.complete = () => { };
        this.headers = {};
        this._applyOptions(options);
    }
    _applyOptions(options = {}) {
        if (type.isDefined(options.beforeSend)) {
            this.beforeSend = options.beforeSend;
        }
        else {
            this.beforeSend = () => { };
        }
        if (type.isDefined(options.headers)) {
            this.headers = options.headers;
        }
        else {
            this.headers = {};
        }
        if (type.isDefined(options.complete)) {
            this.complete = options.complete;
        }
        else {
            this.complete = () => { };
        }
    }
    getFromServer(url, data, queryOptions) {
        var obsoleteGetFromServer = findGloballyDefinedMethod('DevExpress', 'Dashboard', 'getFromServer');
        if (obsoleteGetFromServer) {
            console.warn('This method is obsolete. Please use **remoteService** option to customize HTTP requests.');
            return obsoleteGetFromServer(url, data, queryOptions);
        }
        return $.ajax(Object.assign({ url: url, dataType: 'json', data: data, beforeSend: this.beforeSend, headers: this.headers, complete: this.complete }, queryOptions));
    }
    postToServer(url, data) {
        var obsoletePostToServer = findGloballyDefinedMethod('DevExpress', 'Dashboard', 'postToServer');
        if (obsoletePostToServer) {
            console.warn('This method is obsolete. Please use **remoteService** option to customize HTTP requests.');
            return obsoletePostToServer(url, data);
        }
        return $.ajax({
            method: 'post',
            url: url,
            dataType: 'json',
            contentType: 'application/json',
            jsonp: false,
            data: data === null || data === undefined ? '' : JSON.stringify(data),
            beforeSend: this.beforeSend,
            headers: this.headers,
            complete: this.complete
        });
    }
    performPostback(url, args) {
        const parsedArgs = JSON.stringify(args);
        var obsoletePerformPostback = findGloballyDefinedMethod('DevExpress', 'Dashboard', 'performPostback');
        if (obsoletePerformPostback) {
            console.warn('This method is obsolete. Please use **remoteService** option to customize HTTP requests.');
            return obsoletePerformPostback(url, parsedArgs);
        }
        var $div = $.fn.constructor('<div>').appendTo('body');
        var $form = $.fn.constructor('<form>', {
            action: url,
            method: 'POST',
            target: '_blank'
        }).appendTo($div);
        var $input = $.fn.constructor('<input>', {
            id: 'dx-db-export-input-id',
            name: 'dx-db-export',
            type: 'hidden',
            value: encodeURIComponent(parsedArgs)
        }).appendTo($form);
        Object.keys(this.headers).forEach(headerName => {
            var $input = $.fn.constructor('<input>', {
                name: headerName,
                type: 'hidden',
                value: encodeURIComponent(this.headers[headerName])
            }).appendTo($form);
        });
        $form.submit();
        $div.remove();
        return createJQueryDeferred().resolve().promise();
    }
}
export class FetchRemoteService {
    constructor(options = {}) {
        this.headers = {};
        this._executeRequest = (method, url, data, queryOptions, abortController) => {
            const responseDeferred = createJQueryDeferred();
            const response = this._fetch(method, url, data, queryOptions, abortController);
            response.then((response) => __awaiter(this, void 0, void 0, function* () {
                let json;
                try {
                    json = yield response.json();
                }
                catch (e) {
                    responseDeferred.reject(e.message);
                    return;
                }
                if (response.ok) {
                    responseDeferred.resolve(json);
                }
                else {
                    responseDeferred.reject(json.Message);
                }
            }), (error) => {
                responseDeferred.reject(error.message);
            });
            return responseDeferred.promise();
        };
        this._fetch = (method, url, data, queryOptions, abortController) => {
            const { cache, preparedUrl, body } = this._prepareParams(method, url, data, queryOptions);
            const settings = {
                method,
                cache,
                headers: Object.assign({ 'content-type': 'application/json' }, this.headers),
                body,
                signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal
            };
            this.beforeSend && this.beforeSend(settings);
            return fetch(preparedUrl, settings);
        };
        this._applyOptions(options);
    }
    _applyOptions(options = {}) {
        this.headers = {};
        if (type.isDefined(options === null || options === void 0 ? void 0 : options.headers)) {
            this.headers = options.headers;
        }
        this.beforeSend = options === null || options === void 0 ? void 0 : options.beforeSend;
    }
    getFromServer(url, data, queryOptions, abortController) {
        return this._executeRequest('GET', url, data, queryOptions, abortController);
    }
    postToServer(url, data, abortController) {
        return this._executeRequest('POST', url, data, abortController);
    }
    _performPostback(url, args, abortController) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._fetch('POST', url, args, abortController);
            if (response.ok) {
                const blob = yield response.blob();
                const contentDisposition = response.headers.get('Content-Disposition');
                const fileMetadata = {
                    contentType: response.headers.get('Content-Type'),
                    contentFilename: _getFileName(contentDisposition),
                    url: URL.createObjectURL(blob)
                };
                const link = document.createElement('a');
                link.href = fileMetadata.url;
                link.rel = 'noreferrer noopener';
                link.download = fileMetadata.contentFilename;
                document.body.appendChild(link);
                link.click();
                link.remove();
                URL.revokeObjectURL(fileMetadata.url);
            }
            else {
                const json = yield response.json();
                throw new Error(json.Message);
            }
        });
    }
    performPostback(url, args, abortController) {
        const response = this._performPostback(url, args, abortController);
        const responseDeferred = createJQueryDeferred();
        response
            .then(() => {
            responseDeferred.resolve();
        }).catch((error) => {
            responseDeferred.reject(error.message);
        });
        return responseDeferred.promise();
    }
    _prepareParams(method, url, data, queryOptions) {
        let body = null;
        let preparedUrl = url;
        let cache = 'default';
        if (type.isDefined(queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.cache) && !queryOptions.cache) {
            cache = 'no-store';
        }
        if (method === 'GET') {
            const queryParams = jqueryQueryParam(data);
            if (queryParams) {
                preparedUrl.includes('?') ? preparedUrl += `&${queryParams}` : preparedUrl += `?${queryParams}`;
            }
        }
        else if (method === 'POST') {
            body = data === null || data === undefined ? '' : JSON.stringify(data);
        }
        return { cache, preparedUrl, body };
    }
}
