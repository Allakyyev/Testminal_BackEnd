/**
* DevExpress Dashboard (_docking-layout-bindings.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getHeight, getWidth } from '../../data/_jquery-helpers';
import { debounce } from '../../data/_utils';
import { safeComputed, safeSubscribe } from '../../model/internal/_knockout-utils';
import { titleHeight as defaultTitleHeight } from '../../viewer-parts/title/_dashboard-title-view-constants';
import { DashboardTitleModel } from '../viewer/title/_dashboard-title-model';
import { DockingLayoutSettings } from './_docking-layout-settings';
import { SplitterSize } from './core/_layout-item';
const ShadowSize = SplitterSize / 2;
const _getPaddingBesideScrollBar = (mode) => safeComputed({ mode }, args => {
    const scrollbarSize = 8;
    let calculatedPadding = DockingLayoutSettings.layoutPaddings - scrollbarSize;
    calculatedPadding = calculatedPadding < 0 ? 0 : calculatedPadding;
    return args.mode === 'Fixed' ? calculatedPadding : DockingLayoutSettings.layoutPaddings;
});
const _getScrollDirection = (verticalMode, horizontalMode) => {
    if (horizontalMode === 'Fixed' && verticalMode === 'Fixed') {
        return 'both';
    }
    else if (horizontalMode === 'Fixed') {
        return 'horizontal';
    }
    else if (verticalMode === 'Fixed') {
        return 'vertical';
    }
};
const processResize = ({ element, layout, layoutOptions, fullscreenItemModel, titleModel, titleWidth, titleHeight, repaintRequest, resizeByTimer, rootLayoutElement }) => {
    const disposables = [];
    const toDispose = (disposable) => {
        disposables.push(disposable);
        return disposable;
    };
    const layoutContainerSize = {
        width: getWidth(element),
        height: getHeight(element),
    };
    const getLayoutWidth = () => {
        const initialWidth = layoutOptions.width.mode() === 'Fixed' ? layoutOptions.width.value() : layoutContainerSize.width;
        return initialWidth - DockingLayoutSettings.layoutPaddings * 2;
    };
    const getLayoutHeight = () => {
        const initialHeight = layoutOptions.height.mode() === 'Fixed' ? layoutOptions.height.value() : layoutContainerSize.height;
        return initialHeight - DockingLayoutSettings.layoutPaddings * 2 - (titleModel.showTitle() === true ? titleHeight() : 0);
    };
    const updateTitleWidth = () => {
        const titleContainerWidth = layoutContainerSize.width - DockingLayoutSettings.layoutPaddings * 2;
        titleWidth((ko.unwrap(fullscreenItemModel.visible) ? titleContainerWidth : Math.min(getLayoutWidth(), titleContainerWidth)) - ShadowSize * 2);
    };
    const updateFullscreenItemSize = () => {
        if (ko.unwrap(fullscreenItemModel.visible)) {
            fullscreenItemModel.viewModel().repaintRequest.fire();
        }
    };
    const updateSize = () => {
        updateFullscreenItemSize();
        updateTitleWidth();
        const rootElt = rootLayoutElement();
        if (rootElt) {
            rootElt.style.width = `${getLayoutWidth()}px`;
            rootElt.style.height = `${getLayoutHeight()}px`;
        }
        layout.updateSize(getLayoutWidth(), getLayoutHeight());
    };
    const updateSizeDebounced = debounce(updateSize, 100);
    const resizeObserver = new ResizeObserver(entries => {
        layoutContainerSize.width = entries[0].contentRect.width;
        layoutContainerSize.height = entries[0].contentRect.height;
        if (resizeByTimer()) {
            updateSizeDebounced();
        }
    });
    resizeObserver.observe(element);
    toDispose(safeSubscribe({
        widthMode: layoutOptions.width.mode,
        fixedWidth: layoutOptions.width.value,
        mode: layoutOptions.height.mode,
        fixedHeight: layoutOptions.height.value,
        titleHeight,
        showTitle: titleModel.showTitle,
        rootLayoutElement
    }, () => updateSize()));
    toDispose(fullscreenItemModel.visible.subscribe(updateTitleWidth));
    toDispose(resizeByTimer.subscribe((newValue) => newValue && updateSize()));
    const forceRepaintCallback = () => updateSize();
    repaintRequest.add(forceRepaintCallback);
    toDispose({
        dispose: () => {
            repaintRequest.remove(forceRepaintCallback);
        }
    });
    return disposables;
};
ko.components.register('dashboard-docking-layout', {
    viewModel: {
        createViewModel: function ({ componentArgs }, componentInfo) {
            let disposables = [];
            const toDispose = (disposable) => {
                disposables.push(disposable);
                return disposable;
            };
            const rootLayoutElement = ko.observable();
            const titleWidth = ko.observable(getWidth(componentInfo.element));
            const titleHeight = ko.observable(defaultTitleHeight);
            const titleModel = new DashboardTitleModel(componentArgs.titleContext, componentArgs.dashboard);
            const isTitleVisible = titleModel.showTitle;
            const layout = componentArgs.layout;
            const layoutOptions = componentArgs.dashboard.layoutOptions;
            const fullscreenItemModel = componentArgs.fullscreenItemModel;
            const layoutTop = toDispose(safeComputed({ isTitleVisible, titleHeight, }, args => args.isTitleVisible ? args.titleHeight + DockingLayoutSettings.layoutPaddings : 0));
            const paddings = {
                paddingTop: toDispose(safeComputed({ isTitleVisible }, args => args.isTitleVisible ? 0 : DockingLayoutSettings.layoutPaddings)),
                paddingRight: toDispose(_getPaddingBesideScrollBar(layoutOptions.height.mode)),
                paddingBottom: toDispose(_getPaddingBesideScrollBar(layoutOptions.width.mode)),
                paddingLeft: DockingLayoutSettings.layoutPaddings
            };
            const scrollViewOptions = toDispose(safeComputed({
                verticalMode: layoutOptions.height.mode,
                horizontalMode: layoutOptions.width.mode
            }, (args) => (Object.assign({ direction: _getScrollDirection(args.verticalMode, args.horizontalMode), showScrollbar: _getScrollDirection(args.verticalMode, args.horizontalMode) ? 'always' : 'never' }, componentArgs.scrollViewEvents))));
            const viewModel = {
                title: {
                    showTitle: titleModel.showTitle,
                    containerStyles: {
                        display: 'flex',
                        justifyContent: 'start',
                        position: 'absolute',
                        top: DockingLayoutSettings.layoutPaddings,
                        left: DockingLayoutSettings.layoutPaddings + ShadowSize,
                        height: titleHeight
                    },
                    styles: {
                        width: titleWidth,
                    },
                    componentArgs: {
                        height: titleHeight,
                        width: titleWidth,
                        encodeHtml: componentArgs.encodeHtml,
                        options: titleModel.toolbarOptions,
                    }
                },
                scrollView: {
                    options: scrollViewOptions,
                    styles: { top: layoutTop },
                    contentWrapperStyles: Object.assign(Object.assign({}, paddings), { display: 'block', boxSizing: 'content-box' }),
                },
                fullscreenItem: {
                    styles: {
                        paddingTop: paddings.paddingTop,
                        paddingRight: DockingLayoutSettings.layoutPaddings,
                        paddingBottom: DockingLayoutSettings.layoutPaddings,
                        paddingLeft: DockingLayoutSettings.layoutPaddings,
                        top: layoutTop
                    }
                },
                layout: layout,
                layoutMainElementEvents: Object.assign(Object.assign({}, componentArgs.layoutMainElementEvents), { targetElement: rootLayoutElement }),
                fullscreenItemModel: fullscreenItemModel,
            };
            processResize({
                element: componentInfo.element,
                layout,
                layoutOptions,
                fullscreenItemModel,
                titleModel,
                titleWidth,
                titleHeight,
                repaintRequest: componentArgs.repaintRequest,
                resizeByTimer: componentArgs.resizeByTimer,
                rootLayoutElement: rootLayoutElement
            })
                .forEach(d => toDispose(d));
            const disposeCallback = () => {
                disposables.forEach(disposable => disposable.dispose());
                disposables = [];
                titleModel.dispose();
                window.removeEventListener('unload', disposeCallback);
            };
            ko.utils.domNodeDisposal.addDisposeCallback(componentInfo.element, disposeCallback);
            window.addEventListener('unload', disposeCallback);
            return viewModel;
        }
    },
    template: { element: 'dx-dashboard-docking-layout' }
});
