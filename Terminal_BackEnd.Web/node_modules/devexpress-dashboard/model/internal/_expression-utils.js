/**
* DevExpress Dashboard (_expression-utils.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { CriteriaOperatorStateMachine } from '@devexpress/analytics-core/analytics-criteria-utils';
import { FilterEditorSerializer } from '@devexpress/analytics-core/analytics-widgets-internal';
import * as ko from 'knockout';
var parameterPositions = [];
function visitOperandProperty(element) {
    var _a;
    if (hasParametersPrefix(element.propertyName)) {
        parameterPositions.push({ operandStartPosition: ((_a = element.startPosition.column) !== null && _a !== void 0 ? _a : 0) - 1, operandPropertyLength: element.originalPropertyLength });
    }
    return element;
}
export function replaceExpressionParametersPrefix(expression) {
    var criteriaOperator = CriteriaOperatorStateMachine.parse(expression);
    if (!criteriaOperator)
        return ko.observable(expression);
    parameterPositions.splice(0);
    criteriaOperator = criteriaOperator.accept({ visitOperandProperty: visitOperandProperty });
    const replaceAtString = (value, startIndex, replaceCount, replacement) => {
        return value.substring(0, startIndex) + replacement + value.substring(startIndex + replaceCount);
    };
    var shift = 0;
    const replaceLength = '[Parameters.'.length;
    parameterPositions.forEach(parameterEntry => {
        const startPosition = parameterEntry.operandStartPosition - shift;
        if (startPosition < 0) {
            console.warn('Operand property should has a start position.');
            return;
        }
        if (expression[startPosition] === '[' && expression[startPosition + parameterEntry.operandPropertyLength - 1] === ']') {
            expression = replaceAtString(expression, startPosition, replaceLength, '?');
            const parameterNameLength = parameterEntry.operandPropertyLength - replaceLength;
            expression = replaceAtString(expression, startPosition + parameterNameLength, 1, '');
            shift += replaceLength;
        }
    });
    return ko.observable(expression);
}
export function hasParametersPrefix(value) {
    return value.length && value.startsWith('Parameters.');
}
export function getFilterCriteria(filterString) {
    let criteriaSerializer = new FilterEditorSerializer();
    return criteriaSerializer.deserialize(filterString);
}
export function insertDimensionsExpressionsIntoFilterExpression(filterString, dimensionsExpressions) {
    let criteriaSerializer = new FilterEditorSerializer();
    let filterCriteria = criteriaSerializer.deserialize(filterString);
    let dimensionsCriteria = {};
    for (let dimensionName in dimensionsExpressions)
        dimensionsCriteria[dimensionName] = CriteriaOperatorStateMachine.parse(dimensionsExpressions[dimensionName]);
    let patched = DimensionExpressionInserter.patch(filterCriteria, dimensionsCriteria);
    return criteriaSerializer.serialize(patched);
}
export class DimensionExpressionInserter {
    constructor(dimensionsCriteria) {
        this._dimensionsCriteria = dimensionsCriteria;
    }
    static patch(criteria, dimensionsCriteria) {
        let patcher = new DimensionExpressionInserter(dimensionsCriteria);
        return criteria.accept(patcher);
    }
    visitOperandProperty(element) {
        return this._dimensionsCriteria[element.propertyName];
    }
}
