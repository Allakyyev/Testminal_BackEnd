/**
* DevExpress Dashboard (_chart-utils.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../data/localization/_default';
import { getDataItemContainerDisplayName } from '../../designer/_display-name-provider';
import { HighLowCloseSeries, OpenHighLowCloseSeries, RangeSeries, SimpleSeries, WeightedSeries } from '../../model/items/chart/chart-series';
import { chartSeriesValue, close, high, low, open } from '../../model/items/chart/metadata/_chart-series';
import { indicatorTypeMap } from '../items/chart/metadata/_chart-indicators';
export function getChartCFSeries(dashboardItem) {
    return []
        .concat(...dashboardItem.panes().map(pane => pane.series()))
        .filter(series => series._isConditionalFormattingSupported);
}
export function getChartApplyToDataItems(dashboardItem, dataSourceBrowser, getChartSeries = getChartCFSeries) {
    return () => getChartSeries(dashboardItem).reduce((result, series) => {
        result.push({
            uniqueName: series._getDataId(),
            displayName: series.name() || getDataItemContainerDisplayName(dataSourceBrowser, dashboardItem, series)
        });
        return result;
    }, []);
}
export function getChartSeries(dashboardItem) {
    return []
        .concat(...dashboardItem.panes().map(pane => pane.series()));
}
export function getAvailableValueLevels(seriesDataId, dashboardItem) {
    const series = getChartSeries(dashboardItem);
    const chosenSeries = series.filter(series => series._getDataId() === seriesDataId)[0];
    let availableValueLevels = [];
    switch (chosenSeries === null || chosenSeries === void 0 ? void 0 : chosenSeries.constructor) {
        case HighLowCloseSeries:
            availableValueLevels = [low, high, close];
            break;
        case OpenHighLowCloseSeries:
            availableValueLevels = [open, low, high, close];
            break;
        case SimpleSeries:
        case WeightedSeries:
        case RangeSeries:
            availableValueLevels = [chartSeriesValue];
            break;
    }
    return availableValueLevels.map(level => { return { value: level.modelName, displayValueId: level.displayName }; });
}
export function getIndicatorDisplayNameFromSeries(model, dashboardItem, dataSourceBrowser) {
    var _a;
    let seriesDataId = model.value();
    let chosenSeriesName = ko.unwrap((_a = getChartApplyToDataItems(dashboardItem, dataSourceBrowser, getChartSeries)()
        .filter(x => x.uniqueName === seriesDataId)[0]) === null || _a === void 0 ? void 0 : _a.displayName);
    chosenSeriesName = chosenSeriesName + ' ' + getLocalizationById(indicatorTypeMap[model.itemType()]);
    return chosenSeriesName;
}
export function getDefaultSeriesDataId(model, dashboardItem, dataSourceBrowser) {
    const seriesDataItems = ko.pureComputed(() => {
        const chartSeries = getChartApplyToDataItems(dashboardItem, dataSourceBrowser, getChartSeries)();
        return chartSeries.map((m) => ({ value: ko.unwrap(m.uniqueName), displayValueId: ko.unwrap(m.displayName) }));
    });
    const seriesDataItemNames = seriesDataItems().map(dataItem => ko.unwrap(dataItem.value));
    if (!model.value() && seriesDataItemNames.length) {
        model.value(seriesDataItemNames[0]);
    }
}
