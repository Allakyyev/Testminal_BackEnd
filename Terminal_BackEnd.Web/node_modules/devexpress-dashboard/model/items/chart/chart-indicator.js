/**
* DevExpress Dashboard (chart-indicator.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { getChartApplyToDataItems, getChartSeries, getIndicatorDisplayNameFromSeries } from '../../internal/_chart-utils';
import { DefaultDashboardPalette } from '../../internal/_default-palette';
import { NameGenerator } from '../../internal/_helper-classes';
import { SerializableModel } from '../../serializable-model';
import { chartIndicatorSerializationInfo, indicatorTypeMap } from './metadata/_chart-indicators';
export class ChartIndicator extends SerializableModel {
    constructor(model, serializer, info) {
        super(model, serializer, info);
        this._typeName = ko.observable(this.customTypeName() || this.itemType());
    }
    static _createNew(chartItem, dataSourceBrowser) {
        const defaultName = getLocalizationById('DashboardStringId.DefaultNameChartIndicator');
        const name = NameGenerator.generateName(defaultName, chartItem.indicators(), 'name', 1);
        const newModel = new ChartIndicator({
            '@Name': name,
            '@Visible': true,
            '@ShowInLegend': true,
            '@ItemType': 'TrendLine'
        });
        const currentColorIndex = chartItem.panes().reduce((accumulator, currentPane) => {
            return accumulator + currentPane.series().length;
        }, 0);
        const existedColors = chartItem.indicators().map(x => x.color());
        newModel.color(DefaultDashboardPalette.getNextColor(currentColorIndex, existedColors));
        const chartSeries = getChartApplyToDataItems(chartItem, dataSourceBrowser, getChartSeries)()[0];
        if (chartSeries) {
            newModel.value(ko.unwrap(chartSeries.uniqueName));
            const displayName = getIndicatorDisplayNameFromSeries(newModel, chartItem, dataSourceBrowser);
            newModel.legendText(displayName);
        }
        return newModel;
    }
    getInfo() {
        return chartIndicatorSerializationInfo;
    }
    _updateItemType() {
        let typeName = this._typeName();
        if (typeName in indicatorTypeMap) {
            this.itemType(typeName);
        }
        else {
            this.customTypeName(typeName);
            this.itemType('CustomIndicator');
        }
    }
}
