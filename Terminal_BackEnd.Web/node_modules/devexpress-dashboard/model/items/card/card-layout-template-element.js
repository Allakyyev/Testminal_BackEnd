/**
* DevExpress Dashboard (card-layout-template-element.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
import { getLocalizationById } from '../../../data/localization/_default';
import { SerializableModel } from '../../serializable-model';
import { cardLayoutTemplateDataElementSerializationInfo, cardLayoutTemplateElementBaseSerializationInfo, cardRowDataElementTypeValuesMapEx } from './metadata/_card-layout-template-element';
export class CardLayoutTemplateElementBase extends SerializableModel {
    constructor(modelJson = {}, serializer = new ModelSerializer()) {
        super(modelJson, serializer);
    }
    _createEditorModel(dimensionNames) {
        return {
            title: this._getTitle(dimensionNames),
            checked: this.visible
        };
    }
    getInfo() {
        return cardLayoutTemplateElementBaseSerializationInfo;
    }
    _initDefault(visible = true, valueType = null, dimenstionIndex = 0) {
        this.visible(visible);
    }
}
export class CardLayoutTemplateDeltaElement extends CardLayoutTemplateElementBase {
    constructor(modelJson = {}, serializer = new ModelSerializer()) {
        super(modelJson, serializer);
    }
    _getTitle() {
        return ko.computed(() => getLocalizationById(cardRowDataElementTypeValuesMapEx.DeltaIndicator));
    }
}
export class CardLayoutTemplateSparklineElement extends CardLayoutTemplateElementBase {
    constructor(modelJson = {}, serializer = new ModelSerializer()) {
        super(modelJson, serializer);
    }
    _getTitle() {
        return ko.computed(() => getLocalizationById(cardRowDataElementTypeValuesMapEx.Sparkline));
    }
}
export class CardLayoutTemplateDataElement extends CardLayoutTemplateElementBase {
    constructor(modelJson = {}, serializer = new ModelSerializer()) {
        super(modelJson, serializer);
    }
    _getTitle(dimensionNames) {
        return ko.computed(() => {
            var res = getLocalizationById(cardRowDataElementTypeValuesMapEx[this.valueType()]);
            if (this.valueType() === 'DimensionValue') {
                res += ' ' + (dimensionNames[this.dimensionIndex()] || ('[' + this.dimensionIndex() + ']'));
            }
            return res;
        });
    }
    getInfo() {
        return cardLayoutTemplateDataElementSerializationInfo;
    }
    _initDefault(visible, valueType, dimenstionIndex = 0) {
        super._initDefault(visible);
        this.valueType(valueType);
        this.dimensionIndex(dimenstionIndex);
    }
    _getEditorProperty(valueType, dimensionIndex = 0, dimensionNames) {
        var displayText = getLocalizationById(cardRowDataElementTypeValuesMapEx[valueType]);
        if (valueType === 'DimensionValue')
            displayText += ' ' + dimensionNames[dimensionIndex];
        return { value: valueType, displayText: displayText, dimensionIndex: dimensionIndex, key: valueType + dimensionIndex };
    }
    _createEditorModel(dimensionNames) {
        var items = ['Title', 'Subtitle', 'ActualValue', 'TargetValue', 'AbsoluteVariation', 'PercentVariation', 'PercentOfTarget', 'CardName']
            .map((valueType) => this._getEditorProperty(valueType))
            .concat(dimensionNames.map((name, index) => this._getEditorProperty('DimensionValue', index, dimensionNames)));
        return Object.assign(Object.assign({}, super._createEditorModel(dimensionNames)), { lookupDataSource: items, selectedItem: ko.pureComputed({
                read: () => {
                    const selectedItem = items.filter(i => i.value === this.valueType() && i.dimensionIndex === this.dimensionIndex())[0];
                    return selectedItem && selectedItem.key;
                },
                write: (val) => {
                    const newValue = items.filter(i => i.key === val)[0];
                    this.valueType(newValue.value);
                    this.dimensionIndex(newValue.dimensionIndex);
                }
            }) });
    }
}
