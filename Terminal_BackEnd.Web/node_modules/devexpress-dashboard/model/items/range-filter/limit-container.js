/**
* DevExpress Dashboard (limit-container.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
import { SerializableModel } from '../../serializable-model';
import { limitContainer } from './metadata/_limit-container';
export class LimitContainer extends SerializableModel {
    constructor(modelJson = {}, serializer = new ModelSerializer()) {
        super(modelJson, serializer);
        this.mode = ko.observable();
        this.argumentInterval = ko.observable('Year');
        this.addDisposable(this.mode.subscribe(newMode => {
            if (newMode === 'None') {
                this.flow.isEmpty(true);
                this.fixed.isEmpty(true);
            }
            else if (newMode === 'Flow') {
                this.flow.isEmpty(false);
                this.fixed.isEmpty(true);
            }
            else if (newMode === 'Fixed') {
                this.flow.isEmpty(true);
                this.fixed.isEmpty(false);
            }
        }));
        if (!modelJson.hasOwnProperty('FixedDateTimePeriodLimit')) {
            if (!modelJson.hasOwnProperty('FlowDateTimePeriodLimit')) {
                this.mode('None');
            }
            else {
                this.mode('Flow');
            }
        }
        else {
            this.mode('Fixed');
        }
        this.addDisposable(ko.computed(() => {
            this.flow.argumentInterval(this.argumentInterval());
        }));
    }
    getInfo() {
        return limitContainer;
    }
    isEmpty() {
        return this.mode() === 'None';
    }
    getInterval() {
        if (this.mode() === 'Flow') {
            return this.flow.interval();
        }
        else {
            return null;
        }
    }
}
