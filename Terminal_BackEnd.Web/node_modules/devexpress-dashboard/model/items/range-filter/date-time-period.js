/**
* DevExpress Dashboard (date-time-period.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { ModelSerializer } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
import { DashboardFormatHelper } from '../../../data/_format-helper';
import { constructIntervalFilterText } from '../../../data/_formatter';
import { getLocalizationById } from '../../../data/localization/_default';
import { DateTimePeriodConverter } from '../../../viewer-parts/viewer-items/range-selector-item/_datetime-period-converter';
import { DataField } from '../../data-sources/_data-field';
import { safeSubscribe } from '../../internal/_knockout-utils';
import { TypedSerializableModel } from '../../serializable-model';
import { dateTimePeriodSerializationsInfo } from './metadata/_date-time-period';
import { convertDateTimeGroupInterval, flowIntervalOrderedValues } from './metadata/_period-limit';
export class DateTimePeriod extends TypedSerializableModel {
    constructor(modelJson = {}, serializer = new ModelSerializer()) {
        super(modelJson, serializer);
        this.argumentInterval = ko.observable('Year');
        this._firstDayOfWeek = ko.observable(0);
        this.addDisposable(this._getPeriodTextValue = ko.pureComputed(() => {
            let range = this.getDateTimeValue();
            var startTextValue = this.format(range.startValue);
            var endTextValue = this.format(range.endValue);
            if (startTextValue != null || endTextValue != null)
                return constructIntervalFilterText({ left: startTextValue, right: endTextValue });
            return getLocalizationById('DashboardStringId.EntireRangePeriodCaption');
        }));
        this.addDisposable(ko.computed(() => {
            this.start.argumentInterval(this.argumentInterval());
            this.end.argumentInterval(this.argumentInterval());
        }));
        this.addDisposable(this.start, this.end);
    }
    getInfo() {
        return dateTimePeriodSerializationsInfo;
    }
    _getDefaultItemType() { return 'DateTimePeriod'; }
    getDateTimeValue() {
        let convertToLimit = (limit) => {
            if (limit.mode() === 'None')
                return undefined;
            let flowMode = limit.mode() === 'Flow';
            return {
                Relative: flowMode,
                Date: limit.mode() === 'Fixed' ? limit.fixed.date() : undefined,
                Interval: flowMode ? limit.flow.interval() : undefined,
                Offset: flowMode ? limit.flow.offset() : undefined
            };
        };
        let range = DateTimePeriodConverter.toRange({
            Start: convertToLimit(this.start),
            End: convertToLimit(this.end)
        }, this._firstDayOfWeek());
        return range;
    }
    getDateFormat() {
        var argumentInterval = convertDateTimeGroupInterval(this.argumentInterval()), startInterval = this.start.getInterval() || argumentInterval, endInterval = this.end.getInterval() || argumentInterval;
        var dateFormat = ['year', 'quarterYear', 'monthYear', 'weekYear', 'dayMonthYear', 'dateHour', 'dateHourMinute', 'dateHourMinuteSecond'];
        return dateFormat[Math.max(flowIntervalOrderedValues.indexOf(startInterval), flowIntervalOrderedValues.indexOf(endInterval))];
    }
    format(value) {
        if (value == null)
            return null;
        var dateFormatInfoType = this.getDateFormat(), correctedValue = value;
        switch (dateFormatInfoType) {
            case 'year':
                correctedValue = value.getFullYear();
                break;
        }
        return DashboardFormatHelper.format(correctedValue, { dateType: 'short', format: dateFormatInfoType });
    }
    _subscribeToGroupInterval(dimension) {
        return safeSubscribe({
            dataMember: dimension.dataMember,
            groupInterval: dimension.dateTimeGroupInterval
        }, (dim) => {
            this.argumentInterval(DataField.isOlap(dim.dataMember) ? 'None' : dim.groupInterval);
        });
    }
}
