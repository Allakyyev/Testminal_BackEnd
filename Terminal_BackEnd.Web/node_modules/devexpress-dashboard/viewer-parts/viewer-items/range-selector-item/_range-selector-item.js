/**
* DevExpress Dashboard (_range-selector-item.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import dxRangeSelector from 'devextreme/viz/range_selector';
import { specialValues } from '../../../data/special-values';
import { chartHelper } from '../../../data/_chart-helper';
import { viewerActions } from '../../../data/_common';
import { DashboardFormatHelper } from '../../../data/_format-helper';
import { closest, createJQueryCallbacks, isVisible } from '../../../data/_jquery-helpers';
import { localizationId } from '../../../data/_localization-ids';
import { localizer } from '../../../data/_localizer';
import { findIndex, findLastIndex, type } from '../../../data/_utils';
import { dashboardToolbarItemNames } from '../../widgets/caption-toolbar/caption-toolbar-options';
import { cssClasses } from '../../widgets/caption-toolbar/_caption-toolbar-css-classes';
import { customTimePeriodDialog } from '../../widgets/dialogs/_custom-time-period-dialog';
import { RenderHelper } from '../../widgets/_render-helper';
import { baseItem } from '../_base-item';
import { RangeFilterSelectionValidator } from './_range-filter-selection-validator';
var DayIntervalWidthInPixels = 25, MonthIntervalWidthInPixels = 40, QuarterIntervalWidthInPixels = 20;
export class rangeSelectorItem extends baseItem {
    constructor(container, options) {
        super(container, options);
        this.itemElementCustomColor = createJQueryCallbacks();
        this.timePeriodMenuSelectedIndex = undefined;
    }
    get dataController() { return this._dataController; }
    set dataController(dataController) { this._dataController = dataController; }
    get _isBottomFloatingToolbarPosition() {
        return true;
    }
    _getCustomTimePeriodDialog() {
        if (!this._customTimePeriodDialog) {
            this._customTimePeriodDialog = new customTimePeriodDialog({
                container: closest(this.container, '.' + cssClasses.dashboardContainer),
                setRange: (range) => {
                    this.selected.fire(this.getName(), viewerActions.setMasterFilter, [[range.startValue, range.endValue]]);
                }
            });
        }
        return this._customTimePeriodDialog;
    }
    _initializeData(newOptions) {
        super._initializeData(newOptions);
        if (this._dataController) {
            this._dataController.elementCustomColor = (args) => this._elementCustomColor(args);
        }
    }
    _clearSelectionUnsafe() {
        this._setRange([]);
    }
    _clearSelectionBase() {
        this.timePeriodMenuSelectedIndex = undefined;
    }
    _setSelectionUnsafe(values) {
        this._setRange(values && values.length > 0 ? values[0] : []);
    }
    _getCurrentRange() {
        var value = this._getSelectedValues();
        let startValue, endValue;
        if (value && value !== null) {
            startValue = value[0];
            endValue = value[1];
        }
        if (!type.isDefined(startValue) || !type.isDefined(endValue)) {
            let entireRange = this._getEntireRange();
            if (!type.isDefined(startValue))
                startValue = entireRange.startValue;
            if (!type.isDefined(endValue))
                endValue = entireRange.endValue;
        }
        return new rangeFilterSelection({ startValue, endValue });
    }
    getEntireRange() {
        return new rangeFilterSelection(this._getEntireRange());
    }
    dispose() {
        super.dispose();
        var customPeriodForm = this._getCustomTimePeriodDialog();
        if (customPeriodForm) {
            customPeriodForm.dispose();
        }
        this.rangeSelectorViewer && this.rangeSelectorViewer.dispose();
    }
    _setRange(range) {
        this._setSelectedValues([range]);
        if (this.hasWidget) {
            this._lock();
            this.rangeSelectorViewer.setValue(range);
            this._unlock();
        }
        else {
            this.selected.fire(this.getName(), viewerActions.setMasterFilter, [range]);
        }
    }
    _setPredefinedRange(dateTimePeriodName) {
        let dateTimePeriods = this.options.ViewModel.DateTimePeriods;
        let period = dateTimePeriods.filter(dateTimePeriod => dateTimePeriod.Name === dateTimePeriodName)[0];
        this.timePeriodMenuSelectedIndex = !!period ? dateTimePeriods.indexOf(period) : undefined;
        this.updateCaptionToolbar();
    }
    _getAvailablePredefinedRanges() {
        return this.options.ViewModel.DateTimePeriods.map(period => period.Name);
    }
    renderContentUnsafe(element, changeExisting, afterRenderCallback) {
        var that = this, options = this._getRangeSelectorViewerOptions();
        var isFirstInitialization = !changeExisting || !that.rangeSelectorViewer;
        this._lock();
        this._raiseItemWidgetOptionsPrepared(options);
        try {
            if (isFirstInitialization) {
                this.rangeSelectorViewer = this._createTestableWidget(element, options);
            }
            else {
                this.rangeSelectorViewer.option(options);
            }
        }
        finally {
            this._unlock();
        }
        this.timePeriodMenuSelectedIndex = this.options.ViewModel.SelectedPeriodIndex;
        return false;
    }
    _createTestableWidget(element, options) {
        return new dxRangeSelector(element, options);
    }
    _isBorderRequired() {
        return false;
    }
    _getContainerPositionUnsafe() {
        var position = super._getContainerPositionUnsafe(), buttonOffset = this._getButtonOffset(true);
        position.offsetY = position.height - buttonOffset.top;
        return position;
    }
    _getFirstDayOfWeek() {
        var rangeDataController = this.dataController;
        var argumentFormat = rangeDataController.getArgumentFormat();
        return argumentFormat ? argumentFormat.firstDayOfWeek : null;
    }
    _getRangeSelectorViewerOptions() {
        var that = this;
        let rangeDataController = that.dataController;
        var viewModel = that.options.ViewModel, argument = viewModel.Argument, scaleType = rangeSelectorItem._getScaleType(argument), seriesTemplates = viewModel.SeriesTemplates, selectedValues = this._getSelectedValues(), dataSourceAndSeries = rangeDataController.getDataSourceAndSeries(that._isEncodeHtml()), tickMarkInterval = undefined, animation = that._getAnimationOptions(), options = {
            scale: {
                axisDivisionFactor: null,
                type: null,
                marker: {
                    visible: false
                }
            },
            encodeHtml: that._isEncodeHtml(),
            margin: {
                top: 10,
                bottom: 15
            }
        };
        if (scaleType !== 'discrete') {
            let entireRange = this._getEntireRangeByDataSource(dataSourceAndSeries.dataSource);
            options.scale.startValue = entireRange.startValue;
            options.scale.endValue = entireRange.endValue;
        }
        else {
            options.scale.startValue = null;
            options.scale.endValue = null;
        }
        if (!this._isValidValues(selectedValues)) {
            options.value = [selectedValues[0], selectedValues[1]];
        }
        var argumentFormat = rangeDataController.getArgumentFormat();
        options.scale.label = {
            format: (value) => DashboardFormatHelper.format(value, argumentFormat)
        };
        options.scale.valueType = argument.Type == 'DateTime' ? 'datetime' : 'numeric';
        options.sliderMarker = {
            format: (value) => DashboardFormatHelper.format(value, argumentFormat)
        };
        let dataSource = dataSourceAndSeries.dataSource;
        options.scale.type = scaleType;
        if (argument) {
            if ((argument.DateTimeGroupInterval === 'Year' && argument.Type === 'DateTime') ||
                !argument.IsContinuousDateTimeScale) {
                tickMarkInterval = rangeDataController.isDiscreteArgument() || argument.Type == 'Integer' ? 1 : chartHelper.convertPresentationUnit(argument);
                if (tickMarkInterval) {
                    var firstDayOfWeek = this._getFirstDayOfWeek();
                    if (tickMarkInterval === 'week') {
                        if (Number.isInteger(firstDayOfWeek)) {
                            options.scale.workWeek = [firstDayOfWeek];
                        }
                        else {
                            throw new Error('First Day Of Week is not defined for range filter agrument');
                        }
                    }
                    options.scale.minorTick = {
                        visible: false
                    };
                    options.behavior = {
                        snapToTicks: true,
                        animationEnabled: animation.enabled
                    };
                    options.scale.minRange = tickMarkInterval;
                    if (scaleType === 'semidiscrete') {
                        options.scale.axisDivisionFactor = {
                            day: DayIntervalWidthInPixels,
                            month: MonthIntervalWidthInPixels,
                            quarter: QuarterIntervalWidthInPixels
                        };
                    }
                }
            }
            else {
                options.behavior = {
                    snapToTicks: false,
                    animationEnabled: animation.enabled
                };
            }
        }
        options.dataSource = dataSource;
        let chartSeries = dataSourceAndSeries.series;
        if (scaleType === 'discrete') {
            chartSeries.forEach(series => {
                series.ignoreEmptyPoints = true;
            });
        }
        options.chart = {
            series: chartSeries,
            commonSeriesSettings: {
                type: seriesTemplates && seriesTemplates.length > 0 ? (chartHelper.convertSeriesType(seriesTemplates[0].SeriesType)) : null
            },
            palette: RenderHelper.getDefaultPalette()
        };
        options.onValueChanged = that._getSelectedRangeChangedHandler();
        return options;
    }
    _getEntireRange() {
        let rangeDataController = this.dataController;
        let dataSourceAndSeries = rangeDataController.getDataSourceAndSeries(this._isEncodeHtml());
        return this._getEntireRangeByDataSource(dataSourceAndSeries.dataSource);
    }
    _getEntireRangeByDataSource(dataSource) {
        let range;
        let lastDataItemIndex = dataSource ? findLastIndex(dataSource, item => this._checkAxisXValue(item.x)) : -1;
        if (lastDataItemIndex > 0) {
            let firstDataItemIndex = findIndex(dataSource, item => this._checkAxisXValue(item.x));
            let isQualitativeArgument = this.dataController.isQualitativeArgument();
            range = {
                startValue: isQualitativeArgument ? firstDataItemIndex : dataSource[firstDataItemIndex].x,
                endValue: isQualitativeArgument ? lastDataItemIndex : dataSource[lastDataItemIndex].x
            };
        }
        else {
            range = {
                startValue: null,
                endValue: null
            };
        }
        return range;
    }
    _checkAxisXValue(value) {
        return type.isDefined(value) && Object.keys(specialValues).filter(specialValueName => specialValues[specialValueName] === value).length === 0;
    }
    _getSelectedValues() {
        let allSelectedValues = super._getSelectedValues();
        return allSelectedValues ? allSelectedValues[0] : null;
    }
    _isValidValues(values) {
        if (values && values.length) {
            var startValue = values[0], endValue = values[1];
            if (RangeFilterSelectionValidator.isValidValue(startValue) && RangeFilterSelectionValidator.isValidValue(endValue))
                return false;
        }
        return true;
    }
    _getSliderMarkerFormat() {
        return this._dataController.isSingleArgument() ? this._dataController.getSingleArgumentDimensionFormat() : undefined;
    }
    static _getScaleType(argument) {
        if (argument) {
            let dateTimeGroupInterval = argument.DateTimeGroupInterval;
            switch (argument.Type) {
                case 'String':
                    let groupIntervalScaleType = rangeSelectorItem._getStringScaleTypeByGroupInterval(dateTimeGroupInterval);
                    return type.isDefined(groupIntervalScaleType) ? groupIntervalScaleType : 'discrete';
                case 'Integer':
                    return 'semidiscrete';
                case 'DateTime':
                    return rangeSelectorItem._getDateTimeScaleType(dateTimeGroupInterval);
                default:
                    return null;
            }
        }
    }
    static _getStringScaleTypeByGroupInterval(dateTimeGroupInterval) {
        switch (dateTimeGroupInterval) {
            case 'Year':
            case 'Quarter':
            case 'Month':
            case 'Day':
            case 'Hour':
            case 'Minute':
            case 'Second':
            case 'DayOfYear':
            case 'DayOfWeek':
            case 'WeekOfYear':
            case 'WeekOfMonth':
                return 'semidiscrete';
        }
        return undefined;
    }
    static _getDateTimeScaleType(dateTimeGroupInterval) {
        switch (dateTimeGroupInterval) {
            case 'Year':
            case 'QuarterYear':
            case 'MonthYear':
            case 'WeekYear':
            case 'DayMonthYear':
                return 'semidiscrete';
        }
        return null;
    }
    _getSelectedRangeChangedHandler() {
        var that = this;
        return function (e) {
            if (!that._isLocked()) {
                that.selected.fire(that.getName(), viewerActions.setMasterFilter, [e.value]);
            }
        };
    }
    _resizeUnsafe() {
        super._resizeUnsafe();
        if (isVisible(this.container)) {
            this.rangeSelectorViewer.render();
        }
    }
    _getWidget() {
        return this.rangeSelectorViewer;
    }
    _elementCustomColor(eventArgs) {
        this.itemElementCustomColor.fire(this.getName(), eventArgs);
    }
    _hasTimePeriods() {
        return true;
    }
    _isDateTimePeriodSupported() {
        return this.options.ViewModel.SupportDateTimePeriods;
    }
    _getSpecificActionToolbarItems() {
        if (this.options.ViewModel.SupportDateTimePeriods) {
            if (this.options.ViewModel.DateTimePeriods.length > 0) {
                let dateTimePeriodNames = this.options.ViewModel.DateTimePeriods.map(period => (period.Name));
                dateTimePeriodNames.push(localizer.getString(localizationId.buttonNames.CustomPeriod));
                return [{
                        menu: {
                            name: dashboardToolbarItemNames.dateTimePeriodMenu,
                            items: dateTimePeriodNames,
                            selectedItems: this.timePeriodMenuSelectedIndex !== undefined ? [dateTimePeriodNames[this.timePeriodMenuSelectedIndex]] : [],
                            selectionMode: 'multiple',
                            itemClick: (itemData, itemElement, index) => {
                                var viewModel = this.options.ViewModel, dateTimePeriods = viewModel.DateTimePeriods;
                                if (index >= 0 && index < dateTimePeriods.length) {
                                    if (this.timePeriodMenuSelectedIndex !== index) {
                                        this._raisePredefinedPeriodSelected(index);
                                    }
                                }
                                else {
                                    this._showCustomTimePeriodDialog();
                                }
                            },
                            type: 'list'
                        },
                        icon: cssClasses.iconTimePeriods,
                        type: 'menu',
                        hint: localizer.getString(localizationId.buttonNames.AddTimePeriod),
                    }];
            }
            else {
                return [{
                        name: dashboardToolbarItemNames.customDateTimePeriod,
                        icon: cssClasses.iconTimePeriods,
                        type: 'button',
                        hint: localizer.getString(localizationId.buttonNames.AddTimePeriod),
                        click: (element) => {
                            this._showCustomTimePeriodDialog();
                        }
                    }];
            }
        }
        else
            return [];
    }
    _raisePredefinedPeriodSelected(index) {
        let name = this.options.ViewModel.DateTimePeriods[index].Name;
        this.predefinedRangeChanged && this.predefinedRangeChanged(name);
    }
    _showCustomTimePeriodDialog() {
        this._getCustomTimePeriodDialog().show({
            range: this._getCurrentRange(),
            groupInterval: this.options.ViewModel.Argument.DateTimeGroupInterval,
            isIntYearGroupInterval: this._isIntYearGroupInterval(),
            firstDayOfWeek: this._getFirstDayOfWeek(),
            displayFormat: this._getSliderMarkerFormat()
        });
    }
    _isIntYearGroupInterval() {
        var viewModel = this.options.ViewModel, argument = viewModel.Argument;
        return argument && argument.DateTimeGroupInterval === 'Year' && argument.Type !== 'DateTime';
    }
}
export class rangeFilterSelection {
    constructor(range) {
        this.setMinimum(range.startValue);
        this.setMaximum(range.endValue);
    }
    getMaximum() {
        return this.maximum;
    }
    setMaximum(value) {
        this.maximum = value;
    }
    getMinimum() {
        return this.minimum;
    }
    setMinimum(value) {
        this.minimum = value;
    }
}
