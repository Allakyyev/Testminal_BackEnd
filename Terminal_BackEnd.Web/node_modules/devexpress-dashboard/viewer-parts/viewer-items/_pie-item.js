/**
* DevExpress Dashboard (_pie-item.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { format as stringFormat } from 'devextreme/core/utils/string';
import * as $ from 'jquery';
import { chartHelper } from '../../data/_chart-helper';
import { createJQueryCallbacks, deepExtend, extend } from '../../data/_jquery-helpers';
import { selectionHelper } from '../../data/_selection-helper';
import { allowSelectValue, checkValuesAreEqual, getAxisPointValue, getTagValue, tooltipContainerSelector } from '../../data/_utils';
import { zIndex } from '../../data/_z-index';
import { itemDataAxisNames } from '../../data/item-data/item-data-axis-names';
import { RenderHelper } from '../widgets/_render-helper';
import { widgetViewerItem } from './_widget-viewer-item';
var pieSizeGroup = 0;
const defaultPieProportions = 4 / 3;
const defaultPieAndLabelProportions = 3 / 5;
export class pieItem extends widgetViewerItem {
    constructor(container, options) {
        super(container, options);
        this.itemElementCustomColor = createJQueryCallbacks();
        this.sizeGroupId = undefined;
        this.sizeGroupId = ++pieSizeGroup;
        this._createPieMouseEventController();
    }
    get dataController() { return this._dataController; }
    set dataController(dataController) { this._dataController = dataController; }
    _initializeData(newOptions) {
        super._initializeData(newOptions);
        if (this.dataController) {
            this._dataController.elementCustomColor = args => this._elementCustomColor(args);
        }
    }
    _clearSelectionUnsafe() {
        super._clearSelectionUnsafe();
        var that = this, viewModel = that.options.ViewModel, piesViewer = that.widgetsViewer;
        if (viewModel && viewModel.SelectionEnabled && viewModel.SelectionMode !== chartHelper.SelectionMode.Series) {
            $.each(piesViewer.itemsList, function () {
                if (this._widget) {
                    this._widget.clearSelection();
                }
            });
        }
    }
    updateContentStateUnsafe() {
        var that = this;
        if (that._getCustomHoverEnabled()) {
            var argumentHoverMode = 'none', seriesHoverEnabled = false, targetAxes = this._getTargetAxes();
            if (targetAxes.length == 1) {
                if (targetAxes[0] == itemDataAxisNames.chartArgumentAxis)
                    argumentHoverMode = 'allArgumentPoints';
                else
                    seriesHoverEnabled = true;
            }
            else {
                if (targetAxes.length == 2) {
                    argumentHoverMode = 'point';
                    seriesHoverEnabled = true;
                }
            }
            $.each(this.widgetsViewer.itemsList, function (index, viewer) {
                viewer._widget.option('commonSeriesSettings.hoverMode', argumentHoverMode);
                viewer._hoverEnabled = seriesHoverEnabled;
            });
        }
    }
    selectTupleUnsafe(tuple, state) {
        var that = this, isPointSelection = that.options.ViewModel.SelectionMode === chartHelper.SelectionMode.Points, seriesValue = getAxisPointValue(tuple, itemDataAxisNames.chartSeriesAxis), argumentValue = getAxisPointValue(tuple, itemDataAxisNames.chartArgumentAxis);
        $.each(that.widgetsViewer.itemsList, function (index, viewer) {
            if (seriesValue) {
                if (selectionHelper._checkWidgetCorrespondsToValue(viewer, seriesValue)) {
                    if (argumentValue)
                        selectionHelper.setSelectedArguments(viewer._widget, [argumentValue], state);
                    else if (isPointSelection)
                        selectionHelper.selectWholePie(viewer._widget, state);
                    else
                        selectionHelper.setSelectedWidgetViewer(viewer, [seriesValue], state);
                }
            }
            else if (argumentValue) {
                selectionHelper.setSelectedArguments(viewer._widget, [argumentValue], state);
            }
        });
    }
    _setSelectionUnsafe(values) {
        super._setSelectionUnsafe(values);
        this.clearSelection();
        this._applySelection();
    }
    _elementCustomColor(eventArgs) {
        this.itemElementCustomColor.fire(this.getName(), eventArgs);
    }
    _createPieMouseEventController() {
        var that = this;
        that.pieMouseEventController = new pieMouseEventController();
        that.pieMouseEventController.ready.add(function () {
            var data = { pie: that.pieMouseEventController.pieData, slice: that.pieMouseEventController.sliceData };
            that._raiseItemClick(data);
        });
    }
    _isHoverEnabled() {
        return super._isHoverEnabled() && this._isItemSelectionEnabled();
    }
    _isItemSelectionEnabled() {
        var viewModel = this.options.ViewModel;
        return viewModel && viewModel.SelectionEnabled && (viewModel.SelectionMode === chartHelper.SelectionMode.Series);
    }
    _isLabelsVisible() {
        var viewModel = this.options.ViewModel;
        return viewModel && (viewModel.LabelContentType !== 'None');
    }
    _isShowPieCaptions() {
        var viewModel = this.options.ViewModel;
        return viewModel && viewModel.ShowPieCaptions;
    }
    _supportAnimation() {
        return true;
    }
    _getSpecificWidgetViewerOptions() {
        var that = this, specificOptions = that._isLabelsVisible() ? {
            itemOptions: {
                minWidth: 200,
                proportions: defaultPieAndLabelProportions,
                ignoreProportions: true
            }
        } : {
            itemOptions: {
                minWidth: 100,
                proportions: this._isShowPieCaptions() ? defaultPieProportions : 1,
                ignoreProportions: true
            }
        };
        return deepExtend(specificOptions, super._getSpecificWidgetViewerOptions());
    }
    _getWidgetType() {
        return 'pieChart';
    }
    _getDataSource() {
        if (!this.options.ViewModel) {
            return {};
        }
        var that = this, viewModel = that.options.ViewModel, isPointSelectionEnabled = that._getPointSelectionEnabled(), selectionMode = that._selectionMode(), seriesAxisPoints = that._dataController.getSeriesAxisPoints(), selectedValuesList = that._getSelectedValues(), dataSource = [], currentSeriesPath, seriesPropsValues;
        seriesAxisPoints.forEach(seriesAxisPoint => {
            currentSeriesPath = seriesAxisPoint.getUniquePath();
            that._dataController.getValueDataMembers().forEach((valueDataMember, valueIndex) => {
                let dataSourceItem = {
                    animation: that._getAnimationOptions(),
                    sizeGroup: that.sizeGroupId,
                    legend: {
                        visible: false
                    },
                    minDiameter: 0.75,
                    resolveLabelOverlapping: 'shift',
                    onIncidentOccurred: RenderHelper.widgetIncidentOccurred,
                    onPointClick: that._getSelectPointsHandler(),
                    onPointHoverChanged: that._getHoverPointsHandler(),
                    palette: RenderHelper.getDefaultPalette(),
                    pointSelectionMode: 'multiple',
                    commonSeriesSettings: {
                        hoverMode: isPointSelectionEnabled && (selectionMode !== 'none') ? 'allArgumentPoints' : 'none'
                    },
                    customizePoint: function () {
                        var result = { color: that._dataController.getColor(this.tag.axisPoint, seriesAxisPoint, that._getMeasuresIds(this.tag), this.tag.colorMeasureId) };
                        let interactionValue = that._getElementInteractionValue(this, that.options.ViewModel);
                        if (interactionValue && interactionValue.axisPoint && !allowSelectValue(interactionValue.axisPoint.getUniquePath())) {
                            result.hoverStyle = { hatching: 'none' };
                        }
                        return result;
                    }
                };
                dataSourceItem.tag = { axisPoint: seriesAxisPoint };
                extend(dataSourceItem, that._configureHover(currentSeriesPath));
                if (selectedValuesList && that._isItemSelectionEnabled()) {
                    $.each(selectedValuesList, function (__, selectedValue) {
                        if (checkValuesAreEqual(currentSeriesPath, selectedValue))
                            dataSourceItem.isSelected = true;
                    });
                }
                if (viewModel.ShowPieCaptions) {
                    dataSourceItem.title = {
                        text: that._dataController.getValueDisplayNames(seriesAxisPoint, valueIndex),
                        font: {
                            size: 18
                        }
                    };
                }
                seriesPropsValues = {
                    type: (viewModel.PieType === 'Donut') ? 'doughnut' : 'pie',
                    argumentField: 'x',
                    valueField: 'y',
                    label: {
                        visible: that._isLabelsVisible(),
                        position: viewModel.LabelPosition == 'Inside' ? 'inside' : 'columns'
                    },
                    point: {
                        visible: true
                    },
                    segmentsDirection: 'anticlockwise',
                    paintNullPoints: true
                };
                if (seriesPropsValues.label.visible) {
                    seriesPropsValues.label.connector = {
                        visible: true,
                        width: 1
                    };
                    seriesPropsValues.label.customizeText = that._getFormatLabelHandler(viewModel.LabelContentType);
                }
                dataSourceItem.series = [seriesPropsValues];
                dataSourceItem.dataSource = that._dataController.createDataSource(seriesAxisPoint, valueDataMember);
                dataSourceItem.tooltip = {
                    enabled: (viewModel.TooltipContentType !== 'None')
                };
                if (dataSourceItem.tooltip.enabled) {
                    dataSourceItem.tooltip.container = tooltipContainerSelector;
                    dataSourceItem.tooltip.customizeTooltip = function (label) {
                        return { text: that._getFormatLabelHandler(viewModel.TooltipContentType)(label) };
                    };
                    dataSourceItem.tooltip.font = {
                        size: 14
                    };
                    dataSourceItem.tooltip.zIndex = zIndex.dashboardItemTooltips;
                }
                dataSource.push(dataSourceItem);
            });
        });
        return (dataSource.length == 1 && dataSource[0].dataSource.length == 0) ? [] : dataSource;
    }
    _getPointSelectionEnabled() {
        var viewModel = this.options.ViewModel;
        return viewModel.SelectionEnabled && (viewModel.SelectionMode === chartHelper.SelectionMode.Argument || viewModel.SelectionMode === chartHelper.SelectionMode.Points);
    }
    _getFormatLabelHandler(valueType) {
        var that = this;
        return function (label) {
            var pointTexts = that._dataController.getPointDisplayTexts(label.point.tag, label.value, label.percent), tooltipPattern = that._getTooltipPattern(valueType);
            switch (valueType) {
                case 'Argument':
                    return pointTexts.argumentText;
                case 'Percent':
                    return pointTexts.percentText;
                case 'Value':
                    return pointTexts.valueText;
                case 'ValueAndPercent':
                    return stringFormat(tooltipPattern, pointTexts.valueText, pointTexts.percentText);
                case 'ArgumentAndPercent':
                    return stringFormat(tooltipPattern, pointTexts.argumentText, pointTexts.percentText);
                case 'ArgumentAndValue':
                    return stringFormat(tooltipPattern, pointTexts.argumentText, pointTexts.valueText);
                case 'ArgumentValueAndPercent':
                    return stringFormat(tooltipPattern, pointTexts.argumentText, pointTexts.valueText, pointTexts.percentText);
                default:
                    return '';
            }
        };
    }
    _getTooltipPattern(valueType) {
        switch (valueType) {
            case 'ValueAndPercent':
                return '{0} ({1})';
            case 'ArgumentAndPercent':
            case 'ArgumentAndValue':
                return '{0}: {1}';
            case 'ArgumentValueAndPercent':
                return '{0}: {1} ({2})';
            default:
                return '';
        }
    }
    _getElementInteractionValue(element, viewModel) {
        if (this._isItemSelectionEnabled())
            return super._getElementInteractionValue(element, viewModel);
        return element.tag;
    }
    _getOnClickHandler() {
        var that = this;
        return function (e) {
            that._pieMouseEventHandler(e.item);
        };
    }
    _getSelectPointsHandler() {
        var that = this;
        return function (e) {
            var viewModel = that.options.ViewModel, selectionMode = that._selectionMode(), isPointSelectionEnalbed = viewModel.SelectionEnabled && (viewModel.SelectionMode === chartHelper.SelectionMode.Argument) && selectionMode !== 'none';
            that._sliceMouseEventHandler(e.target);
        };
    }
    _getOnHoverHandler() {
        var that = this;
        return function (e) {
            that.pieMouseEventController.pieData = e.item;
            that._raiseItemHover({ pie: e.item }, e.state);
        };
    }
    _getHoverPointsHandler() {
        var that = this;
        return function (e) {
            that._raiseItemHover({ pie: that.pieMouseEventController.pieData, slice: e.target });
        };
    }
    _pieMouseEventHandler(element) {
        this.pieMouseEventController.setPieData(element);
    }
    _sliceMouseEventHandler(element) {
        this.pieMouseEventController.setSliceData(element);
    }
    _getDataPoint(element) {
        var that = this, viewModel = that.options.ViewModel, slice = element.slice, sliceTag = slice ? slice.tag : undefined, pie = element.pie, pieTag = pie ? pie.tag : undefined, argumentsValues = sliceTag ? getTagValue(sliceTag) : [], titleValues = pieTag ? getTagValue(pieTag) : [], argumentIndex = (slice && !sliceTag) ? slice.index : undefined, elementIndex = (pie && !pieTag) ? pie.index : undefined, measureIndex = argumentIndex ? argumentIndex : elementIndex ? elementIndex : 0;
        return {
            getValues: function (name) {
                switch (name) {
                    case itemDataAxisNames.chartArgumentAxis:
                        return argumentsValues;
                    case itemDataAxisNames.chartSeriesAxis:
                        return titleValues;
                    default:
                        return null;
                }
            },
            getDeltaIds: function () {
                return [];
            },
            getMeasureIds: function () {
                return slice ? that._getMeasuresIds(slice.tag) : [];
            }
        };
    }
    _getMeasuresIds(sliceTag) {
        return sliceTag ? sliceTag.dataMembers : [];
    }
    _isMultiDataSupported() {
        return true;
    }
    _getWidget() {
        if (this.widgetsViewer) {
            var pieWidgetViewers = this.widgetsViewer.itemsList, piesList = [];
            $.each(pieWidgetViewers, function () {
                piesList.push(this._widget);
            });
            return piesList;
        }
        else {
            return undefined;
        }
    }
    _applySelectionUnsafe() {
        var that = this;
        that.getSelectedTuples().forEach(tuple => that.selectTuple(tuple, true));
    }
}
export class pieMouseEventController {
    constructor() {
        this.shouldRaise = false;
        this.ready = createJQueryCallbacks();
        this.timer = 0;
    }
    setPieData(data) {
        this.pieData = data;
        if (this.ready) {
            this.ready.fire();
        }
        this.pieData = undefined;
        this.sliceData = undefined;
    }
    setSliceData(data) {
        this.sliceData = data;
    }
}
