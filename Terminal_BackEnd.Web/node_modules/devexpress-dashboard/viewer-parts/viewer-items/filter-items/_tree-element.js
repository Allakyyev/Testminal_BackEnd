/**
* DevExpress Dashboard (_tree-element.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import dxTreeList from 'devextreme/ui/tree_list';
import dxTreeView from 'devextreme/ui/tree_view';
import { KEY_EXPR } from '../../../data/data-controllers/_filter-element-data-controller';
import { getLocalizationById } from '../../../data/localization/_default';
import { specialValues } from '../../../data/special-values';
import { $unwrap } from '../../../data/_jquery-helpers';
import { localizationId } from '../../../data/_localization-ids';
import { ALL_ELEMENT, localizer } from '../../../data/_localizer';
import { wrapHash } from '../../../data/_utils';
import { LegacySettings } from '../../legacy-settings';
import { filterElementBaseItem } from './_base-element';
export let cssTreeViewClassNames = {
    borderVisible: 'dx-treeview-border-visible',
    topBorder: 'dx-dashboard-top-border',
    item: 'dx-dashboard-tree-item'
};
export class treeViewFilterElement extends filterElementBaseItem {
    get dataController() { return this._dataController; }
    set dataController(dataController) { this._dataController = dataController; }
    get filterDataController() { return this._dataController; }
    _setSelectionUnsafe(values) {
        super._setSelectionUnsafe(values);
        var selection = this._dataController.selection;
        if (!LegacySettings.useLegacyTreeView && this.widget != null && this.widget.getSelectedRowKeys('leavesOnly').sort().toString() !== selection.sort().toString()) {
            this._lock();
            this.widget.selectRows(selection).always(() => this._unlock());
        }
    }
    _generateInnerBorderClassesUnsafe(element) {
        var classes = super._generateInnerBorderClassesUnsafe(element);
        if (!this._isPaneEmpty()) {
            classes.push(cssTreeViewClassNames.item);
        }
        if (element) {
            if (this._isPaneEmpty()) {
                element.classList.remove(cssTreeViewClassNames.item);
            }
            else {
                element.classList.add(cssTreeViewClassNames.item);
            }
        }
        return classes;
    }
    _clearSelectionUnsafe() {
        if (!!this.options.useNeutralFilterMode) {
            this._lock();
            this.widget.selectRows([]).always(() => this._unlock());
        }
    }
    renderContentUnsafe(element, changeExisting, afterRenderCallback) {
        super.renderContentUnsafe(element, changeExisting, afterRenderCallback);
        var widgetElement = $unwrap(this.widget.element());
        if (LegacySettings.useLegacyTreeView && this._isPaneEmpty() && this.visualMode !== 'content') {
            widgetElement.classList.add(cssTreeViewClassNames.borderVisible);
        }
        else {
            widgetElement.classList.remove(cssTreeViewClassNames.borderVisible);
        }
        return false;
    }
    _getWidgetName() {
        return LegacySettings.useLegacyTreeView ? 'dxTreeView' : 'dxTreeList';
    }
    _createWidget(div, opts) {
        return LegacySettings.useLegacyTreeView ? new dxTreeView(div, opts) : new dxTreeList(div, opts);
    }
    _getOptions(includeActions) {
        var that = this;
        return LegacySettings.useLegacyTreeView ?
            {
                items: that._dataController.dataSource,
                width: '100%',
                height: '100%',
                keyExpr: 'key',
                hoverStateEnabled: false,
                scrollDirection: 'both',
                showCheckBoxesMode: 'selectAll',
                rootValue: null,
                selectAllText: ALL_ELEMENT.text,
                selectNodesRecursive: true,
                onSelectionChanged: includeActions ? e => that._raiseItemClick(e.component.getNodes()) : undefined,
                encodeNoDataText: true,
                noDataText: getLocalizationById('DashboardStringId.FilterElementNoDataToDisplay'),
            } :
            {
                dataSource: that._dataController.dataSource,
                itemsExpr: 'items',
                dataStructure: 'tree',
                columns: [{
                        caption: ALL_ELEMENT.text,
                        dataField: 'text',
                        encodeHtml: that._isEncodeHtml()
                    }],
                selection: {
                    allowSelectAll: true,
                    mode: 'multiple',
                    recursive: true
                },
                scrolling: {
                    mode: 'virtual'
                },
                sorting: {
                    mode: 'none'
                },
                searchPanel: {
                    placeholder: localizer.getString(localizationId.SearchNullValuePrompt),
                    visible: this._enableSearch,
                    width: '100%',
                    searchVisibleColumnsOnly: true
                },
                autoExpandAll: that.options.ViewModel.AutoExpandNodes,
                expandNodesOnFiltering: true,
                showRowLines: false,
                showBorders: that.hasParentContainer() && this.visualMode !== 'content',
                width: '100%',
                height: '100%',
                keyExpr: KEY_EXPR,
                hoverStateEnabled: false,
                rootValue: null,
                noDataText: getLocalizationById('DashboardStringId.FilterElementNoDataToDisplay'),
                onContentReady: (e) => {
                    let scrollable = e.component.getScrollable();
                    if (scrollable) {
                        scrollable.off('scroll', this._onScrollChanged);
                        scrollable.on('scroll', this._onScrollChanged);
                    }
                },
                onEditorPrepared: (e) => {
                    $unwrap(e.editorElement).classList.remove('dx-treelist-checkbox-size');
                },
                onSelectionChanged: includeActions ? e => {
                    if (!this._isLocked()) {
                        if (e.currentSelectedRowKeys.length > 0 && e.currentDeselectedRowKeys.length > 0)
                            throw new Error('TREEVIEW has an incorrect selection');
                        this._raiseItemClick(this._getSelectedBranches(e.currentSelectedRowKeys.length > 0 ? e.currentSelectedRowKeys : e.currentDeselectedRowKeys, e.currentSelectedRowKeys.length > 0));
                    }
                } : undefined
            };
    }
    _fillChildren(node, branch, isSelected, branches, hash) {
        node.children && node.children.forEach(childNode => {
            const childNodeBranch = branch.slice();
            childNodeBranch.push(childNode.data.value);
            this._fillChildren(childNode, childNodeBranch, isSelected, branches, hash);
        });
        if (!node.children || !node.children.length) {
            const nullValueItemsCount = this.dataController.multiData ? this.dataController.multiData.getDimensions().length - branch.length : 0;
            for (let i = 0; i < nullValueItemsCount; i++) {
                branch.push(specialValues.olapNullValueGuid);
            }
            if ((isSelected && !!hash[branch]) || (!isSelected && !hash[branch]))
                return true;
            branches[branch] = branch;
        }
    }
    _getSelectedBranches(keys, isSelected = false) {
        const branches = {};
        const hash = wrapHash(this._getSelectedValues());
        for (let i = 0; i < keys.length; i++) {
            let treeList = this.widget;
            const node = treeList.getNodeByKey(keys[i]);
            const branch = [node.data.value];
            let curNode = node;
            while (curNode.parent && curNode.level > 0) {
                branch.unshift(curNode.parent.data.value);
                curNode = curNode.parent;
            }
            this._fillChildren(node, branch, isSelected, branches, hash);
        }
        return Object.keys(branches).map(key => branches[key]);
    }
    _onScrollChanged(e) {
        if (e.scrollOffset.top !== 0) {
            $unwrap(e.element).classList.add(cssTreeViewClassNames.topBorder);
        }
        else {
            $unwrap(e.element).classList.remove(cssTreeViewClassNames.topBorder);
        }
    }
}
