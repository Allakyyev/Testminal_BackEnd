/**
* DevExpress Dashboard (_cssHelper.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
export function createCssPropertyWrapper(propertyName, propertyValue) {
    return { propertyName, propertyValue };
}
export function getEmptyCssPropertyWrappersArray() {
    return [];
}
const dashboardStyleTagClass = 'dx-dashboard-styles';
const dashboardStyleTagSelector = '.' + dashboardStyleTagClass;
export function findStylesElement(relativeElement) {
    var _a, _b;
    const style = (_b = (_a = relativeElement === null || relativeElement === void 0 ? void 0 : relativeElement.closest('.dx-dashboard-widget-container')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.querySelector(dashboardStyleTagSelector);
    return style || document.querySelector(dashboardStyleTagSelector);
}
export function createStylesElement(rootElement = document.head, nonce) {
    let style = rootElement.querySelector(dashboardStyleTagSelector);
    if (!style) {
        style = document.createElement('style');
        style.setAttribute('type', 'text/css');
        style.classList.add(dashboardStyleTagClass);
        if (nonce) {
            style.setAttribute('nonce', nonce);
        }
        rootElement.prepend(style);
    }
}
export function removeStylesElement() {
    var _a;
    (_a = findStylesElement()) === null || _a === void 0 ? void 0 : _a.remove();
}
export function addToStyles(styles, relativeElement) {
    var style = findStylesElement(relativeElement);
    style.textContent += styles;
    return () => {
        style.textContent = style.textContent.replace(styles, '');
    };
}
export function createCssClass(cssSelector, cssProperties, relativeElement) {
    return addToStyles(cssSelector + ' {' + convertCssPropertyWrappersToString(cssProperties) + '}', relativeElement);
}
export function convertCssPropertyWrappersToString(properties) {
    return properties
        .filter(x => x && x.propertyValue)
        .map(value => value.propertyName + ': ' + value.propertyValue + ';')
        .join(' ');
}
export function convertCssPropertyWrappersToObject(properties) {
    return properties
        .filter(x => x && x.propertyValue)
        .reduce((result, current) => {
        result[current.propertyName] = current.propertyValue;
        return result;
    }, {});
}
