/**
* DevExpress Dashboard (_utils.layout.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { deepExtend, extend } from '../../data/_jquery-helpers';
export let size = function (w, h) {
    return {
        width: w,
        height: h,
        plus: function (arg) {
            var correctSize = function (value, addition) {
                return (Number.MAX_VALUE - value >= addition) ? value + addition : Number.MAX_VALUE;
            };
            return size(correctSize(this.width, arg.width), correctSize(this.height, arg.height));
        },
        minus: function (arg) {
            return size(this.width - arg.width, this.height - arg.height);
        },
        compareByDirections: function (size) {
            if (!size) {
                return ['width', 'height'];
            }
            else {
                var differentDirections = [];
                if (size.width != this.width)
                    differentDirections.push('width');
                if (size.height != this.height)
                    differentDirections.push('height');
                return differentDirections;
            }
        },
        constrain: function (constraints) {
            var that = this, ensureDirection = function (direction) {
                return ensureRange(that[direction], constraints.min[direction], constraints.max[direction]);
            };
            return size(ensureDirection('width'), ensureDirection('height'));
        },
        clone: function () {
            return size(this.width, this.height);
        }
    };
};
export let constraints = function (pMin, pMax) {
    return {
        min: pMin,
        max: pMax,
        consolidate: function (sourceConstraints, consolidateDirection) {
            return constraints(this._consolidatePart(sourceConstraints, consolidateDirection, 'min'), this._consolidatePart(sourceConstraints, consolidateDirection, 'max'));
        },
        isFixed: function (direction) {
            if (direction) {
                var differentDirections = this.min.compareByDirections(this.max);
                return differentDirections.indexOf(direction) === -1;
            }
            else {
                return false;
            }
        },
        _consolidatePart: function (sourceConstraints, consolidateDirection, part) {
            var that = this, resultSize = size(), direction = consolidateDirection ? consolidateDirection : 'width', crossDirection = getCrossDirection(direction), consolidateSumFunc = function (currentDirection) {
                var val1 = that[part][currentDirection], val2 = sourceConstraints[part][currentDirection];
                return (val1 === Number.MAX_VALUE || val2 === Number.MAX_VALUE) ? Number.MAX_VALUE : (val1 + val2);
            }, consolidateMaxMinFunc = function (currentDirection, isCross) {
                var val1 = that[part][currentDirection], val2 = sourceConstraints[part][currentDirection];
                return (part === 'min' || isCross) ? Math.max(val1, val2) : Math.min(val1, val2);
            };
            resultSize[direction] = consolidateDirection ? consolidateSumFunc(direction) : consolidateMaxMinFunc(direction, false);
            resultSize[crossDirection] = consolidateMaxMinFunc(crossDirection, !!consolidateDirection);
            return resultSize;
        }
    };
};
export let nonClientElement = function (width, height) {
    var resultSize = size(width, height);
    return {
        getBounds: function () {
            return resultSize.clone();
        }
    };
};
export let getCrossDirection = function (direction) {
    return direction === 'width' ? 'height' : 'width';
};
export let defConstraints = function (valueMin, valueMax) {
    var paramValueMin = valueMin === undefined ? 0 : valueMin, paramValueMax = valueMax === undefined ? Number.MAX_VALUE : valueMax;
    return new this.constraints(new this.size(paramValueMin, paramValueMin), new this.size(paramValueMax, paramValueMax));
};
export let defSizeInPercents = function (direction, value) {
    var size = new this.size(1, 1);
    size[direction] = value;
    return size;
};
export let checkRange = function (value, min, max) {
    return min <= value && value <= max;
};
export let ensureRange = function (value, min, max) {
    return Math.max(Math.min(value, max), min);
};
export let deepCloneObject = function (injectObject, sourceObject, noDeepCopyPropsValues) {
    var copyObj = {};
    extend(copyObj, sourceObject);
    for (var prop in noDeepCopyPropsValues)
        delete copyObj[prop];
    deepExtend(injectObject, copyObj);
    extend(injectObject, noDeepCopyPropsValues);
    return injectObject;
};
