/**
* DevExpress Dashboard (_caption-toolbar-adapter.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import dxTooltip from 'devextreme/ui/tooltip';
import { $unwrap } from '../../../data/_jquery-helpers';
import { createSvgIconElement } from '../../../data/_utils';
import { RenderHelper } from '../_render-helper';
import { cssClasses } from './_caption-toolbar-css-classes';
import { PopupMenuCreator } from './_popup-menu-creator';
export class DashboardCaptionToolbarAdapter {
    constructor(_encodeHtml) {
        this._encodeHtml = _encodeHtml;
    }
    createToolbarItem(item, controlContainer, popupContainer, onMenuItemClick) {
        if (item.isSeparator)
            return this._createSeparatorItem(item);
        this._validate(item);
        let toolbarItem = {
            location: item.location
        };
        if (item.type === 'button' || item.type === 'menu') {
            toolbarItem.widget = 'dxButton';
            toolbarItem.options = this._createToolbarItemOptions(item, controlContainer, popupContainer, onMenuItemClick);
        }
        else {
            if (item.template) {
                toolbarItem.template = item.template;
            }
            else if (item.text) {
                toolbarItem.template = () => {
                    let textDiv = document.createElement('div');
                    textDiv.classList.add(cssClasses.ellipsisText);
                    RenderHelper.html(textDiv, item.text, this._encodeHtml);
                    return textDiv;
                };
            }
            else {
                return undefined;
            }
        }
        return toolbarItem;
    }
    _applyText(item, text) {
        if (this._encodeHtml === false) {
            item.html = text;
        }
        else {
            item.text = text;
        }
    }
    _createToolbarItemOptions(item, controlContainer, popupContainer, onMenuItemClick) {
        var _a;
        let itemOptions = {};
        if (item.template === undefined) {
            let classNames = this._fillCssClasses(item);
            if (classNames.length > 0) {
                itemOptions.elementAttr = {
                    class: classNames.join(' ')
                };
            }
        }
        if (item.tooltip) {
            itemOptions.onContentReady = (data) => {
                let options = this._createTooltipOptions(item.tooltip, data.element, popupContainer);
                let toolTipElement = document.createElement('div');
                toolTipElement.classList.add(item.tooltip['className']);
                new dxTooltip(toolTipElement, options);
                $unwrap(data.element).appendChild(toolTipElement);
            };
        }
        else if (item.hint) {
            itemOptions.hint = item.hint;
        }
        if (item.template) {
            itemOptions.template = item.template;
        }
        else if (item.icon) {
            itemOptions.template = (buttonData, contentElement) => {
                return createSvgIconElement(item.icon);
            };
            if (!!((_a = itemOptions.elementAttr) === null || _a === void 0 ? void 0 : _a.class)) {
                itemOptions.elementAttr.class += ' dx-button-has-icon';
            }
            else
                itemOptions.elementAttr = { class: 'dx-button-has-icon' };
        }
        else if (item.text) {
            this._applyText(itemOptions, item.text);
        }
        if (item.type === 'button' && item.click) {
            itemOptions.onClick = data => item.click(data.element);
        }
        else if (item.type === 'menu' && item.menu && (item.menu.items && item.menu.items.length > 0 || item.menu.itemTemplate)) {
            itemOptions.onClick = data => PopupMenuCreator.toggleMenu($unwrap(data.element).querySelector('.dx-button-content'), item.menu, popupContainer, controlContainer, onMenuItemClick);
        }
        if (!!item.disabled) {
            itemOptions.disabled = item.disabled;
        }
        return itemOptions;
    }
    _createTooltipOptions(tooltip, target, container) {
        let contentTemplate = typeof tooltip === 'string' ? (element) => RenderHelper.html($unwrap(element), tooltip, this._encodeHtml) : tooltip.template;
        return {
            target: target,
            contentTemplate: contentTemplate,
            showEvent: 'mouseenter',
            hideEvent: 'mouseleave',
            container,
        };
    }
    _fillCssClasses(item) {
        let classNames = [];
        if (item.checked && item.type === 'button')
            classNames.push(cssClasses.checked);
        if (item.icon) {
            classNames.push(item.icon);
        }
        else if (item.text) {
            classNames.push(cssClasses.textButton);
        }
        return classNames;
    }
    _validate(item) {
        let menu = item.menu;
        let isIconMenuItem = item.type === 'menu' && menu && menu.type === 'icons';
        if (isIconMenuItem && menu.columnCount !== undefined && menu.columnCount < 1)
            throw new Error('The columnCount property must be greater than zero.');
    }
    _createSeparatorItem(item) {
        return {
            location: item.location,
            html: '<div class="' + cssClasses.captionPanelSeparator + '"></div>'
        };
    }
}
