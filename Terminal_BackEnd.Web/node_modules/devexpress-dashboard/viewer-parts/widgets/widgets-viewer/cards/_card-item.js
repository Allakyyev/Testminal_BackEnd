/**
* DevExpress Dashboard (_card-item.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { encodeHtml as encodeStringToHtml } from 'devextreme/core/utils/string';
import dxTooltip from 'devextreme/ui/tooltip';
import dxSparkline from 'devextreme/viz/sparkline';
import * as $ from 'jquery';
import { DashboardFormatHelper } from '../../../../data/_format-helper';
import { deepExtend } from '../../../../data/_jquery-helpers';
import { DeltaIndicator } from '../../indicators/_delta-indicator';
import { SimpleIndicator } from '../../indicators/_simple-indicator';
import { BaseWidgetItem } from '../_base-widget-item';
import { cssClassNames } from '../_css-class-names';
var hiddenContainer = $.fn.constructor('<div>', {
    id: cssClassNames.cardHiddenContainer
}), nowrapHiddenContainer = $.fn.constructor('<div>', {
    id: cssClassNames.cardNowrapHiddenContainer
}), _ceil = Math.ceil, _floor = Math.floor, TITLE_TOOLTIP_PREFIX = 'titleTooltip', TITLE_CONTAINER_PREFIX = 'titleContainer';
export let cardValue1Counter = 0;
function getSparklineHeight(cardHeight) {
    return cardHeight * 0.25;
}
function calcRowCount(text, encodeHtml) {
    var text = encodeHtml ? encodeStringToHtml(text) : text, words = text.split(' '), i, openSpan = '<span>', closeSpan = ' </span>', markup = '', prevOffsetTop, lineCount = 1, clientRects;
    for (i = 0; i < words.length; i++) {
        markup += openSpan + words[i] + closeSpan;
    }
    hiddenContainer.html(openSpan + markup + closeSpan);
    clientRects = hiddenContainer.children()[0].getClientRects();
    prevOffsetTop = clientRects[0].top;
    for (i = 1; i < clientRects.length; i++) {
        if (clientRects[i].top !== prevOffsetTop) {
            lineCount++;
            prevOffsetTop = clientRects[i].top;
        }
    }
    return lineCount;
}
export class CardItem extends BaseWidgetItem {
    constructor(item, options) {
        super(CardItem.ensureOptions(options));
        var getText = function (text) {
            if (text) {
                return options.encodeHtml ? $.fn.constructor('<div>').text(text).html() : text;
            }
            return '';
        }, defaultValues = {
            type: 'none',
            hasPositiveMeaning: false,
            text: {
                value: '',
                useDefaultColor: false
            }
        };
        item = item || {};
        this.data = item.data || {};
        this.title = getText(item.title);
        this.subTitle = getText(item.subTitle);
        this.sparklineOptions = item.sparklineOptions || {};
        this.variableValue1 = deepExtend({}, defaultValues, item.variableValue1);
        this.variableValue2 = deepExtend({}, defaultValues, item.variableValue2);
        defaultValues.text.useDefaultColor = true;
        this.mainValue = deepExtend({}, defaultValues, item.mainValue);
        this.indicator = {
            hasPositiveMeaning: this.mainValue.hasPositiveMeaning,
            type: this.mainValue.type
        };
        if (hiddenContainer.parent().length === 0) {
            hiddenContainer.appendTo(document.body);
        }
        if (nowrapHiddenContainer.parent().length === 0) {
            nowrapHiddenContainer.appendTo(document.body);
        }
        this.subtitleDotsIndex = 0;
    }
    static ensureOptions(options) {
        options = options || {};
        options.type = 'cardItem';
        options.ignoreProportions = false;
        return options;
    }
    draw(widthCard, heightCard, cardIndex, commonItemsOptions) {
        var that = this, options = that._options, paddings = commonItemsOptions.paddings, sparklineHeight = commonItemsOptions.sparklineHeight, imgDiv, itemDiv, sparklineContainer, topContentOffset = parseFloat(paddings.top), title, subtitle, variableValue1, variableValue2, mainValueDiv, textSubtitle = options.encodeHtml ? that._getEllipsisText(that.subTitle, commonItemsOptions, _floor((widthCard - paddings.right - paddings.left) * 0.6)) : that.subTitle, index = cardValue1Counter++, value1Text = that._getText('variableValue1'), value2Text = that._getText('variableValue2'), mainValueText = that._getText('mainValue'), titleContainerId = TITLE_CONTAINER_PREFIX + index;
        itemDiv = super.draw(widthCard, heightCard, cardIndex);
        title = ['<div id="' + titleContainerId + '" class="', cssClassNames.cardTitle + '" style="padding:' + topContentOffset + 'px ' + paddings.left + 'px 0px ' + paddings.left + 'px;">', that.title, '</div>'].join('');
        subtitle = ['<div class="', cssClassNames.cardSubtitle, '" style="padding-left:' + paddings.left + 'px;">', textSubtitle, '</div>'].join('');
        variableValue1 = ['<span class="', cssClassNames.cardVariableValue1, ' ', that._getValueClassName('variableValue1') + '" style="padding-right:' + paddings.right + 'px;">', value1Text, '</span>'].join('');
        variableValue2 = ['<span class="', cssClassNames.cardVariableValue2, ' ', that._getValueClassName('variableValue2'), '" style="padding-right:' + paddings.right + 'px;">', value2Text, '</span>'].join('');
        imgDiv = ['<div class="', cssClassNames.cardIndicator, '" style="padding-left:' + paddings.left + 'px;">',
            SimpleIndicator.getIndicator(that.indicator.type, that.indicator.hasPositiveMeaning), '</div>'].join('');
        mainValueDiv = ['<span class="', cssClassNames.cardMainValue, ' ', that._getValueClassName('mainValue'), '" style="padding-right:' + paddings.right + 'px;">', mainValueText, '</div>'].join('');
        itemDiv.innerHTML = title + subtitle + variableValue1 + variableValue2 + imgDiv + mainValueDiv;
        that._addTooltip(itemDiv, titleContainerId, TITLE_TOOLTIP_PREFIX, that.title, index);
        if (options.hasSparkline) {
            sparklineContainer = document.createElement('div');
            sparklineContainer.classList.add(cssClassNames.cardSparkline);
            sparklineContainer.style.left = paddings.left;
            sparklineContainer.style.left = paddings.right;
            itemDiv.appendChild(sparklineContainer);
            that.sparklineOptions.size = {
                width: widthCard - paddings.left - paddings.right,
                height: sparklineHeight
            };
            new dxSparkline(sparklineContainer, that.sparklineOptions);
        }
        return itemDiv;
    }
    resize(width, height, index, commonItemsOptions) {
        var that = this, sparklineHeight = commonItemsOptions.sparklineHeight, itemDiv = that._itemDiv, imgDiv = itemDiv.querySelector('.' + cssClassNames.cardIndicator), subTitle = itemDiv.querySelector('.' + cssClassNames.cardSubtitle), sparklineContainer = itemDiv.querySelector('.' + cssClassNames.cardSparkline), paddings = that._options.padding, widthWithoutpaddings = width - paddings.right - paddings.left;
        if (!itemDiv.childElementCount) {
            that.draw(width, height, index, commonItemsOptions);
            return that._itemDiv;
        }
        if (that._options.encodeHtml)
            subTitle.innerText = that._getEllipsisText(subTitle.innerText, commonItemsOptions, _floor((widthWithoutpaddings) * 0.6));
        if (sparklineHeight) {
            dxSparkline.getInstance(sparklineContainer)
                .option('size', { width: widthWithoutpaddings, height: sparklineHeight });
        }
        return itemDiv;
    }
    getCssStyle(width, height, commonItemsOptions, prefix) {
        var that = this, paddings = commonItemsOptions.paddings, sparklineHeight = commonItemsOptions.sparklineHeight, widthWithoutpaddings = width - paddings.right - paddings.left, fontSizes = commonItemsOptions.fontSizes, baseStyle = super.getCssStyle(width, height, commonItemsOptions, prefix), titleStyle = prefix + ' ' + that._formStyle('.' + cssClassNames.cardTitle, {
            'font-size': fontSizes.title,
            'min-height': _ceil(fontSizes.title * 1.3),
            'line-height': fontSizes.title
        }), subTitleStyle = prefix + ' ' + that._formStyle('.' + cssClassNames.cardSubtitle, {
            'min-height': _ceil(fontSizes.subTitle * 1.3) * 2,
            'font-size': fontSizes.subTitle
        }), indicatorContainerStyle = prefix + ' ' + that._formStyle('.' + cssClassNames.cardIndicator, {
            height: _ceil(0.18 * (height - sparklineHeight)),
            width: _ceil(0.24 * (height - sparklineHeight)),
            bottom: paddings.bottom + sparklineHeight + 3
        }), variableValue1Style = prefix + ' ' + that._formStyle('.' + cssClassNames.cardVariableValue1, {
            'font-size': fontSizes.variableValue1,
            'line-height': fontSizes.variableValue1,
            bottom: fontSizes.variableValue2 + fontSizes.mainValue
        }), variableValue2Style = prefix + ' ' + that._formStyle('.' + cssClassNames.cardVariableValue2, {
            'font-size': fontSizes.variableValue2,
            'line-height': fontSizes.variableValue2,
            'bottom': fontSizes.mainValue
        }), mainValueStyle = prefix + ' ' + that._formStyle('.' + cssClassNames.cardMainValue, {
            'font-size': fontSizes.mainValue,
            'line-height': fontSizes.mainValue,
            bottom: paddings.bottom + sparklineHeight
        }), sparklineContainerStyle = sparklineHeight ?
            prefix + ' ' + that._formStyle('.' + cssClassNames.cardSparkline, {
                height: sparklineHeight,
                width: widthWithoutpaddings
            }) : '';
        return [baseStyle, titleStyle, subTitleStyle, indicatorContainerStyle, variableValue1Style, variableValue2Style, mainValueStyle, sparklineContainerStyle].join(' ');
    }
    static calcFonts(height) {
        return {
            title: (~~(height * 0.22)),
            subTitle: (~~(height * 0.14)),
            mainValue: (~~(height * 0.30)),
            variableValue1: (~~(height * 0.14)),
            variableValue2: (~~(height * 0.14))
        };
    }
    calcCommonItemSpecificOptions(width, height) {
        var that = this, options = that._options, sparklineHeight = options.hasSparkline ? getSparklineHeight(height) : 0, fontSizes = CardItem.calcFonts(height - sparklineHeight), paddings = Object.assign({ top: 0, left: 0, right: 0, bottom: 0 }, options.padding), oneRowHeight;
        hiddenContainer.width(_floor((width - paddings.right - paddings.left) * 0.6))
            .css('fontSize', fontSizes.subTitle);
        nowrapHiddenContainer.css('fontSize', fontSizes.subTitle);
        oneRowHeight = hiddenContainer.text('a').height();
        hiddenContainer.empty();
        return {
            paddings: paddings,
            sparklineHeight: sparklineHeight,
            fontSizes: fontSizes,
            oneRowHeight: oneRowHeight
        };
    }
    dispose() {
        var that = this;
        BaseWidgetItem.prototype.dispose.apply(that, arguments);
        that.data = null;
        that.sparklineOptions = null;
        that.indicator = null;
        that._options = null;
    }
    _addTooltip(itemDiv, containerId, tooltipPrefix, text, index) {
        var container = itemDiv.querySelector('#' + containerId);
        var div = document.createElement('div');
        div.id = tooltipPrefix + index;
        container.appendChild(div);
        div.innerText = text;
        new dxTooltip(div, {
            target: '#' + containerId,
            showEvent: { name: 'mouseenter', delay: 800 },
            hideEvent: 'mouseleave'
        });
    }
    _getDefaultOptions() {
        var defaults = BaseWidgetItem.prototype._getDefaultOptions.apply(this, arguments), options = {
            padding: {
                top: 3,
                left: 12,
                right: 12,
                bottom: 10
            },
            font: {
                family: 'Segoe UI, HelveticaNeue, Trebuchet MS, Verdana',
                weight: 'normal'
            },
            title: {
                color: 'black'
            },
            subTitle: {
                color: '#B6B6B6'
            }
        };
        return deepExtend({}, defaults, options);
    }
    _getText(classText) {
        var that = this;
        var valueOptions = that[classText].text, value = valueOptions.value, format = valueOptions.format;
        if (format) {
            return DashboardFormatHelper.format(parseFloat(value), format);
        }
        else {
            return that._options.encodeHtml ? encodeStringToHtml(value) : value.toString();
        }
    }
    _getClassFromIndicator(type, hasPositiveMeaning, useDefaultColor) {
        return DeltaIndicator.getIndicatorColorType(type, hasPositiveMeaning, useDefaultColor);
    }
    _getCardStyle(isSelected) {
        return isSelected ? this._options.selectionStyle : this._options.style;
    }
    _getValueClassName(classText) {
        var that = this, value = that[classText], useDefaultColor = value.text.useDefaultColor, hasPositiveMeaning = value.hasPositiveMeaning, type = value.type;
        return that._getClassFromIndicator(type, hasPositiveMeaning, useDefaultColor);
    }
    _setSubtitleDotsIndex(index) {
        this._subtitleDotsIndex = index;
    }
    _getEllipsisText(inputText, commonItemsOptions, containerWidth) {
        if (!inputText || inputText === '') {
            return '';
        }
        var that = this, subtitleRowsCount = calcRowCount(inputText, that._options.encodeHtml), fullTextWidth, proportionalTextLen, updatedText, movingDirection, threeDots = '...', i, endIndex, dotsIndex = this._subtitleDotsIndex;
        if (subtitleRowsCount <= 2) {
            return inputText;
        }
        fullTextWidth = nowrapHiddenContainer.text(inputText).width();
        proportionalTextLen = _floor(2 * containerWidth * inputText.length / fullTextWidth);
        updatedText = inputText.substring(0, proportionalTextLen - 3) + threeDots;
        subtitleRowsCount = calcRowCount(updatedText, that._options.encodeHtml);
        if (subtitleRowsCount > 2) {
            movingDirection = -1;
        }
        else {
            movingDirection = 1;
        }
        for (i = 1; i < proportionalTextLen; i += 2) {
            endIndex = dotsIndex ? dotsIndex + i * movingDirection : proportionalTextLen - 3 + i * movingDirection;
            updatedText = inputText.substring(0, endIndex) + threeDots;
            subtitleRowsCount = calcRowCount(updatedText, that._options.encodeHtml);
            if (movingDirection === 1 && subtitleRowsCount === 3) {
                updatedText = inputText.substring(0, endIndex - 3) + threeDots;
                that._setSubtitleDotsIndex(updatedText.length - 3);
                return updatedText;
            }
            if (movingDirection === -1 && subtitleRowsCount === 2) {
                that._setSubtitleDotsIndex(updatedText.length - 3);
                return updatedText;
            }
        }
        return updatedText;
    }
}
