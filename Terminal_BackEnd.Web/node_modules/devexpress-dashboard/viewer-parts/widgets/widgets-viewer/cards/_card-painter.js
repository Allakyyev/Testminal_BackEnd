/**
* DevExpress Dashboard (_card-painter.js)
* Version:  23.2.7
* Build date: Jun 25, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { guid } from '@devexpress/analytics-core/analytics-internal';
import dxTooltip from 'devextreme/ui/tooltip';
import dxSparkline from 'devextreme/viz/sparkline';
import * as $ from 'jquery';
import { createCssPropertyWrapper, getEmptyCssPropertyWrappersArray } from '../../../viewer/_cssHelper';
import { DeltaIndicator } from '../../indicators/_delta-indicator';
import { SimpleIndicator } from '../../indicators/_simple-indicator';
import { layoutCardCssClassNames } from '../_css-class-names';
import { cardIndicatorElement, cardSparklineElement, horizontalAlignment, verticalAlignment } from './_card-layout';
export class cardPainter {
    constructor(data, controlContainer) {
        this.data = data;
        this.controlContainer = controlContainer;
    }
    draw(cardArrangements, layout, _styleSettingsProvider) {
        this.layout = layout;
        this._styleSettingsProvider = _styleSettingsProvider;
        var cardHeight = cardArrangements.getCardHeight();
        var cardWidth = cardArrangements.getCardWidth();
        this._cardStyle = layout.getStyleSettings(this.data);
        var $divCardLayout = $.fn.constructor('<div>', {})
            .addClass(layoutCardCssClassNames.card)
            .css({
            height: cardHeight,
            width: cardWidth,
            'background-color': layout.getCardBackgroundColor()
        });
        const disposables = this.appendCardContent(cardArrangements, layout, $divCardLayout);
        let divCardLayout = $divCardLayout.get(0);
        if (this._cardStyle)
            this._styleSettingsProvider.applyStyleSettings(divCardLayout, null, this._cardStyle, true, null, null, true);
        return { element: $divCardLayout, disposables };
    }
    appendCardContent(cardArrangements, layout, parent) {
        var contentHeight = cardArrangements.getCardContentHeight();
        var contentWidth = cardArrangements.getCardContentWidth();
        var actualContentWidth = layout.maxWidth > 0 ? Math.min(contentWidth, Math.max(layout.minWidth, layout.maxWidth)) : contentWidth;
        const element = $.fn.constructor('<div>')
            .css({
            height: contentHeight,
            width: actualContentWidth
        }).addClass(layoutCardCssClassNames.content);
        parent.append(element);
        return this.appendRows(layout.rows, actualContentWidth, element);
    }
    appendRows(rowModels, contentWidth, parent) {
        var topRows = $.fn.constructor('<div>', { 'class': layoutCardCssClassNames.contentTopRows }), centerRows = $.fn.constructor('<div>', {}), bottomRows = $.fn.constructor('<div>', { 'class': layoutCardCssClassNames.contentBottomRows });
        const disposables = rowModels.reduce((acc, rowModel) => {
            var rowDiv = $.fn.constructor('<div>');
            rowDiv.css('paddingBottom', rowModel.indent);
            switch (rowModel.vAlignment) {
                case verticalAlignment.top:
                    topRows.append(rowDiv);
                    break;
                case verticalAlignment.bottom:
                    bottomRows.append(rowDiv);
                    break;
                case verticalAlignment.center:
                default:
                    centerRows.append(rowDiv);
            }
            acc.push(...this.createRow(rowModel.elements, rowDiv, contentWidth));
            return acc;
        }, []);
        if (centerRows.children().length > 0)
            parent.append([topRows, centerRows, bottomRows]);
        else if (topRows.children().length > 0 || bottomRows.children().length > 0) {
            parent.append([topRows, bottomRows]);
        }
        return disposables;
    }
    createRow(elementModels, rowDiv, contentWidth) {
        var leftElements = [], centerElements = [], rightElements = [];
        elementModels.forEach(elementModel => {
            switch (elementModel.hAlignment) {
                case horizontalAlignment.left:
                    leftElements.push(elementModel);
                    break;
                case horizontalAlignment.right:
                    rightElements.push(elementModel);
                    break;
                case horizontalAlignment.center:
                default:
                    centerElements.push(elementModel);
                    break;
            }
        });
        if (centerElements.length != 0 && leftElements.length == 0 && rightElements.length == 0) {
            rowDiv.addClass(layoutCardCssClassNames.rowOnlyCenterElements);
            return this.appendElements(centerElements, contentWidth, rowDiv);
        }
        else {
            rowDiv.addClass(layoutCardCssClassNames.row);
            var leftDiv = $.fn.constructor('<div>', { 'class': layoutCardCssClassNames.rowLeftRightElements }).appendTo(rowDiv), rightDiv = $.fn.constructor('<div>', { 'class': layoutCardCssClassNames.rowLeftRightElements }).appendTo(rowDiv);
            return [].concat(this.appendElements(leftElements.concat(centerElements), contentWidth, leftDiv), this.appendElements(rightElements, contentWidth, rightDiv));
        }
    }
    appendElements(elements, contentWidth, parent) {
        return elements.map(element => {
            if (element instanceof cardIndicatorElement) {
                return this.appendIndicatorElement(element, parent);
            }
            else if (element instanceof cardSparklineElement) {
                return this.appendSparklineElement(element, contentWidth, parent);
            }
            else {
                return this.appendDataElement(element, parent);
            }
        }).filter(x => !!x);
    }
    appendIndicatorElement(indicatorElement, parent) {
        let indicatorDiv = $.fn.constructor('<div>');
        indicatorDiv.addClass(layoutCardCssClassNames.indicatorElement);
        let styleSettings = indicatorElement.getStyleSettings(this.data);
        let cfIconType;
        if (styleSettings)
            cfIconType = this._styleSettingsProvider.getIconType(styleSettings);
        if (cfIconType)
            this._styleSettingsProvider.applyIndicatorStyle(indicatorDiv[0], cfIconType);
        else {
            indicatorDiv
                .css({
                height: indicatorElement.height,
                width: indicatorElement.width
            })
                .append(SimpleIndicator.getIndicator(indicatorElement.getIndicatorType(this.data), indicatorElement.getIsGood(this.data)));
        }
        parent.append(indicatorDiv);
        return null;
    }
    appendSparklineElement(sparklineElement, contentWidth, parent) {
        var sparklineOptions = sparklineElement.getSparklineOptions(this.data);
        sparklineOptions.size = {
            height: sparklineElement.height,
            width: contentWidth
        };
        var sparklineContainer = document.createElement('div');
        const sparkline = new dxSparkline(sparklineContainer, sparklineOptions);
        const elementDiv = $.fn.constructor('<div>')
            .css({
            height: sparklineElement.height
        }).append(sparklineContainer);
        parent.append(elementDiv);
        return sparkline;
    }
    appendDataElement(textElement, parent) {
        var elementText = textElement.getText(this.data);
        let elementCssProperties = getEmptyCssPropertyWrappersArray();
        var elementDiv = $.fn.constructor('<div>')
            .addClass(layoutCardCssClassNames.rowElement)
            .text(elementText);
        this.setElementColor(textElement, elementDiv, elementCssProperties);
        let cssClassName = layoutCardCssClassNames.rowElement + '-' + this.data.getKpiElementId() + '-' + guid();
        if (!this.layout.hasRowElementCssClass(cssClassName)) {
            elementCssProperties.push(createCssPropertyWrapper('font-family', textElement.fontFamily));
            elementCssProperties.push(createCssPropertyWrapper('font-size', textElement.fontSize + 'pt'));
            let cssSelector = '.' + layoutCardCssClassNames.content + ' .' + layoutCardCssClassNames.rowElement + '.' + cssClassName;
            this.layout.addRowElementCss(cssClassName, cssSelector, elementCssProperties, this.controlContainer);
        }
        elementDiv.addClass(cssClassName);
        var textDiv = document.createElement('div');
        textDiv.innerText = elementText;
        elementDiv.append(textDiv);
        let styleSettings = textElement.getStyleSettings(this.data);
        if (styleSettings)
            this._styleSettingsProvider.applyStyleSettings(elementDiv[0], null, styleSettings, false, null, true, false);
        const tooltip = new dxTooltip(textDiv, {
            container: this.controlContainer,
            target: elementDiv.get(0),
            showEvent: { name: 'mouseenter', delay: 800 },
            hideEvent: 'mouseleave'
        });
        parent.append(elementDiv);
        return tooltip;
    }
    setElementColor(element, elementDiv, elementProperties) {
        if (element.predefinedColor !== 'NotSet') {
            switch (element.predefinedColor) {
                case 'Main':
                    elementDiv.addClass(DeltaIndicator.getIndicatorColorType(null, null, true));
                    break;
                case 'Neutral':
                    elementDiv.addClass(DeltaIndicator.getIndicatorColorType());
                    break;
                case 'Bad':
                    elementDiv.addClass(DeltaIndicator.getIndicatorColorType('down', false));
                    break;
                case 'Good':
                    elementDiv.addClass(DeltaIndicator.getIndicatorColorType('up', true));
                    break;
                case 'Warning':
                    elementDiv.addClass(DeltaIndicator.getIndicatorColorType('warning'));
                    break;
                case 'Delta':
                    elementDiv.addClass(DeltaIndicator.getIndicatorColorType(element.getIndicatorType(this.data), element.getIsGood(this.data)));
                    break;
            }
        }
        else if (element.color) {
            elementProperties.push(createCssPropertyWrapper('color', element.color));
        }
        else {
            elementDiv.addClass(DeltaIndicator.getIndicatorColorType(null, null, true));
        }
    }
}
